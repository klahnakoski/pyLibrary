
# HG changeset patch
# User Carsten "Tomcat" Book <cbook@mozilla.com>
# Date 1501145845 -7200
# Node ID e5693cea1ec944ca077c7a46c5f127c828a90f1b
# Parent  c1ed71da57073d0f5fdbd279c9ad6037f9ae2d06# Parent  c8262422f24494702bc965a241ca6bdaadead161
merge mozilla-inbound to mozilla-central a=merge

diff --git a/.clang-format-ignore b/.clang-format-ignore
--- a/.clang-format-ignore
+++ b/.clang-format-ignore
@@ -19,17 +19,17 @@
 ^gfx/cairo/.*
 ^gfx/graphite2/.*
 ^gfx/harfbuzz/.*
 ^gfx/ots/.*
 ^gfx/qcms/.*
 ^gfx/skia/.*
 ^gfx/vr/openvr/.*
 ^gfx/webrender.*
-^gfx/webrender_traits.*
+^gfx/webrender_api.*
 ^gfx/ycbcr/.*
 ^intl/hyphenation/hyphen/.*
 ^intl/icu/.*
 ^ipc/chromium/.*
 ^js/src/ctypes/libffi/.*
 ^js/src/dtoa.c.*
 ^js/src/jit/arm64/vixl/.*
 ^media/ffvpx/.*
diff --git a/accessible/base/SelectionManager.cpp b/accessible/base/SelectionManager.cpp
--- a/accessible/base/SelectionManager.cpp
+++ b/accessible/base/SelectionManager.cpp
@@ -43,60 +43,59 @@ SelectionManager::SelectionManager() :
   mCaretOffset(-1), mAccWithCaret(nullptr)
 {
 
 }
 
 void
 SelectionManager::ClearControlSelectionListener()
 {
-  if (!mCurrCtrlFrame)
-    return;
-
-  const nsFrameSelection* frameSel = mCurrCtrlFrame->GetConstFrameSelection();
-  NS_ASSERTION(frameSel, "No frame selection for the element!");
-
-  mCurrCtrlFrame = nullptr;
-  if (!frameSel)
-    return;
 
   // Remove 'this' registered as selection listener for the normal selection.
-  Selection* normalSel = frameSel->GetSelection(SelectionType::eNormal);
-  normalSel->RemoveSelectionListener(this);
+  nsCOMPtr<nsISelection> normalSel = do_QueryReferent(mCurrCtrlNormalSel);
+  if (normalSel) {
+    normalSel->AsSelection()->RemoveSelectionListener(this);
+    mCurrCtrlNormalSel = nullptr;
+  }
 
   // Remove 'this' registered as selection listener for the spellcheck
   // selection.
-  Selection* spellSel = frameSel->GetSelection(SelectionType::eSpellCheck);
-  spellSel->RemoveSelectionListener(this);
+  nsCOMPtr<nsISelection> spellSel = do_QueryReferent(mCurrCtrlSpellSel);
+  if (spellSel) {
+    spellSel->AsSelection()->RemoveSelectionListener(this);
+    mCurrCtrlSpellSel = nullptr;
+  }
 }
 
 void
 SelectionManager::SetControlSelectionListener(dom::Element* aFocusedElm)
 {
   // When focus moves such that the caret is part of a new frame selection
   // this removes the old selection listener and attaches a new one for
   // the current focus.
   ClearControlSelectionListener();
 
-  mCurrCtrlFrame = aFocusedElm->GetPrimaryFrame();
-  if (!mCurrCtrlFrame)
+  nsIFrame* controlFrame = aFocusedElm->GetPrimaryFrame();
+  if (!controlFrame)
     return;
 
-  const nsFrameSelection* frameSel = mCurrCtrlFrame->GetConstFrameSelection();
+  const nsFrameSelection* frameSel = controlFrame->GetConstFrameSelection();
   NS_ASSERTION(frameSel, "No frame selection for focused element!");
   if (!frameSel)
     return;
 
   // Register 'this' as selection listener for the normal selection.
-  Selection* normalSel = frameSel->GetSelection(SelectionType::eNormal);
-  normalSel->AddSelectionListener(this);
+  nsCOMPtr<nsISelection> normalSel = frameSel->GetSelection(SelectionType::eNormal);
+  normalSel->AsSelection()->AddSelectionListener(this);
+  mCurrCtrlNormalSel = do_GetWeakReference(normalSel);
 
   // Register 'this' as selection listener for the spell check selection.
-  Selection* spellSel = frameSel->GetSelection(SelectionType::eSpellCheck);
-  spellSel->AddSelectionListener(this);
+  nsCOMPtr<nsISelection> spellSel = frameSel->GetSelection(SelectionType::eSpellCheck);
+  spellSel->AsSelection()->AddSelectionListener(this);
+  mCurrCtrlSpellSel = do_GetWeakReference(spellSel);
 }
 
 void
 SelectionManager::AddDocSelectionListener(nsIPresShell* aPresShell)
 {
   const nsFrameSelection* frameSel = aPresShell->ConstFrameSelection();
 
   // Register 'this' as selection listener for the normal selection.
diff --git a/accessible/base/SelectionManager.h b/accessible/base/SelectionManager.h
--- a/accessible/base/SelectionManager.h
+++ b/accessible/base/SelectionManager.h
@@ -116,17 +116,18 @@ protected:
 
   /**
    * Process DOM selection change. Fire selection and caret move events.
    */
   void ProcessSelectionChanged(SelData* aSelData);
 
 private:
   // Currently focused control.
-  WeakFrame mCurrCtrlFrame;
   int32_t mCaretOffset;
   HyperTextAccessible* mAccWithCaret;
+  nsWeakPtr mCurrCtrlNormalSel;
+  nsWeakPtr mCurrCtrlSpellSel;
 };
 
 } // namespace a11y
 } // namespace mozilla
 
 #endif
diff --git a/accessible/base/nsAccessibilityService.cpp b/accessible/base/nsAccessibilityService.cpp
--- a/accessible/base/nsAccessibilityService.cpp
+++ b/accessible/base/nsAccessibilityService.cpp
@@ -53,16 +53,17 @@
 #include "Logging.h"
 #endif
 
 #ifdef MOZ_CRASHREPORTER
 #include "nsExceptionHandler.h"
 #endif
 
 #include "nsImageFrame.h"
+#include "nsINamed.h"
 #include "nsIObserverService.h"
 #include "nsLayoutUtils.h"
 #include "nsPluginFrame.h"
 #include "SVGGeometryFrame.h"
 #include "nsTreeBodyFrame.h"
 #include "nsTreeColumns.h"
 #include "nsTreeUtils.h"
 #include "nsXBLPrototypeBinding.h"
@@ -407,16 +408,17 @@ nsAccessibilityService::GetRootDocumentA
   return nullptr;
 }
 
 #ifdef XP_WIN
 static StaticAutoPtr<nsTArray<nsCOMPtr<nsIContent> > > sPendingPlugins;
 static StaticAutoPtr<nsTArray<nsCOMPtr<nsITimer> > > sPluginTimers;
 
 class PluginTimerCallBack final : public nsITimerCallback
+                                , public nsINamed
 {
   ~PluginTimerCallBack() {}
 
 public:
   explicit PluginTimerCallBack(nsIContent* aContent) : mContent(aContent) {}
 
   NS_DECL_ISUPPORTS
 
@@ -439,21 +441,27 @@ public:
 
     // We couldn't get a doc accessible so presumably the document went away.
     // In this case don't leak our ref to the content or timer.
     sPendingPlugins->RemoveElement(mContent);
     sPluginTimers->RemoveElement(aTimer);
     return NS_OK;
   }
 
+  NS_IMETHOD GetName(nsACString& aName) final
+  {
+    aName.AssignLiteral("PluginTimerCallBack");
+    return NS_OK;
+  }
+
 private:
   nsCOMPtr<nsIContent> mContent;
 };
 
-NS_IMPL_ISUPPORTS(PluginTimerCallBack, nsITimerCallback)
+NS_IMPL_ISUPPORTS(PluginTimerCallBack, nsITimerCallback, nsINamed)
 #endif
 
 already_AddRefed<Accessible>
 nsAccessibilityService::CreatePluginAccessible(nsPluginFrame* aFrame,
                                                nsIContent* aContent,
                                                Accessible* aContext)
 {
   // nsPluginFrame means a plugin, so we need to use the accessibility support
diff --git a/accessible/tests/mochitest/focus/a11y.ini b/accessible/tests/mochitest/focus/a11y.ini
--- a/accessible/tests/mochitest/focus/a11y.ini
+++ b/accessible/tests/mochitest/focus/a11y.ini
@@ -1,9 +1,9 @@
 [DEFAULT]
 support-files =
   !/accessible/tests/mochitest/*.js
 
 [test_focusedChild.html]
-skip-if = (os == 'win' && (os_version == '6.2' || os_version == '6.3')) # bug 845134
+skip-if = (os == 'win' && (os_version == '6.2' || os_version == '6.3' || os_version == '10.0.15063')) # bug 845134
 [test_takeFocus.html]
 skip-if = buildapp == 'mulet'
 [test_takeFocus.xul]
diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -1509,16 +1509,18 @@ pref("browser.translation.ui.show", fals
 // Allows to define the translation engine. Bing is default, Yandex may optionally switched on.
 pref("browser.translation.engine", "bing");
 
 // Telemetry settings.
 // Determines if Telemetry pings can be archived locally.
 pref("toolkit.telemetry.archive.enabled", true);
 // Enables sending the shutdown ping when Firefox shuts down.
 pref("toolkit.telemetry.shutdownPingSender.enabled", true);
+// Enables sending the shutdown ping using the pingsender from the first session.
+pref("toolkit.telemetry.shutdownPingSender.enabledFirstSession", false);
 // Enables sending the 'new-profile' ping on new profiles.
 pref("toolkit.telemetry.newProfilePing.enabled", true);
 
 // Telemetry experiments settings.
 pref("experiments.enabled", true);
 pref("experiments.manifest.fetchIntervalSeconds", 86400);
 pref("experiments.manifest.uri", "https://telemetry-experiment.cdn.mozilla.net/manifest/v1/firefox/%VERSION%/%CHANNEL%");
 // Whether experiments are supported by the current application profile.
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -31,17 +31,17 @@ XPCOMUtils.defineLazyPreferenceGetter(th
           Deprecated:false, E10SUtils:false, ExtensionsUI: false, FormValidationHandler:false,
           GMPInstallManager:false, LightweightThemeManager:false, Log:false,
           LoginManagerParent:false, NewTabUtils:false, PageThumbs:false,
           PluralForm:false, Preferences:false, PrivateBrowsingUtils:false,
           ProcessHangMonitor:false, PromiseUtils:false, ReaderMode:false,
           ReaderParent:false, RecentWindow:false, SafeBrowsing: false,
           SessionStore:false,
           ShortcutUtils:false, SimpleServiceDiscovery:false, SitePermissions:false,
-          Social:false, TabCrashHandler:false, Task:false, TelemetryStopwatch:false,
+          Social:false, TabCrashHandler:false, TelemetryStopwatch:false,
           Translation:false, UITour:false, Utils:false, UpdateUtils:false,
           Weave:false,
           WebNavigationFrames: false, fxAccounts:false, gDevTools:false,
           gDevToolsBrowser:false, webrtcUI:false, ZoomUI:false,
           Marionette:false,
  */
 
 /**
@@ -80,17 +80,16 @@ XPCOMUtils.defineLazyPreferenceGetter(th
   ["RecentWindow", "resource:///modules/RecentWindow.jsm"],
   ["SafeBrowsing", "resource://gre/modules/SafeBrowsing.jsm"],
   ["SessionStore", "resource:///modules/sessionstore/SessionStore.jsm"],
   ["ShortcutUtils", "resource://gre/modules/ShortcutUtils.jsm"],
   ["SimpleServiceDiscovery", "resource://gre/modules/SimpleServiceDiscovery.jsm"],
   ["SitePermissions", "resource:///modules/SitePermissions.jsm"],
   ["Social", "resource:///modules/Social.jsm"],
   ["TabCrashHandler", "resource:///modules/ContentCrashHandlers.jsm"],
-  ["Task", "resource://gre/modules/Task.jsm"],
   ["TelemetryStopwatch", "resource://gre/modules/TelemetryStopwatch.jsm"],
   ["Translation", "resource:///modules/translation/Translation.jsm"],
   ["UITour", "resource:///modules/UITour.jsm"],
   ["UpdateUtils", "resource://gre/modules/UpdateUtils.jsm"],
   ["Utils", "resource://gre/modules/sessionstore/Utils.jsm"],
   ["Weave", "resource://services-sync/main.js"],
   ["WebNavigationFrames", "resource://gre/modules/WebNavigationFrames.jsm"],
   ["fxAccounts", "resource://gre/modules/FxAccounts.jsm"],
diff --git a/browser/base/content/test/tabcrashed/browser_shown.js b/browser/base/content/test/tabcrashed/browser_shown.js
--- a/browser/base/content/test/tabcrashed/browser_shown.js
+++ b/browser/base/content/test/tabcrashed/browser_shown.js
@@ -1,14 +1,17 @@
 "use strict";
 
 const PAGE = "data:text/html,<html><body>A%20regular,%20everyday,%20normal%20page.";
 const COMMENTS = "Here's my test comment!";
 const EMAIL = "foo@privacy.com";
 
+// Avoid timeouts, as in bug 1325530
+requestLongerTimeout(2);
+
 add_task(async function setup() {
   await setupLocalCrashReportServer();
 });
 
 /**
  * This function returns a Promise that resolves once the following
  * actions have taken place:
  *
diff --git a/browser/components/downloads/DownloadsCommon.jsm b/browser/components/downloads/DownloadsCommon.jsm
--- a/browser/components/downloads/DownloadsCommon.jsm
+++ b/browser/components/downloads/DownloadsCommon.jsm
@@ -42,28 +42,28 @@ XPCOMUtils.defineLazyModuleGetter(this, 
 XPCOMUtils.defineLazyModuleGetter(this, "PluralForm",
                                   "resource://gre/modules/PluralForm.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "AppConstants",
                                   "resource://gre/modules/AppConstants.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "AppMenuNotifications",
                                   "resource://gre/modules/AppMenuNotifications.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "CustomizableUI",
                                   "resource:///modules/CustomizableUI.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "DownloadHistory",
+                                  "resource://gre/modules/DownloadHistory.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "Downloads",
                                   "resource://gre/modules/Downloads.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "DownloadUIHelper",
                                   "resource://gre/modules/DownloadUIHelper.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "DownloadUtils",
                                   "resource://gre/modules/DownloadUtils.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "FileUtils",
                                   "resource://gre/modules/FileUtils.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "OS",
-                                  "resource://gre/modules/osfile.jsm")
-XPCOMUtils.defineLazyModuleGetter(this, "PlacesUtils",
-                                  "resource://gre/modules/PlacesUtils.jsm");
+                                  "resource://gre/modules/osfile.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "PrivateBrowsingUtils",
                                   "resource://gre/modules/PrivateBrowsingUtils.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "RecentWindow",
                                   "resource:///modules/RecentWindow.jsm");
 
 XPCOMUtils.defineLazyGetter(this, "DownloadsLogger", () => {
   let { ConsoleAPI } = Cu.import("resource://gre/modules/Console.jsm", {});
   let consoleOptions = {
@@ -737,42 +737,18 @@ DownloadsDataCtor.prototype = {
     if (oldState != newState) {
       if (download.succeeded ||
           (download.canceled && !download.hasPartialData) ||
           download.error) {
         // Store the end time that may be displayed by the views.
         download.endTime = Date.now();
 
         // This state transition code should actually be located in a Downloads
-        // API module (bug 941009).  Moreover, the fact that state is stored as
-        // annotations should be ideally hidden behind methods of
-        // nsIDownloadHistory (bug 830415).
-        if (!this._isPrivate) {
-          try {
-            let downloadMetaData = {
-              state: DownloadsCommon.stateOfDownload(download),
-              endTime: download.endTime,
-            };
-            if (download.succeeded) {
-              downloadMetaData.fileSize = download.target.size;
-            }
-            if (download.error && download.error.reputationCheckVerdict) {
-              downloadMetaData.reputationCheckVerdict =
-                download.error.reputationCheckVerdict;
-            }
-
-            PlacesUtils.annotations.setPageAnnotation(
-                          NetUtil.newURI(download.source.url),
-                          "downloads/metaData",
-                          JSON.stringify(downloadMetaData), 0,
-                          PlacesUtils.annotations.EXPIRE_WITH_HISTORY);
-          } catch (ex) {
-            Cu.reportError(ex);
-          }
-        }
+        // API module (bug 941009).
+        DownloadHistory.updateMetaData(download);
       }
 
       if (download.succeeded ||
           (download.error && download.error.becauseBlocked)) {
         this._notifyDownloadEvent("finish");
       }
     }
 
diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -34,17 +34,17 @@ XPCOMUtils.defineLazyModuleGetter(this, 
           FileUtils:false, FormValidationHandler:false, Integration:false,
           LightweightThemeManager:false, LoginHelper:false, LoginManagerParent:false,
           NetUtil:false, NewTabUtils:false, OS:false,
           PageThumbs:false, PdfJs:false, PermissionUI:false, PlacesBackups:false,
           PlacesUtils:false, PluralForm:false, PrivateBrowsingUtils:false,
           ProcessHangMonitor:false, ReaderParent:false, RecentWindow:false,
           RemotePrompt:false, SessionStore:false,
           ShellService:false, SimpleServiceDiscovery:false, TabCrashHandler:false,
-          Task:false, UITour:false, UIState:false, UpdateListener:false, WebChannel:false,
+          UITour:false, UIState:false, UpdateListener:false, WebChannel:false,
           WindowsRegistry:false, webrtcUI:false */
 
 
 
 /**
  * IF YOU ADD OR REMOVE FROM THIS LIST, PLEASE UPDATE THE LIST ABOVE AS WELL.
  * XXX Bug 1325373 is for making eslint detect these automatically.
  */
@@ -89,17 +89,16 @@ let initializedModules = {};
   ["ProcessHangMonitor", "resource:///modules/ProcessHangMonitor.jsm"],
   ["ReaderParent", "resource:///modules/ReaderParent.jsm"],
   ["RecentWindow", "resource:///modules/RecentWindow.jsm"],
   ["RemotePrompt", "resource:///modules/RemotePrompt.jsm"],
   ["SessionStore", "resource:///modules/sessionstore/SessionStore.jsm"],
   ["ShellService", "resource:///modules/ShellService.jsm"],
   ["SimpleServiceDiscovery", "resource://gre/modules/SimpleServiceDiscovery.jsm"],
   ["TabCrashHandler", "resource:///modules/ContentCrashHandlers.jsm"],
-  ["Task", "resource://gre/modules/Task.jsm"],
   ["UIState", "resource://services-sync/UIState.jsm"],
   ["UITour", "resource:///modules/UITour.jsm"],
   ["UpdateListener", "resource://gre/modules/UpdateListener.jsm", "init"],
   ["WebChannel", "resource://gre/modules/WebChannel.jsm"],
   ["WindowsRegistry", "resource://gre/modules/WindowsRegistry.jsm"],
   ["webrtcUI", "resource:///modules/webrtcUI.jsm", "init"],
 ].forEach(([name, resource, init]) => {
   if (init) {
diff --git a/browser/extensions/webcompat-reporter/content/WebCompatReporter.jsm b/browser/extensions/webcompat-reporter/content/WebCompatReporter.jsm
--- a/browser/extensions/webcompat-reporter/content/WebCompatReporter.jsm
+++ b/browser/extensions/webcompat-reporter/content/WebCompatReporter.jsm
@@ -6,16 +6,17 @@ this.EXPORTED_SYMBOLS = ["WebCompatRepor
 
 let { classes: Cc, interfaces: Ci, utils: Cu } = Components;
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 const TABLISTENER_JSM = "chrome://webcompat-reporter/content/TabListener.jsm";
 const WIDGET_ID = "webcompat-reporter-button";
+const PREF_STYLO_ENABLED = "layout.css.servo.enabled";
 
 XPCOMUtils.defineLazyModuleGetter(this, "CustomizableUI",
   "resource:///modules/CustomizableUI.jsm");
 
 XPCOMUtils.defineLazyGetter(this, "wcStrings", function() {
   return Services.strings.createBundle(
     "chrome://webcompat-reporter/locale/webcompat.properties");
 });
@@ -115,19 +116,28 @@ let WebCompatReporter = {
   //    so it can show a preview to the user and include it in FormData
   // Note: openWebCompatTab arguments are passed in as an array because they
   // are the result of a promise resolution.
   openWebCompatTab([gBrowser, tabData]) {
     const SCREENSHOT_MESSAGE = "WebCompat:SendScreenshot";
     const FRAMESCRIPT = "chrome://webcompat-reporter/content/wc-frame.js";
     let win = Services.wm.getMostRecentWindow("navigator:browser");
     const WEBCOMPAT_ORIGIN = new win.URL(WebCompatReporter.endpoint).origin;
+    let styloEnabled = Services.prefs.getBoolPref(PREF_STYLO_ENABLED, false);
+
+    let params = new URLSearchParams();
+    params.append("url", `${tabData.url}`);
+    params.append("src", "desktop-reporter");
+    if (styloEnabled) {
+        params.append("details", "layout.css.servo.enabled: true");
+        params.append("label", "type-stylo");
+    }
 
     let tab = gBrowser.loadOneTab(
-      `${WebCompatReporter.endpoint}?url=${encodeURIComponent(tabData.url)}&src=desktop-reporter`,
+      `${WebCompatReporter.endpoint}?${params}`,
       {inBackground: false, triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal()});
 
     // If we successfully got a screenshot blob, add a listener to know when
     // the new tab is loaded before sending it over.
     if (tabData && tabData.blob) {
       let browser = gBrowser.getBrowserForTab(tab);
       let loadedListener = {
         QueryInterface: XPCOMUtils.generateQI(["nsIWebProgressListener",
diff --git a/build/moz.configure/old.configure b/build/moz.configure/old.configure
--- a/build/moz.configure/old.configure
+++ b/build/moz.configure/old.configure
@@ -245,17 +245,16 @@ def old_configure_options(*options):
     '--with-android-distribution-directory',
     '--with-android-max-sdk',
     '--with-android-min-sdk',
     '--with-android-sdk',
     '--with-app-basename',
     '--with-app-name',
     '--with-arch',
     '--with-branding',
-    '--with-crashreporter-enable-percent',
     '--with-cross-lib',
     '--with-debug-label',
     '--with-default-mozilla-five-home',
     '--with-distribution-id',
     '--with-doc-include-dirs',
     '--with-doc-input-dirs',
     '--with-doc-output-dir',
     '--with-float-abi',
diff --git a/devtools/client/inspector/grids/test/browser.ini b/devtools/client/inspector/grids/test/browser.ini
--- a/devtools/client/inspector/grids/test/browser.ini
+++ b/devtools/client/inspector/grids/test/browser.ini
@@ -28,8 +28,9 @@ support-files =
 [browser_grids_grid-list-toggle-single-grid.js]
 [browser_grids_grid-outline-cannot-show-outline.js]
 [browser_grids_grid-outline-highlight-area.js]
 [browser_grids_grid-outline-highlight-cell.js]
 [browser_grids_grid-outline-selected-grid.js]
 [browser_grids_grid-outline-updates-on-grid-change.js]
 [browser_grids_highlighter-setting-rules-grid-toggle.js]
 [browser_grids_number-of-css-grids-telemetry.js]
+[browser_grids_restored-after-reload.js]
diff --git a/devtools/client/inspector/grids/test/browser_grids_restored-after-reload.js b/devtools/client/inspector/grids/test/browser_grids_restored-after-reload.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/inspector/grids/test/browser_grids_restored-after-reload.js
@@ -0,0 +1,87 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Tests that the grid highlighter is re-displayed after reloading a page and the grid
+// item is highlighted.
+
+const TEST_URI = `
+  <style type='text/css'>
+    #grid {
+      display: grid;
+    }
+  </style>
+  <div id="grid">
+    <div id="cell1">cell1</div>
+    <div id="cell2">cell2</div>
+  </div>
+`;
+
+const OTHER_URI = `
+  <style type='text/css'>
+    #grid {
+      display: grid;
+    }
+  </style>
+  <div id="grid">
+    <div id="cell1">cell1</div>
+    <div id="cell2">cell2</div>
+    <div id="cell3">cell3</div>
+  </div>
+`;
+
+add_task(function* () {
+  yield addTab("data:text/html;charset=utf-8," + encodeURIComponent(TEST_URI));
+  let { gridInspector, inspector } = yield openLayoutView();
+  let { document: doc } = gridInspector;
+  let { highlighters, store } = inspector;
+
+  yield selectNode("#grid", inspector);
+  let gridList = doc.getElementById("grid-list");
+  let checkbox = gridList.children[0].querySelector("input");
+
+  info("Toggling ON the CSS grid highlighter from the layout panel.");
+  let onHighlighterShown = highlighters.once("grid-highlighter-shown");
+  let onCheckboxChange = waitUntilState(store, state =>
+    state.grids.length == 1 &&
+    state.grids[0].highlighted);
+  checkbox.click();
+  yield onHighlighterShown;
+  yield onCheckboxChange;
+
+  info("Checking the CSS grid highlighter is created.");
+  ok(highlighters.highlighters[HIGHLIGHTER_TYPE],
+    "CSS grid highlighter is created in the highlighters overlay.");
+  ok(highlighters.gridHighlighterShown, "CSS grid highlighter is shown.");
+
+  info("Reload the page, expect the highlighter to be displayed once again and " +
+    "grid is checked");
+  let onStateRestored = highlighters.once("grid-state-restored");
+  let onGridListRestored = waitUntilState(store, state =>
+    state.grids.length == 1 &&
+    state.grids[0].highlighted);
+  yield refreshTab(gBrowser.selectedTab);
+  let { restored } = yield onStateRestored;
+  yield onGridListRestored;
+
+  info("Check that the grid highlighter can be displayed after reloading the page");
+  ok(restored, "The highlighter state was restored");
+  ok(highlighters.gridHighlighterShown, "CSS grid highlighter is shown.");
+
+  info("Navigate to another URL, and check that the highlighter is hidden and " +
+    "grid is unchecked");
+  let otherUri = "data:text/html;charset=utf-8," + encodeURIComponent(OTHER_URI);
+  onStateRestored = highlighters.once("grid-state-restored");
+  onGridListRestored = waitUntilState(store, state =>
+    state.grids.length == 1 &&
+    !state.grids[0].highlighted);
+  yield navigateTo(inspector, otherUri);
+  ({ restored } = yield onStateRestored);
+  yield onGridListRestored;
+
+  info("Check that the grid highlighter is hidden after navigating to a different page");
+  ok(!restored, "The highlighter state was not restored");
+  ok(!highlighters.gridHighlighterShown, "CSS grid highlighter is hidden.");
+});
diff --git a/devtools/client/inspector/inspector.js b/devtools/client/inspector/inspector.js
--- a/devtools/client/inspector/inspector.js
+++ b/devtools/client/inspector/inspector.js
@@ -103,31 +103,33 @@ function Inspector(toolbox) {
 
   // Store the URL of the target page prior to navigation in order to ensure
   // telemetry counts in the Grid Inspector are not double counted on reload.
   this.previousURL = this.target.url;
 
   this.nodeMenuTriggerInfo = null;
 
   this._handleRejectionIfNotDestroyed = this._handleRejectionIfNotDestroyed.bind(this);
+  this._onContextMenu = this._onContextMenu.bind(this);
   this._onBeforeNavigate = this._onBeforeNavigate.bind(this);
-  this.onNewRoot = this.onNewRoot.bind(this);
-  this._onContextMenu = this._onContextMenu.bind(this);
-  this.onTextBoxContextMenu = this.onTextBoxContextMenu.bind(this);
+  this._onMarkupFrameLoad = this._onMarkupFrameLoad.bind(this);
   this._updateSearchResultsLabel = this._updateSearchResultsLabel.bind(this);
+
+  this.onDetached = this.onDetached.bind(this);
+  this.onMarkupLoaded = this.onMarkupLoaded.bind(this);
   this.onNewSelection = this.onNewSelection.bind(this);
-  this.onDetached = this.onDetached.bind(this);
+  this.onNewRoot = this.onNewRoot.bind(this);
   this.onPaneToggleButtonClicked = this.onPaneToggleButtonClicked.bind(this);
-  this._onMarkupFrameLoad = this._onMarkupFrameLoad.bind(this);
   this.onPanelWindowResize = this.onPanelWindowResize.bind(this);
-  this.onSidebarShown = this.onSidebarShown.bind(this);
+  this.onShowBoxModelHighlighterForNode =
+    this.onShowBoxModelHighlighterForNode.bind(this);
   this.onSidebarHidden = this.onSidebarHidden.bind(this);
   this.onSidebarSelect = this.onSidebarSelect.bind(this);
-  this.onShowBoxModelHighlighterForNode =
-    this.onShowBoxModelHighlighterForNode.bind(this);
+  this.onSidebarShown = this.onSidebarShown.bind(this);
+  this.onTextBoxContextMenu = this.onTextBoxContextMenu.bind(this);
 
   this._target.on("will-navigate", this._onBeforeNavigate);
   this._detectingActorFeatures = this._detectActorFeatures();
 }
 
 Inspector.prototype = {
   /**
    * open is effectively an asynchronous constructor
@@ -774,32 +776,47 @@ Inspector.prototype = {
       // been queued up.
       if (this._pendingSelection != onNodeSelected) {
         return;
       }
       this._pendingSelection = null;
       this.selection.setNodeFront(defaultNode, "navigateaway");
 
       this._initMarkup();
-      this.once("markuploaded", () => {
-        if (!this.markup) {
-          return;
-        }
-        this.markup.expandNode(this.selection.nodeFront);
-        this.emit("new-root");
-      });
+      this.once("markuploaded", this.onMarkupLoaded);
 
       // Setup the toolbar again, since its content may depend on the current document.
       this.setupToolbar();
     };
     this._pendingSelection = onNodeSelected;
     this._getDefaultNodeForSelection()
         .then(onNodeSelected, this._handleRejectionIfNotDestroyed);
   },
 
+  /**
+   * Handler for "markuploaded" event fired on a new root mutation and after the markup
+   * view is initialized. Expands the current selected node and restores the saved
+   * highlighter state.
+   */
+  onMarkupLoaded: Task.async(function* () {
+    if (!this.markup) {
+      return;
+    }
+
+    this.markup.expandNode(this.selection.nodeFront);
+
+    // Restore the highlighter states prior to emitting "new-root".
+    yield Promise.all([
+      this.highlighters.restoreGridState(),
+      this.highlighters.restoreShapeState()
+    ]);
+
+    this.emit("new-root");
+  }),
+
   _selectionCssSelector: null,
 
   /**
    * Set the currently selected node unique css selector.
    * Will store the current target url along with it to allow pre-selection at
    * reload
    */
   set selectionCssSelector(cssSelector = null) {
diff --git a/devtools/client/inspector/shared/highlighters-overlay.js b/devtools/client/inspector/shared/highlighters-overlay.js
--- a/devtools/client/inspector/shared/highlighters-overlay.js
+++ b/devtools/client/inspector/shared/highlighters-overlay.js
@@ -47,25 +47,23 @@ function HighlightersOverlay(inspector) 
     shapes: {}
   };
 
   this.onClick = this.onClick.bind(this);
   this.onMarkupMutation = this.onMarkupMutation.bind(this);
   this.onMouseMove = this.onMouseMove.bind(this);
   this.onMouseOut = this.onMouseOut.bind(this);
   this.onWillNavigate = this.onWillNavigate.bind(this);
-  this.onNavigate = this.onNavigate.bind(this);
   this.showGridHighlighter = this.showGridHighlighter.bind(this);
   this.showShapesHighlighter = this.showShapesHighlighter.bind(this);
   this._handleRejection = this._handleRejection.bind(this);
   this._onHighlighterEvent = this._onHighlighterEvent.bind(this);
 
   // Add inspector events, not specific to a given view.
   this.inspector.on("markupmutation", this.onMarkupMutation);
-  this.inspector.target.on("navigate", this.onNavigate);
   this.inspector.target.on("will-navigate", this.onWillNavigate);
 
   EventEmitter.decorate(this);
 }
 
 HighlightersOverlay.prototype = {
   get isRuleView() {
     return this.inspector.sidebar.getCurrentTabID() == "ruleview";
@@ -382,37 +380,59 @@ HighlightersOverlay.prototype = {
     } else if (data.type === "shape-hover-off") {
       this.state.shapes.hoverPoint = null;
       this.emit("hover-shape-point", null);
     }
     this.emit("highlighter-event-handled");
   },
 
   /**
-   * Restore the saved highlighter states.
+   * Restores the saved grid highlighter state.
+   */
+  restoreGridState: Task.async(function* () {
+    try {
+      yield this.restoreState("grid", this.state.grid, this.showGridHighlighter);
+    } catch (e) {
+      this._handleRejection(e);
+    }
+  }),
+
+  /**
+   * Restores the saved shape highlighter state.
+   */
+  restoreShapeState: Task.async(function* () {
+    try {
+      yield this.restoreState("shapes", this.state.shapes, this.showShapesHighlighter);
+    } catch (e) {
+      this._handleRejection(e);
+    }
+  }),
+
+  /**
+   * Helper function called by restoreGridState and restoreShapeState.
+   * Restores the saved highlighter state for the given highlighter and their state.
+   *
    * @param {String} name
    *        The name of the highlighter to be restored
    * @param {Object} state
    *        The state of the highlighter to be restored
    * @param {Function} showFunction
    *        The function that shows the highlighter
    * @return {Promise} that resolves when the highlighter state was restored, and the
    *         expected highlighters are displayed.
    */
   restoreState: Task.async(function* (name, state, showFunction) {
     let { selector, options, url } = state;
+
     if (!selector || url !== this.inspector.target.url) {
       // Bail out if no selector was saved, or if we are on a different page.
       this.emit(`${name}-state-restored`, { restored: false });
       return;
     }
 
-    // Wait for the new root to be ready in the inspector.
-    yield this.onInspectorNewRoot;
-
     let walker = this.inspector.walker;
     let rootNode = yield walker.getRootNode();
     let nodeFront = yield walker.querySelector(rootNode, selector);
 
     if (nodeFront) {
       if (options.hoverPoint) {
         options.hoverPoint = null;
       }
@@ -709,39 +729,24 @@ HighlightersOverlay.prototype = {
         }
       } catch (e) {
         console.error(e);
       }
     }
   }),
 
   /**
-   * Restore saved highlighter state after navigate.
-   */
-  onNavigate: Task.async(function* () {
-    try {
-      yield this.restoreState("grid", this.state.grid, this.showGridHighlighter);
-      yield this.restoreState("shapes", this.state.shapes, this.showShapesHighlighter);
-    } catch (e) {
-      this._handleRejection(e);
-    }
-  }),
-
-  /**
    * Clear saved highlighter shown properties on will-navigate.
    */
   onWillNavigate: function () {
     this.geometryEditorHighlighterShown = null;
     this.gridHighlighterShown = null;
     this.hoveredHighlighterShown = null;
     this.selectorHighlighterShown = null;
     this.shapesHighlighterShown = null;
-
-    // The inspector panel should emit the new-root event when it is ready after navigate.
-    this.onInspectorNewRoot = this.inspector.once("new-root");
   },
 
   /**
    * Destroy this overlay instance, removing it from the view and destroying
    * all initialized highlighters.
    */
   destroy: function () {
     for (let type in this.highlighters) {
@@ -751,17 +756,16 @@ HighlightersOverlay.prototype = {
         }
         this.highlighters[type].finalize();
         this.highlighters[type] = null;
       }
     }
 
     // Remove inspector events.
     this.inspector.off("markupmutation", this.onMarkupMutation);
-    this.inspector.target.off("navigate", this.onNavigate);
     this.inspector.target.off("will-navigate", this.onWillNavigate);
 
     this._lastHovered = null;
 
     this.inspector = null;
     this.highlighters = null;
     this.highlighterUtils = null;
     this.supportsHighlighters = null;
diff --git a/devtools/client/preferences/devtools.js b/devtools/client/preferences/devtools.js
--- a/devtools/client/preferences/devtools.js
+++ b/devtools/client/preferences/devtools.js
@@ -76,16 +76,17 @@ pref("devtools.promote.layoutview", 1);
 pref("devtools.promote.layoutview.showPromoteBar", true);
 
 // Grid highlighter preferences
 pref("devtools.gridinspector.gridOutlineMaxColumns", 50);
 pref("devtools.gridinspector.gridOutlineMaxRows", 50);
 pref("devtools.gridinspector.showGridAreas", false);
 pref("devtools.gridinspector.showGridLineNumbers", false);
 pref("devtools.gridinspector.showInfiniteLines", false);
+pref("devtools.gridinspector.showNegativeLineNumbers", false);
 
 // Whether or not the box model panel is opened in the computed view
 pref("devtools.computed.boxmodel.opened", true);
 // Whether or not the box model panel is opened in the layout view
 pref("devtools.layout.boxmodel.opened", true);
 // Whether or not the grid inspector panel is opened in the layout view
 pref("devtools.layout.grid.opened", true);
 
diff --git a/devtools/server/actors/highlighters/css-grid.js b/devtools/server/actors/highlighters/css-grid.js
--- a/devtools/server/actors/highlighters/css-grid.js
+++ b/devtools/server/actors/highlighters/css-grid.js
@@ -29,16 +29,17 @@ const {
 } = require("devtools/shared/layout/dom-matrix-2d");
 const { stringifyGridFragments } = require("devtools/server/actors/utils/css-grid-utils");
 const { LocalizationHelper } = require("devtools/shared/l10n");
 
 const LAYOUT_STRINGS_URI = "devtools/client/locales/layout.properties";
 const LAYOUT_L10N = new LocalizationHelper(LAYOUT_STRINGS_URI);
 
 const CSS_GRID_ENABLED_PREF = "layout.css.grid.enabled";
+const NEGATIVE_LINE_NUMBERS_PREF = "devtools.gridinspector.showNegativeLineNumbers";
 
 const DEFAULT_GRID_COLOR = "#4B0082";
 
 const COLUMNS = "cols";
 const ROWS = "rows";
 
 const GRID_FONT_SIZE = 10;
 const GRID_FONT_FAMILY = "sans-serif";
@@ -347,21 +348,19 @@ class CssGridHighlighter extends AutoRef
   constructor(highlighterEnv) {
     super(highlighterEnv);
 
     this.ID_CLASS_PREFIX = "css-grid-";
 
     this.markup = new CanvasFrameAnonymousContentHelper(this.highlighterEnv,
       this._buildMarkup.bind(this));
 
-    this.onNavigate = this.onNavigate.bind(this);
     this.onPageHide = this.onPageHide.bind(this);
     this.onWillNavigate = this.onWillNavigate.bind(this);
 
-    this.highlighterEnv.on("navigate", this.onNavigate);
     this.highlighterEnv.on("will-navigate", this.onWillNavigate);
 
     let { pageListenerTarget } = highlighterEnv;
     pageListenerTarget.addEventListener("pagehide", this.onPageHide);
 
     // Initialize the <canvas> position to the top left corner of the page
     this._canvasPosition = {
       x: 0,
@@ -585,17 +584,16 @@ class CssGridHighlighter extends AutoRef
       prefix: this.ID_CLASS_PREFIX
     });
 
     return container;
   }
 
   destroy() {
     let { highlighterEnv } = this;
-    highlighterEnv.off("navigate", this.onNavigate);
     highlighterEnv.off("will-navigate", this.onWillNavigate);
 
     let { pageListenerTarget } = highlighterEnv;
     if (pageListenerTarget) {
       pageListenerTarget.removeEventListener("pagehide", this.onPageHide);
     }
 
     this.markup.destroy();
@@ -672,33 +670,32 @@ class CssGridHighlighter extends AutoRef
     let pattern = ctx.createPattern(canvas, "repeat");
 
     gridPatternMap.set(dimension, pattern);
     gCachedGridPattern.set(devicePixelRatio, gridPatternMap);
 
     return pattern;
   }
 
-  /**
-   * Called when the page navigates. Used to clear the cached gap patterns and avoid
-   * using DeadWrapper objects as gap patterns the next time.
-   */
-  onNavigate() {
-    this._clearCache();
-  }
-
   onPageHide({ target }) {
     // If a page hide event is triggered for current window's highlighter, hide the
     // highlighter.
     if (target.defaultView === this.win) {
       this.hide();
     }
   }
 
+  /**
+   * Called when the page will-navigate. Used to hide the grid highlighter and clear
+   * the cached gap patterns and avoid using DeadWrapper obejcts as gap patterns the
+   * next time.
+   */
   onWillNavigate({ isTopLevel }) {
+    this._clearCache();
+
     if (isTopLevel) {
       this.hide();
     }
   }
 
   _show() {
     if (Services.prefs.getBoolPref(CSS_GRID_ENABLED_PREF) && !this.isGrid()) {
       this.hide();
@@ -1140,16 +1137,45 @@ class CssGridHighlighter extends AutoRef
     }
 
     // Line numbers are rendered in a 2nd step to avoid overlapping with existing lines.
     if (this.options.showGridLineNumbers) {
       this.renderLineNumbers(fragment.cols, COLUMNS, "left", "top",
                        this.getFirstRowLinePos(fragment));
       this.renderLineNumbers(fragment.rows, ROWS, "top", "left",
                        this.getFirstColLinePos(fragment));
+
+      if (Services.prefs.getBoolPref(NEGATIVE_LINE_NUMBERS_PREF)) {
+        this.renderNegativeLineNumbers(fragment.cols, COLUMNS, "left", "top",
+                          this.getLastRowLinePos(fragment));
+        this.renderNegativeLineNumbers(fragment.rows, ROWS, "top", "left",
+                          this.getLastColLinePos(fragment));
+      }
+    }
+  }
+
+  /**
+   * Render the negative grid lines given the grid dimension information of the
+   * column or row lines.
+   *
+   * See @param for renderLines.
+   */
+  renderNegativeLineNumbers(gridDimension, dimensionType, mainSide, crossSide,
+            startPos) {
+    let lineStartPos = startPos;
+
+    const { lines } = gridDimension;
+
+    for (let i = 0, line = lines[i]; i < lines.length; line = lines[++i]) {
+      let linePos = line.start;
+
+      const negativeLineNumber = i - lines.length;
+
+      this.renderGridLineNumber(negativeLineNumber, linePos, lineStartPos, line.breadth,
+        dimensionType);
     }
   }
 
   /**
    * Renders the grid area overlay on the css grid highlighter canvas.
    */
   renderGridAreaOverlay() {
     let padding = 1;
@@ -1326,32 +1352,50 @@ class CssGridHighlighter extends AutoRef
    * column or row lines.
    *
    * see @param for renderLines.
    */
   renderLineNumbers(gridDimension, dimensionType, mainSide, crossSide,
               startPos) {
     let lineStartPos = startPos;
 
+    // Keep track of the number of collapsed lines per line position
+    let stackedLines = [];
+
     for (let i = 0; i < gridDimension.lines.length; i++) {
       let line = gridDimension.lines[i];
       let linePos = line.start;
 
       // If you place something using negative numbers, you can trigger some implicit grid
       // creation above and to the left of the explicit grid (assuming a horizontal-tb
       // writing mode).
       // The first explicit grid line gets the number of 1; any implicit grid lines
       // before 1 get negative numbers, but do not get any positivity numbers.
       // Since here we're rendering only the positive line numbers, we have to skip any
       // implicit grid lines before the first tha is explicit.
       // For such lines the API returns always 0 as line's number.
       if (line.number === 0) {
         continue;
       }
 
+      // Check for overlapping lines. We render a second box beneath the last overlapping
+      // line number to indicate there are lines beneath it.
+      const gridLine = gridDimension.tracks[line.number - 1];
+      if (gridLine) {
+        const { breadth }  = gridLine;
+        if (breadth === 0) {
+          stackedLines.push(gridDimension.lines[i].number);
+          if (stackedLines.length > 0) {
+            this.renderGridLineNumber(line.number, linePos, lineStartPos, line.breadth,
+              dimensionType, 1);
+          }
+          continue;
+        }
+      }
+
       this.renderGridLineNumber(line.number, linePos, lineStartPos, line.breadth,
         dimensionType);
     }
   }
 
   /**
    * Render the grid line on the css grid highlighter canvas.
    *
@@ -1420,18 +1464,21 @@ class CssGridHighlighter extends AutoRef
    *         The line position along the x-axis for a column grid line and
    *         y-axis for a row grid line.
    * @param  {Number} startPos
    *         The start position of the cross side of the grid line.
    * @param  {Number} breadth
    *         The grid line breadth value.
    * @param  {String} dimensionType
    *         The grid dimension type which is either the constant COLUMNS or ROWS.
+   * @param  {Number||undefined} stackedLineIndex
+   *         The line index position of the stacked line.
    */
-  renderGridLineNumber(lineNumber, linePos, startPos, breadth, dimensionType) {
+  renderGridLineNumber(lineNumber, linePos, startPos, breadth, dimensionType,
+    stackedLineIndex) {
     let displayPixelRatio = getDisplayPixelRatio(this.win);
     let { devicePixelRatio } = this.win;
     let offset = (displayPixelRatio / 2) % 1;
 
     linePos = Math.round(linePos);
     startPos = Math.round(startPos);
     breadth = Math.round(breadth);
 
@@ -1458,45 +1505,67 @@ class CssGridHighlighter extends AutoRef
 
     let boxWidth = textWidth + 2 * padding;
     let boxHeight = textHeight + 2 * padding;
 
     // Calculate the x & y coordinates for the line number container, so that it is
     // centered on the line, and in the middle of the gap if there is any.
     let x, y;
 
+    let startOffset = (boxHeight + 2) / devicePixelRatio;
+
+    if (Services.prefs.getBoolPref(NEGATIVE_LINE_NUMBERS_PREF)) {
+      // If the line number is negative, offset it from the grid container edge,
+      // (downwards if its a column, rightwards if its a row).
+      if (lineNumber < 0) {
+        startPos += startOffset;
+      } else {
+        startPos -= startOffset;
+      }
+    }
+
     if (dimensionType === COLUMNS) {
       x = linePos + breadth / 2;
       y = startPos;
     } else {
       x = startPos;
       y = linePos + breadth / 2;
     }
 
     [x, y] = apply(this.currentMatrix, [x, y]);
 
     x -= boxWidth / 2;
     y -= boxHeight / 2;
 
+    if (stackedLineIndex) {
+      // Offset the stacked line number by half of the box's width/height
+      const xOffset = boxWidth / 4;
+      const yOffset = boxHeight / 4;
+
+      x += xOffset;
+      y += yOffset;
+    }
+
     if (!this.hasNodeTransformations) {
       x = Math.max(x, padding);
       y = Math.max(y, padding);
     }
 
     // Draw a rounded rectangle with a border width of 2 pixels, a border color matching
     // the grid color and a white background (the line number will be written in black).
     this.ctx.lineWidth = 2 * displayPixelRatio;
     this.ctx.strokeStyle = this.color;
     this.ctx.fillStyle = "white";
     let radius = 2 * displayPixelRatio;
     drawRoundedRect(this.ctx, x, y, boxWidth, boxHeight, radius);
 
     // Write the line number inside of the rectangle.
     this.ctx.fillStyle = "black";
-    this.ctx.fillText(lineNumber, x + padding, y + textHeight + padding);
+    const numberText = stackedLineIndex ? "" : lineNumber;
+    this.ctx.fillText(numberText, x + padding, y + textHeight + padding);
 
     this.ctx.restore();
   }
 
   /**
    * Render the grid gap area on the css grid highlighter canvas.
    *
    * @param  {Number} linePos
diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -1766,38 +1766,36 @@ nsDocShell::FirePageHideNotificationInte
 
     // Now make sure our editor, if any, is detached before we go
     // any farther.
     DetachEditorFromWindow();
   }
 }
 
 nsresult
-nsDocShell::DispatchToTabGroup(const char* aName,
-                               TaskCategory aCategory,
+nsDocShell::DispatchToTabGroup(TaskCategory aCategory,
                                already_AddRefed<nsIRunnable>&& aRunnable)
 {
   // Hold the ref so we won't forget to release it.
   nsCOMPtr<nsIRunnable> runnable(aRunnable);
   nsCOMPtr<nsPIDOMWindowOuter> win = GetWindow();
   if (!win) {
     // Window should only be unavailable after destroyed.
     MOZ_ASSERT(mIsBeingDestroyed);
     return NS_ERROR_FAILURE;
   }
 
   RefPtr<mozilla::dom::TabGroup> tabGroup = win->TabGroup();
-  return tabGroup->Dispatch(aName, aCategory, runnable.forget());
+  return tabGroup->Dispatch(aCategory, runnable.forget());
 }
 
 NS_IMETHODIMP
 nsDocShell::DispatchLocationChangeEvent()
 {
   return DispatchToTabGroup(
-    "nsDocShell::FireDummyOnLocationChange",
     TaskCategory::Other,
     NewRunnableMethod("nsDocShell::FireDummyOnLocationChange",
                       this,
                       &nsDocShell::FireDummyOnLocationChange));
 }
 
 bool
 nsDocShell::MaybeInitTiming()
@@ -6788,28 +6786,22 @@ nsDocShell::RefreshURI(nsIURI* aURI, int
   nsresult rv = aURI->Equals(mCurrentURI, &sameURI);
   if (NS_FAILED(rv)) {
     sameURI = false;
   }
   if (!RefreshAttempted(this, aURI, aDelay, sameURI)) {
     return NS_OK;
   }
 
-  nsRefreshTimer* refreshTimer = new nsRefreshTimer();
+  nsCOMPtr<nsITimerCallback> refreshTimer =
+    new nsRefreshTimer(this, aURI, aDelay, aRepeat, aMetaRefresh);
+
   uint32_t busyFlags = 0;
   GetBusyFlags(&busyFlags);
 
-  nsCOMPtr<nsISupports> dataRef = refreshTimer;  // Get the ref count to 1
-
-  refreshTimer->mDocShell = this;
-  refreshTimer->mURI = aURI;
-  refreshTimer->mDelay = aDelay;
-  refreshTimer->mRepeat = aRepeat;
-  refreshTimer->mMetaRefresh = aMetaRefresh;
-
   if (!mRefreshURIList) {
     mRefreshURIList = nsArray::Create();
   }
 
   if (busyFlags & BUSY_FLAGS_BUSY || (!mIsActive && mDisableMetaRefreshWhenInactive)) {
     // We don't  want to create the timer right now. Instead queue up the request
     // and trigger the timer in EndPageLoad() or whenever we become active.
     mRefreshURIList->AppendElement(refreshTimer, /*weak =*/ false);
@@ -8587,18 +8579,17 @@ nsDocShell::RestorePresentation(nsISHEnt
   // implementations.
 
   // Revoke any pending restore (just in case)
   NS_ASSERTION(!mRestorePresentationEvent.IsPending(),
                "should only have one RestorePresentationEvent");
   mRestorePresentationEvent.Revoke();
 
   RefPtr<RestorePresentationEvent> evt = new RestorePresentationEvent(this);
-  nsresult rv = DispatchToTabGroup("nsDocShell::RestorePresentationEvent",
-                                   TaskCategory::Other,
+  nsresult rv = DispatchToTabGroup(TaskCategory::Other,
                                    RefPtr<RestorePresentationEvent>(evt).forget());
   if (NS_SUCCEEDED(rv)) {
     mRestorePresentationEvent = evt.get();
     // The rest of the restore processing will happen on our event
     // callback.
     *aRestoring = true;
   }
 
@@ -10259,18 +10250,17 @@ nsDocShell::InternalLoad(nsIURI* aURI,
       // Do this asynchronously
       nsCOMPtr<nsIRunnable> ev =
         new InternalLoadEvent(this, aURI, aOriginalURI, aResultPrincipalURI,
                               aLoadReplace, aReferrer, aReferrerPolicy,
                               aTriggeringPrincipal, principalToInherit,
                               aFlags, aTypeHint, aPostData, aHeadersData,
                               aLoadType, aSHEntry, aFirstParty, aSrcdoc,
                               aSourceDocShell, aBaseURI, false);
-      return DispatchToTabGroup("nsDocShell::InternalLoadEvent",
-                                TaskCategory::Other, ev.forget());
+      return DispatchToTabGroup(TaskCategory::Other, ev.forget());
     }
 
     // Just ignore this load attempt
     return NS_OK;
   }
 
   // If a source docshell has been passed, check to see if we are sandboxed
   // from it as the result of an iframe or CSP sandbox.
@@ -13629,47 +13619,57 @@ NS_IMETHODIMP
 nsDocShell::SetLayoutHistoryState(nsILayoutHistoryState* aLayoutHistoryState)
 {
   if (mOSHE) {
     mOSHE->SetLayoutHistoryState(aLayoutHistoryState);
   }
   return NS_OK;
 }
 
-nsRefreshTimer::nsRefreshTimer()
-  : mDelay(0), mRepeat(false), mMetaRefresh(false)
+nsRefreshTimer::nsRefreshTimer(nsDocShell* aDocShell, nsIURI* aURI,
+                               int32_t aDelay, bool aRepeat, bool aMetaRefresh)
+  : mDocShell(aDocShell), mURI(aURI), mDelay(aDelay), mRepeat(aRepeat),
+    mMetaRefresh(aMetaRefresh)
 {
 }
 
 nsRefreshTimer::~nsRefreshTimer()
 {
 }
 
 NS_IMPL_ADDREF(nsRefreshTimer)
 NS_IMPL_RELEASE(nsRefreshTimer)
 
 NS_INTERFACE_MAP_BEGIN(nsRefreshTimer)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsITimerCallback)
   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
+  NS_INTERFACE_MAP_ENTRY(nsINamed)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMETHODIMP
 nsRefreshTimer::Notify(nsITimer* aTimer)
 {
   NS_ASSERTION(mDocShell, "DocShell is somehow null");
 
   if (mDocShell && aTimer) {
     // Get the delay count to determine load type
     uint32_t delay = 0;
     aTimer->GetDelay(&delay);
     mDocShell->ForceRefreshURIFromTimer(mURI, delay, mMetaRefresh, aTimer);
   }
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsRefreshTimer::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsRefreshTimer");
+  return NS_OK;
+}
+
 nsDocShell::InterfaceRequestorProxy::InterfaceRequestorProxy(
     nsIInterfaceRequestor* aRequestor)
 {
   if (aRequestor) {
     mWeakPtr = do_GetWeakReference(aRequestor);
   }
 }
 
@@ -14161,18 +14161,17 @@ nsDocShell::OnLinkClick(nsIContent* aCon
   if (NS_FAILED(rv)) {
     target = aTargetSpec;
   }
 
   nsCOMPtr<nsIRunnable> ev =
     new OnLinkClickEvent(this, aContent, aURI, target.get(), aFileName,
                          aPostDataStream, aHeadersDataStream, noOpenerImplied,
                          aIsTrusted, aTriggeringPrincipal);
-  return DispatchToTabGroup("nsDocShell::OnLinkClickEvent",
-                            TaskCategory::UI, ev.forget());
+  return DispatchToTabGroup(TaskCategory::UI, ev.forget());
 }
 
 NS_IMETHODIMP
 nsDocShell::OnLinkClickSync(nsIContent* aContent,
                             nsIURI* aURI,
                             const char16_t* aTargetSpec,
                             const nsAString& aFileName,
                             nsIInputStream* aPostDataStream,
diff --git a/docshell/base/nsDocShell.h b/docshell/base/nsDocShell.h
--- a/docshell/base/nsDocShell.h
+++ b/docshell/base/nsDocShell.h
@@ -39,16 +39,17 @@
 #include "timeline/TimelineMarker.h"
 
 // Threshold value in ms for META refresh based redirects
 #define REFRESH_REDIRECT_TIMER 15000
 
 // Interfaces Needed
 #include "nsIDocCharset.h"
 #include "nsIInterfaceRequestor.h"
+#include "nsINamed.h"
 #include "nsIRefreshURI.h"
 #include "nsIWebNavigation.h"
 #include "nsIWebPageDescriptor.h"
 #include "nsIWebProgressListener.h"
 #include "nsIDocShellLoadInfo.h"
 #include "nsIAuthPromptProvider.h"
 #include "nsILoadContext.h"
 #include "nsIWebShellServices.h"
@@ -101,22 +102,25 @@ class FramingChecker;
 /* internally used ViewMode types */
 enum ViewMode
 {
   viewNormal = 0x0,
   viewSource = 0x1
 };
 
 class nsRefreshTimer : public nsITimerCallback
+                     , public nsINamed
 {
 public:
-  nsRefreshTimer();
+  nsRefreshTimer(nsDocShell* aDocShell, nsIURI* aURI, int32_t aDelay,
+                 bool aRepeat, bool aMetaRefresh);
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   int32_t GetDelay() { return mDelay ;}
 
   RefPtr<nsDocShell> mDocShell;
   nsCOMPtr<nsIURI> mURI;
   int32_t mDelay;
   bool mRepeat;
   bool mMetaRefresh;
@@ -1085,18 +1089,17 @@ private:
   // Internal implementation of nsIDocShell::FirePageHideNotification.
   // If aSkipCheckingDynEntries is true, it will not try to remove dynamic
   // subframe entries. This is to avoid redundant RemoveDynEntries calls in all
   // children docshells.
   void FirePageHideNotificationInternal(bool aIsUnload,
                                         bool aSkipCheckingDynEntries);
 
   // Dispatch a runnable to the TabGroup associated to this docshell.
-  nsresult DispatchToTabGroup(const char* aName,
-                              mozilla::TaskCategory aCategory,
+  nsresult DispatchToTabGroup(mozilla::TaskCategory aCategory,
                               already_AddRefed<nsIRunnable>&& aRunnable);
 
 #ifdef DEBUG
   // We're counting the number of |nsDocShells| to help find leaks
   static unsigned long gNumberOfDocShells;
 #endif /* DEBUG */
 
 public:
diff --git a/docshell/shistory/nsSHEntryShared.cpp b/docshell/shistory/nsSHEntryShared.cpp
--- a/docshell/shistory/nsSHEntryShared.cpp
+++ b/docshell/shistory/nsSHEntryShared.cpp
@@ -210,18 +210,17 @@ nsSHEntryShared::RemoveFromBFCacheAsync(
 
   // Release the reference to the contentviewer asynchronously so that the
   // document doesn't get nuked mid-mutation.
 
   if (!mDocument) {
     return NS_ERROR_UNEXPECTED;
   }
   nsCOMPtr<nsIRunnable> evt = new DestroyViewerEvent(mContentViewer, mDocument);
-  nsresult rv = mDocument->Dispatch("nsSHEntryShared::DestroyViewerEvent",
-                                    mozilla::TaskCategory::Other, evt.forget());
+  nsresult rv = mDocument->Dispatch(mozilla::TaskCategory::Other, evt.forget());
   if (NS_FAILED(rv)) {
     NS_WARNING("failed to dispatch DestroyViewerEvent");
   } else {
     // Drop presentation. Only do this if we succeeded in posting the event
     // since otherwise the document could be torn down mid-mutation, causing
     // crashes.
     DropPresentationState();
   }
diff --git a/dom/base/DOMIntersectionObserver.cpp b/dom/base/DOMIntersectionObserver.cpp
--- a/dom/base/DOMIntersectionObserver.cpp
+++ b/dom/base/DOMIntersectionObserver.cpp
@@ -428,25 +428,25 @@ DOMIntersectionObserver::Update(nsIDocum
 
     double intersectionRatio;
     if (targetArea > 0.0) {
       intersectionRatio = intersectionArea / targetArea;
     } else {
       intersectionRatio = intersectionRect.isSome() ? 1.0 : 0.0;
     }
 
-    size_t threshold = -1;
+    int32_t threshold = -1;
     if (intersectionRatio > 0.0) {
       if (intersectionRatio >= 1.0) {
         intersectionRatio = 1.0;
-        threshold = mThresholds.Length();
+        threshold = (int32_t)mThresholds.Length();
       } else {
         for (size_t k = 0; k < mThresholds.Length(); ++k) {
           if (mThresholds[k] <= intersectionRatio) {
-            threshold = k + 1;
+            threshold = (int32_t)k + 1;
           } else {
             break;
           }
         }
       }
     } else if (intersectionRect.isSome()) {
       threshold = 0;
     }
diff --git a/dom/base/DispatcherTrait.cpp b/dom/base/DispatcherTrait.cpp
--- a/dom/base/DispatcherTrait.cpp
+++ b/dom/base/DispatcherTrait.cpp
@@ -9,21 +9,20 @@
 #include "mozilla/AbstractThread.h"
 #include "mozilla/SchedulerGroup.h"
 #include "nsINamed.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 nsresult
-DispatcherTrait::Dispatch(const char* aName,
-                          TaskCategory aCategory,
+DispatcherTrait::Dispatch(TaskCategory aCategory,
                           already_AddRefed<nsIRunnable>&& aRunnable)
 {
-  return SchedulerGroup::UnlabeledDispatch(aName, aCategory, Move(aRunnable));
+  return SchedulerGroup::UnlabeledDispatch(aCategory, Move(aRunnable));
 }
 
 nsISerialEventTarget*
 DispatcherTrait::EventTargetFor(TaskCategory aCategory) const
 {
   return GetMainThreadSerialEventTarget();
 }
 
diff --git a/dom/base/DispatcherTrait.h b/dom/base/DispatcherTrait.h
--- a/dom/base/DispatcherTrait.h
+++ b/dom/base/DispatcherTrait.h
@@ -21,18 +21,17 @@ class TabGroup;
 // This trait should be attached to classes like nsIGlobalObject and nsIDocument
 // that have a DocGroup or TabGroup attached to them. The methods here should
 // delegate to the DocGroup or TabGroup. We can't use the Dispatcher class
 // directly because it inherits from nsISupports.
 class DispatcherTrait {
 public:
   // This method may or may not be safe off of the main thread. For nsIDocument
   // it is safe. For nsIGlobalWindow it is not safe.
-  virtual nsresult Dispatch(const char* aName,
-                            TaskCategory aCategory,
+  virtual nsresult Dispatch(TaskCategory aCategory,
                             already_AddRefed<nsIRunnable>&& aRunnable);
 
   // This method may or may not be safe off of the main thread. For nsIDocument
   // it is safe. For nsIGlobalWindow it is not safe. The nsISerialEventTarget can
   // always be used off the main thread.
   virtual nsISerialEventTarget* EventTargetFor(TaskCategory aCategory) const;
 
   // Must be called on the main thread. The AbstractThread can always be used
diff --git a/dom/base/DocGroup.cpp b/dom/base/DocGroup.cpp
--- a/dom/base/DocGroup.cpp
+++ b/dom/base/DocGroup.cpp
@@ -51,21 +51,20 @@ DocGroup::~DocGroup()
     nsIEventTarget* target = EventTargetFor(TaskCategory::Other);
     NS_ProxyRelease("DocGroup::mReactionsStack", target, mReactionsStack.forget());
   }
 
   mTabGroup->mDocGroups.RemoveEntry(mKey);
 }
 
 nsresult
-DocGroup::Dispatch(const char* aName,
-                   TaskCategory aCategory,
+DocGroup::Dispatch(TaskCategory aCategory,
                    already_AddRefed<nsIRunnable>&& aRunnable)
 {
-  return mTabGroup->Dispatch(aName, aCategory, Move(aRunnable));
+  return mTabGroup->Dispatch(aCategory, Move(aRunnable));
 }
 
 nsISerialEventTarget*
 DocGroup::EventTargetFor(TaskCategory aCategory) const
 {
   return mTabGroup->EventTargetFor(aCategory);
 }
 
diff --git a/dom/base/DocGroup.h b/dom/base/DocGroup.h
--- a/dom/base/DocGroup.h
+++ b/dom/base/DocGroup.h
@@ -75,18 +75,17 @@ public:
     return mDocuments.begin();
   }
   Iterator end()
   {
     MOZ_ASSERT(NS_IsMainThread());
     return mDocuments.end();
   }
 
-  nsresult Dispatch(const char* aName,
-                    TaskCategory aCategory,
+  nsresult Dispatch(TaskCategory aCategory,
                     already_AddRefed<nsIRunnable>&& aRunnable);
 
   nsISerialEventTarget* EventTargetFor(TaskCategory aCategory) const;
 
   AbstractThread*
   AbstractMainThreadFor(TaskCategory aCategory);
 
   // Ensure that it's valid to access the DocGroup at this time.
diff --git a/dom/base/Selection.cpp b/dom/base/Selection.cpp
--- a/dom/base/Selection.cpp
+++ b/dom/base/Selection.cpp
@@ -47,16 +47,17 @@
 
 #include "nsPresContext.h"
 #include "nsIPresShell.h"
 #include "nsCaret.h"
 
 #include "nsITimer.h"
 #include "nsIDOMDocument.h"
 #include "nsIDocument.h"
+#include "nsINamed.h"
 
 #include "nsISelectionController.h"//for the enums
 #include "nsAutoCopyListener.h"
 #include "SelectionChangeListener.h"
 #include "nsCopySupport.h"
 #include "nsIClipboard.h"
 #include "nsIFrameInlines.h"
 #include "nsRefreshDriver.h"
@@ -191,16 +192,17 @@ struct CachedOffsetForFrame {
 
   nsPoint      mCachedFrameOffset;      // cached frame offset
   nsIFrame*    mLastCaretFrame;         // store the frame the caret was last drawn in.
   int32_t      mLastContentOffset;      // store last content offset
   bool mCanCacheFrameOffset;    // cached frame offset is valid?
 };
 
 class nsAutoScrollTimer final : public nsITimerCallback
+                              , public nsINamed
 {
 public:
 
   NS_DECL_ISUPPORTS
 
   nsAutoScrollTimer()
   : mFrameSelection(0), mSelection(0), mPresContext(0), mPoint(0,0), mDelay(30)
   {
@@ -275,16 +277,22 @@ public:
       }
 
       NS_ASSERTION(frame->PresContext() == mPresContext, "document mismatch?");
       mSelection->DoAutoScroll(frame, pt);
     }
     return NS_OK;
   }
 
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("nsAutoScrollTimer");
+    return NS_OK;
+  }
+
 protected:
   virtual ~nsAutoScrollTimer()
   {
     if (mTimer) {
       mTimer->Cancel();
     }
   }
 
@@ -294,17 +302,17 @@ private:
   nsPresContext *mPresContext;
   // relative to mPresContext's root frame
   nsPoint mPoint;
   nsCOMPtr<nsITimer> mTimer;
   nsCOMPtr<nsIContent> mContent;
   uint32_t mDelay;
 };
 
-NS_IMPL_ISUPPORTS(nsAutoScrollTimer, nsITimerCallback)
+NS_IMPL_ISUPPORTS(nsAutoScrollTimer, nsITimerCallback, nsINamed)
 
 nsresult NS_NewDomSelection(nsISelection **aDomSelection)
 {
   Selection* rlist = new Selection;
   *aDomSelection = (nsISelection *)rlist;
   NS_ADDREF(rlist);
   return NS_OK;
 }
diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -239,16 +239,10 @@ TimeoutExecutor::Notify(nsITimer* aTimer
 
 NS_IMETHODIMP
 TimeoutExecutor::GetName(nsACString& aNameOut)
 {
   aNameOut.AssignLiteral("TimeoutExecutor Runnable");
   return NS_OK;
 }
 
-NS_IMETHODIMP
-TimeoutExecutor::SetName(const char* aName)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -5,16 +5,18 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "TimeoutManager.h"
 #include "nsGlobalWindow.h"
 #include "mozilla/Logging.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/ThrottledEventQueue.h"
 #include "mozilla/TimeStamp.h"
+#include "nsIDocShell.h"
+#include "nsINamed.h"
 #include "nsITimeoutHandler.h"
 #include "mozilla/dom/TabGroup.h"
 #include "OrderedTimeoutIterator.h"
 #include "TimeoutExecutor.h"
 #include "TimeoutBudgetManager.h"
 #include "mozilla/net/WebSocketEventService.h"
 #include "mozilla/MediaManager.h"
 
@@ -102,72 +104,29 @@ TimeoutManager::IsBackground() const
 }
 
 bool
 TimeoutManager::IsActive() const
 {
   // A window is considered active if:
   // * It is a chrome window
   // * It is playing audio
-  // * If it is using user media
-  // * If it is using WebRTC
-  // * If it has open WebSockets
-  // * If it has active IndexedDB databases
   //
   // Note that a window can be considered active if it is either in the
   // foreground or in the background.
 
   if (mWindow.IsChromeWindow()) {
     return true;
   }
 
   // Check if we're playing audio
   if (mWindow.AsInner()->IsPlayingAudio()) {
     return true;
   }
 
-  // Check if there are any active IndexedDB databases
-  if (mWindow.AsInner()->HasActiveIndexedDBDatabases()) {
-    return true;
-  }
-
-  // Check if we have active GetUserMedia
-  if (MediaManager::Exists() &&
-      MediaManager::Get()->IsWindowStillActive(mWindow.WindowID())) {
-    return true;
-  }
-
-  bool active = false;
-#if 0
-  // Check if we have active PeerConnections This doesn't actually
-  // work, since we sometimes call IsActive from Resume, which in turn
-  // is sometimes called from nsGlobalWindow::LeaveModalState. The
-  // problem here is that LeaveModalState can be called with pending
-  // exeptions on the js context, and the following call to
-  // HasActivePeerConnection is a JS call, which will assert on that
-  // exception. Also, calling JS is expensive so we should try to fix
-  // this in some other way.
-  nsCOMPtr<IPeerConnectionManager> pcManager =
-    do_GetService(IPEERCONNECTION_MANAGER_CONTRACTID);
-
-  if (pcManager && NS_SUCCEEDED(pcManager->HasActivePeerConnection(
-                     mWindow.WindowID(), &active)) &&
-      active) {
-    return true;
-  }
-#endif // MOZ_WEBRTC
-
-  // Check if we have web sockets
-  RefPtr<WebSocketEventService> eventService = WebSocketEventService::Get();
-  if (eventService &&
-      NS_SUCCEEDED(eventService->HasListenerFor(mWindow.WindowID(), &active)) &&
-      active) {
-    return true;
-  }
-
   return false;
 }
 
 
 uint32_t
 TimeoutManager::CreateFiringId()
 {
   uint32_t id = mNextFiringId;
@@ -241,17 +200,17 @@ TimeoutManager::MinSchedulingDelay() con
   // mExecutionBudget is -15ms
   // factor is 0.01, which is 1 ms/100ms
   // delay is 1000ms
   // then we will compute the minimum delay:
   // max(1000, - (- 15) * 1/0.01) = max(1000, 1500) = 1500
   TimeDuration unthrottled =
     isBackground ? TimeDuration::FromMilliseconds(gMinBackgroundTimeoutValue)
                  : TimeDuration();
-  if (mBudgetThrottleTimeouts && mExecutionBudget < TimeDuration()) {
+  if (BudgetThrottlingEnabled() && mExecutionBudget < TimeDuration()) {
     // Only throttle if execution budget is less than 0
     double factor = 1.0 / GetRegenerationFactor(mWindow.IsBackgroundInternal());
     return TimeDuration::Min(
       TimeDuration::FromMilliseconds(gBudgetThrottlingMaxDelay),
       TimeDuration::Max(unthrottled, -mExecutionBudget.MultDouble(factor)));
   }
   //
   return unthrottled;
@@ -368,17 +327,17 @@ TimeoutManager::UpdateBudget(const TimeS
 
   // The budget is adjusted by increasing it with the time since the
   // last budget update factored with the regeneration rate. If a
   // runnable has executed, subtract that duration from the
   // budget. The budget updated without consideration of wether the
   // window is active or not. If throttling is enabled and the window
   // is active and then becomes inactive, an overdrawn budget will
   // still be counted against the minimum delay.
-  if (mBudgetThrottleTimeouts) {
+  if (BudgetThrottlingEnabled()) {
     bool isBackground = mWindow.IsBackgroundInternal();
     double factor = GetRegenerationFactor(isBackground);
     TimeDuration regenerated = (aNow - mLastBudgetUpdate).MultDouble(factor);
     // Clamp the budget to the maximum allowed budget.
     mExecutionBudget = TimeDuration::Min(
       GetMaxBudget(isBackground), mExecutionBudget - aDuration + regenerated);
   }
   mLastBudgetUpdate = aNow;
@@ -1204,48 +1163,115 @@ TimeoutManager::IsTimeoutTracking(uint32
   return mTrackingTimeouts.ForEachAbortable([&](Timeout* aTimeout) {
       return aTimeout->mTimeoutId == aTimeoutId;
     });
 }
 
 namespace {
 
 class ThrottleTimeoutsCallback final : public nsITimerCallback
+                                     , public nsINamed
 {
 public:
   explicit ThrottleTimeoutsCallback(nsGlobalWindow* aWindow)
     : mWindow(aWindow)
   {
     MOZ_DIAGNOSTIC_ASSERT(aWindow->IsInnerWindow());
   }
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
 
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("ThrottleTimeoutsCallback");
+    return NS_OK;
+  }
+
 private:
   ~ThrottleTimeoutsCallback() {}
 
 private:
   // The strong reference here keeps the Window and hence the TimeoutManager
   // object itself alive.
   RefPtr<nsGlobalWindow> mWindow;
 };
 
-NS_IMPL_ISUPPORTS(ThrottleTimeoutsCallback, nsITimerCallback)
+NS_IMPL_ISUPPORTS(ThrottleTimeoutsCallback, nsITimerCallback, nsINamed)
 
 NS_IMETHODIMP
 ThrottleTimeoutsCallback::Notify(nsITimer* aTimer)
 {
   mWindow->AsInner()->TimeoutManager().StartThrottlingTimeouts();
   mWindow = nullptr;
   return NS_OK;
 }
 
 }
 
+bool
+TimeoutManager::BudgetThrottlingEnabled() const
+{
+  // A window can be throttled using budget if
+  // * It isn't active
+  // * If it isn't using user media
+  // * If it isn't using WebRTC
+  // * If it hasn't got open WebSockets
+  // * If it hasn't got active IndexedDB databases
+  //
+  // Note that we allow both foreground and background to be
+  // considered for budget throttling. What determines if they are if
+  // budget throttling is enabled is the regeneration factor.
+
+  if (!mBudgetThrottleTimeouts || IsActive()) {
+    return false;
+  }
+
+  // Check if there are any active IndexedDB databases
+  if (mWindow.AsInner()->HasActiveIndexedDBDatabases()) {
+    return false;
+  }
+
+  // Check if we have active GetUserMedia
+  if (MediaManager::Exists() &&
+      MediaManager::Get()->IsWindowStillActive(mWindow.WindowID())) {
+    return false;
+  }
+
+  bool active = false;
+#if 0
+  // Check if we have active PeerConnections This doesn't actually
+  // work, since we sometimes call IsActive from Resume, which in turn
+  // is sometimes called from nsGlobalWindow::LeaveModalState. The
+  // problem here is that LeaveModalState can be called with pending
+  // exeptions on the js context, and the following call to
+  // HasActivePeerConnection is a JS call, which will assert on that
+  // exception. Also, calling JS is expensive so we should try to fix
+  // this in some other way.
+  nsCOMPtr<IPeerConnectionManager> pcManager =
+    do_GetService(IPEERCONNECTION_MANAGER_CONTRACTID);
+
+  if (pcManager && NS_SUCCEEDED(pcManager->HasActivePeerConnection(
+                     mWindow.WindowID(), &active)) &&
+      active) {
+    return false;
+  }
+#endif // MOZ_WEBRTC
+
+  // Check if we have web sockets
+  RefPtr<WebSocketEventService> eventService = WebSocketEventService::Get();
+  if (eventService &&
+      NS_SUCCEEDED(eventService->HasListenerFor(mWindow.WindowID(), &active)) &&
+      active) {
+    return false;
+  }
+
+  return true;
+}
+
 void
 TimeoutManager::StartThrottlingTimeouts()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(mThrottleTimeoutsTimer);
 
   MOZ_LOG(gLog, LogLevel::Debug,
           ("TimeoutManager %p started to throttle tracking timeouts\n", this));
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -143,16 +143,18 @@ private:
                          const TimeStamp& aNow = TimeStamp::Now());
 
   void RecordExecution(Timeout* aRunningTimeout,
                        Timeout* aTimeout);
 
   void UpdateBudget(const TimeStamp& aNow,
                     const TimeDuration& aDuration = TimeDuration());
 
+  bool BudgetThrottlingEnabled() const;
+
 private:
   struct Timeouts {
     explicit Timeouts(const TimeoutManager& aManager)
       : mManager(aManager)
     {
     }
 
     // Insert aTimeout into the list, before all timeouts that would
diff --git a/dom/base/nsContentList.cpp b/dom/base/nsContentList.cpp
--- a/dom/base/nsContentList.cpp
+++ b/dom/base/nsContentList.cpp
@@ -244,17 +244,17 @@ NS_GetContentList(nsINode* aRootNode,
   }
 
   sRecentlyUsedContentLists[recentlyUsedCacheIndex] = list;
   return list.forget();
 }
 
 #ifdef DEBUG
 const nsCacheableFuncStringContentList::ContentListType
-  nsCacheableFuncStringNodeList::sType = nsCacheableFuncStringContentList::eNodeList;
+  nsCachableElementsByNameNodeList::sType = nsCacheableFuncStringContentList::eNodeList;
 const nsCacheableFuncStringContentList::ContentListType
   nsCacheableFuncStringHTMLCollection::sType = nsCacheableFuncStringContentList::eHTMLCollection;
 #endif
 
 // Hashtable for storing nsCacheableFuncStringContentList
 static PLDHashTable* gFuncStringContentListHashTable;
 
 struct FuncStringContentListHashEntry : public PLDHashEntryHdr
@@ -333,43 +333,31 @@ GetFuncStringContentList(nsINode* aRootN
     }
   }
 
   // Don't cache these lists globally
 
   return list.forget();
 }
 
+// Explicit instantiations to avoid link errors
+template
 already_AddRefed<nsContentList>
-NS_GetFuncStringNodeList(nsINode* aRootNode,
-                         nsContentListMatchFunc aFunc,
-                         nsContentListDestroyFunc aDestroyFunc,
-                         nsFuncStringContentListDataAllocator aDataAllocator,
-                         const nsAString& aString)
-{
-  return GetFuncStringContentList<nsCacheableFuncStringNodeList>(aRootNode,
-                                                                 aFunc,
-                                                                 aDestroyFunc,
-                                                                 aDataAllocator,
-                                                                 aString);
-}
-
+GetFuncStringContentList<nsCachableElementsByNameNodeList>(nsINode* aRootNode,
+                                                           nsContentListMatchFunc aFunc,
+                                                           nsContentListDestroyFunc aDestroyFunc,
+                                                           nsFuncStringContentListDataAllocator aDataAllocator,
+                                                           const nsAString& aString);
+template
 already_AddRefed<nsContentList>
-NS_GetFuncStringHTMLCollection(nsINode* aRootNode,
-                               nsContentListMatchFunc aFunc,
-                               nsContentListDestroyFunc aDestroyFunc,
-                               nsFuncStringContentListDataAllocator aDataAllocator,
-                               const nsAString& aString)
-{
-  return GetFuncStringContentList<nsCacheableFuncStringHTMLCollection>(aRootNode,
-                                                                       aFunc,
-                                                                       aDestroyFunc,
-                                                                       aDataAllocator,
-                                                                       aString);
-}
+GetFuncStringContentList<nsCacheableFuncStringHTMLCollection>(nsINode* aRootNode,
+                                                              nsContentListMatchFunc aFunc,
+                                                              nsContentListDestroyFunc aDestroyFunc,
+                                                              nsFuncStringContentListDataAllocator aDataAllocator,
+                                                              const nsAString& aString);
 
 //-----------------------------------------------------
 // nsContentList implementation
 
 nsContentList::nsContentList(nsINode* aRootNode,
                              int32_t aMatchNameSpaceId,
                              nsIAtom* aHTMLMatchAtom,
                              nsIAtom* aXMLMatchAtom,
@@ -1071,24 +1059,43 @@ nsContentList::AssertInSync()
     }
   }
 
   NS_ASSERTION(cnt == mElements.Length(), "Too few elements");
 }
 #endif
 
 //-----------------------------------------------------
-// nsCacheableFuncStringNodeList
+// nsCachableElementsByNameNodeList
 
 JSObject*
-nsCacheableFuncStringNodeList::WrapObject(JSContext *cx, JS::Handle<JSObject*> aGivenProto)
+nsCachableElementsByNameNodeList::WrapObject(JSContext *cx, JS::Handle<JSObject*> aGivenProto)
 {
   return NodeListBinding::Wrap(cx, this, aGivenProto);
 }
 
+void
+nsCachableElementsByNameNodeList::AttributeChanged(nsIDocument* aDocument,
+                                                   Element* aElement,
+                                                   int32_t aNameSpaceID,
+                                                   nsIAtom* aAttribute,
+                                                   int32_t aModType,
+                                                   const nsAttrValue* aOldValue)
+{
+  // No need to rebuild the list if the changed attribute is not the name
+  // attribute.
+  if (aAttribute != nsGkAtoms::name) {
+    return;
+  }
+
+  nsCacheableFuncStringContentList::AttributeChanged(aDocument, aElement,
+                                                     aNameSpaceID, aAttribute,
+                                                     aModType, aOldValue);
+}
+
 //-----------------------------------------------------
 // nsCacheableFuncStringHTMLCollection
 
 JSObject*
 nsCacheableFuncStringHTMLCollection::WrapObject(JSContext *cx, JS::Handle<JSObject*> aGivenProto)
 {
   return HTMLCollectionBinding::Wrap(cx, this, aGivenProto);
 }
diff --git a/dom/base/nsContentList.h b/dom/base/nsContentList.h
--- a/dom/base/nsContentList.h
+++ b/dom/base/nsContentList.h
@@ -541,33 +541,35 @@ protected:
   virtual void RemoveFromCaches() override {
     RemoveFromFuncStringHashtable();
   }
   void RemoveFromFuncStringHashtable();
 
   nsString mString;
 };
 
-class nsCacheableFuncStringNodeList
+class nsCachableElementsByNameNodeList
   : public nsCacheableFuncStringContentList
 {
 public:
-  nsCacheableFuncStringNodeList(nsINode* aRootNode,
-                                nsContentListMatchFunc aFunc,
-                                nsContentListDestroyFunc aDestroyFunc,
-                                nsFuncStringContentListDataAllocator aDataAllocator,
-                                const nsAString& aString)
+  nsCachableElementsByNameNodeList(nsINode* aRootNode,
+                                   nsContentListMatchFunc aFunc,
+                                   nsContentListDestroyFunc aDestroyFunc,
+                                   nsFuncStringContentListDataAllocator aDataAllocator,
+                                   const nsAString& aString)
     : nsCacheableFuncStringContentList(aRootNode, aFunc, aDestroyFunc,
                                        aDataAllocator, aString)
   {
 #ifdef DEBUG
     mType = eNodeList;
 #endif
   }
 
+  NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
+
   virtual JSObject* WrapObject(JSContext *cx, JS::Handle<JSObject*> aGivenProto) override;
 
 #ifdef DEBUG
   static const ContentListType sType;
 #endif
 };
 
 class nsCacheableFuncStringHTMLCollection
diff --git a/dom/base/nsContentListDeclarations.h b/dom/base/nsContentListDeclarations.h
--- a/dom/base/nsContentListDeclarations.h
+++ b/dom/base/nsContentListDeclarations.h
@@ -52,22 +52,17 @@ typedef void* (*nsFuncStringContentListD
 // elements in HTML documents and aTagname against everything else.
 // For any other value of aMatchNameSpaceId, the list will match
 // aTagname against all elements.
 already_AddRefed<nsContentList>
 NS_GetContentList(nsINode* aRootNode,
                   int32_t aMatchNameSpaceId,
                   const nsAString& aTagname);
 
+template<class ListType>
 already_AddRefed<nsContentList>
-NS_GetFuncStringNodeList(nsINode* aRootNode,
+GetFuncStringContentList(nsINode* aRootNode,
                          nsContentListMatchFunc aFunc,
                          nsContentListDestroyFunc aDestroyFunc,
                          nsFuncStringContentListDataAllocator aDataAllocator,
                          const nsAString& aString);
-already_AddRefed<nsContentList>
-NS_GetFuncStringHTMLCollection(nsINode* aRootNode,
-                               nsContentListMatchFunc aFunc,
-                               nsContentListDestroyFunc aDestroyFunc,
-                               nsFuncStringContentListDataAllocator aDataAllocator,
-                               const nsAString& aString);
 
 #endif // nsContentListDeclarations_h
diff --git a/dom/base/nsContentSink.cpp b/dom/base/nsContentSink.cpp
--- a/dom/base/nsContentSink.cpp
+++ b/dom/base/nsContentSink.cpp
@@ -1654,14 +1654,8 @@ nsContentSink::NotifyDocElementCreated(n
 }
 
 NS_IMETHODIMP
 nsContentSink::GetName(nsACString& aName)
 {
   aName.AssignASCII("nsContentSink_timer");
   return NS_OK;
 }
-
-NS_IMETHODIMP
-nsContentSink::SetName(const char* aName)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
diff --git a/dom/base/nsContentUtils.h b/dom/base/nsContentUtils.h
--- a/dom/base/nsContentUtils.h
+++ b/dom/base/nsContentUtils.h
@@ -50,16 +50,17 @@
 
 class imgICache;
 class imgIContainer;
 class imgINotificationObserver;
 class imgIRequest;
 class imgLoader;
 class imgRequestProxy;
 class nsAutoScriptBlockerSuppressNodeRemoved;
+class nsCacheableFuncStringHTMLCollection;
 class nsHtml5StringParser;
 class nsIChannel;
 class nsIConsoleService;
 class nsIContent;
 class nsIContentPolicy;
 class nsIContentSecurityPolicy;
 class nsIDocShellTreeItem;
 class nsIDocumentLoaderFactory;
@@ -2078,20 +2079,21 @@ public:
    * Utility method for getElementsByClassName.  aRootNode is the node (either
    * document or element), which getElementsByClassName was called on.
    */
   static already_AddRefed<nsContentList>
   GetElementsByClassName(nsINode* aRootNode, const nsAString& aClasses)
   {
     NS_PRECONDITION(aRootNode, "Must have root node");
 
-    return NS_GetFuncStringHTMLCollection(aRootNode, MatchClassNames,
-                                          DestroyClassNameArray,
-                                          AllocClassMatchingInfo,
-                                          aClasses);
+    return GetFuncStringContentList<nsCacheableFuncStringHTMLCollection>(aRootNode,
+                                                                         MatchClassNames,
+                                                                         DestroyClassNameArray,
+                                                                         AllocClassMatchingInfo,
+                                                                         aClasses);
   }
 
   /**
    * Returns a presshell for this document, if there is one. This will be
    * aDoc's direct presshell if there is one, otherwise we'll look at all
    * ancestor documents to try to find a presshell, so for example this can
    * still find a presshell for documents in display:none frames that have
    * no presentation. So you have to be careful how you use this presshell ---
diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -1577,17 +1577,17 @@ nsWindowSH::GlobalResolve(nsGlobalWindow
   // this is called during Window setup when the Document isn't necessarily
   // hooked up yet.
   if ((id == XPCJSRuntime::Get()->GetStringID(XPCJSContext::IDX_CONTROLLERS) ||
        id == XPCJSRuntime::Get()->GetStringID(XPCJSContext::IDX_CONTROLLERS_CLASS)) &&
       !xpc::IsXrayWrapper(obj) &&
       !nsContentUtils::IsSystemPrincipal(nsContentUtils::ObjectPrincipal(obj)))
   {
     if (aWin->GetDoc()) {
-      aWin->GetDoc()->WarnOnceAbout(nsIDocument::eWindow_Controllers);
+      aWin->GetDoc()->WarnOnceAbout(nsIDocument::eWindow_Cc_ontrollers);
     }
     const JSClass* clazz;
     if (id == XPCJSRuntime::Get()->GetStringID(XPCJSContext::IDX_CONTROLLERS)) {
       clazz = &XULControllersShimClass;
     } else {
       clazz = &ControllersShimClass;
     }
     MOZ_ASSERT(JS_IsGlobalObject(obj));
diff --git a/dom/base/nsDeprecatedOperationList.h b/dom/base/nsDeprecatedOperationList.h
--- a/dom/base/nsDeprecatedOperationList.h
+++ b/dom/base/nsDeprecatedOperationList.h
@@ -32,17 +32,17 @@ DEPRECATED_OPERATION(GetSetUserData)
 DEPRECATED_OPERATION(MozGetAsFile)
 DEPRECATED_OPERATION(UseOfCaptureEvents)
 DEPRECATED_OPERATION(UseOfReleaseEvents)
 DEPRECATED_OPERATION(UseOfDOM3LoadMethod)
 DEPRECATED_OPERATION(ChromeUseOfDOM3LoadMethod)
 DEPRECATED_OPERATION(ShowModalDialog)
 DEPRECATED_OPERATION(Window_Content)
 DEPRECATED_OPERATION(SyncXMLHttpRequest)
-DEPRECATED_OPERATION(Window_Controllers)
+DEPRECATED_OPERATION(Window_Cc_ontrollers)
 DEPRECATED_OPERATION(ImportXULIntoContent)
 DEPRECATED_OPERATION(PannerNodeDoppler)
 DEPRECATED_OPERATION(NavigatorGetUserMedia)
 DEPRECATED_OPERATION(WebrtcDeprecatedPrefix)
 DEPRECATED_OPERATION(RTCPeerConnectionGetStreams)
 DEPRECATED_OPERATION(AppCache)
 DEPRECATED_OPERATION(PrefixedImageSmoothingEnabled)
 DEPRECATED_OPERATION(PrefixedFullscreenAPI)
diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -3045,25 +3045,24 @@ nsIDocument::GetDocGroup() const
     // XXX: Check that the TabGroup is correct as well!
   }
 #endif
 
   return mDocGroup;
 }
 
 nsresult
-nsIDocument::Dispatch(const char* aName,
-                      TaskCategory aCategory,
+nsIDocument::Dispatch(TaskCategory aCategory,
                       already_AddRefed<nsIRunnable>&& aRunnable)
 {
   // Note that this method may be called off the main thread.
   if (mDocGroup) {
-    return mDocGroup->Dispatch(aName, aCategory, Move(aRunnable));
-  }
-  return DispatcherTrait::Dispatch(aName, aCategory, Move(aRunnable));
+    return mDocGroup->Dispatch(aCategory, Move(aRunnable));
+  }
+  return DispatcherTrait::Dispatch(aCategory, Move(aRunnable));
 }
 
 nsISerialEventTarget*
 nsIDocument::EventTargetFor(TaskCategory aCategory) const
 {
   if (mDocGroup) {
     return mDocGroup->EventTargetFor(aCategory);
   }
@@ -4454,18 +4453,17 @@ nsDocument::SetStyleSheetApplicableState
   if (!mSSApplicableStateNotificationPending) {
     MOZ_RELEASE_ASSERT(NS_IsMainThread());
     nsCOMPtr<nsIRunnable> notification =
       NewRunnableMethod("nsDocument::NotifyStyleSheetApplicableStateChanged",
                         this,
                         &nsDocument::NotifyStyleSheetApplicableStateChanged);
     mSSApplicableStateNotificationPending =
       NS_SUCCEEDED(
-        Dispatch("nsDocument::NotifyStyleSheetApplicableStateChanged",
-                 TaskCategory::Other, notification.forget()));
+        Dispatch(TaskCategory::Other, notification.forget()));
   }
 }
 
 void
 nsDocument::NotifyStyleSheetApplicableStateChanged()
 {
   mSSApplicableStateNotificationPending = false;
   nsCOMPtr<nsIObserverService> observerService =
@@ -5402,17 +5400,17 @@ nsDocument::UnblockDOMContentLoaded()
 
   MOZ_ASSERT(mReadyState == READYSTATE_INTERACTIVE);
   if (!mSynchronousDOMContentLoaded) {
     MOZ_RELEASE_ASSERT(NS_IsMainThread());
     nsCOMPtr<nsIRunnable> ev =
       NewRunnableMethod("nsDocument::DispatchContentLoadedEvents",
                         this,
                         &nsDocument::DispatchContentLoadedEvents);
-    Dispatch("nsDocument::DispatchContentLoadedEvents", TaskCategory::Other, ev.forget());
+    Dispatch(TaskCategory::Other, ev.forget());
   } else {
     DispatchContentLoadedEvents();
   }
 }
 
 void
 nsDocument::ContentStateChanged(nsIContent* aContent, EventStates aStateMask)
 {
@@ -7042,18 +7040,17 @@ nsDocument::NotifyPossibleTitleChange(bo
   if (mPendingTitleChangeEvent.IsPending())
     return;
 
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
   RefPtr<nsRunnableMethod<nsDocument, void, false>> event =
     NewNonOwningRunnableMethod("nsDocument::DoNotifyPossibleTitleChange",
                                this,
                                &nsDocument::DoNotifyPossibleTitleChange);
-  nsresult rv = Dispatch("nsDocument::DoNotifyPossibleTitleChange",
-                         TaskCategory::Other, do_AddRef(event));
+  nsresult rv = Dispatch(TaskCategory::Other, do_AddRef(event));
   if (NS_SUCCEEDED(rv)) {
     mPendingTitleChangeEvent = Move(event);
   }
 }
 
 void
 nsDocument::DoNotifyPossibleTitleChange()
 {
@@ -8889,17 +8886,17 @@ private:
 };
 
 void
 nsDocument::PostUnblockOnloadEvent()
 {
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIRunnable> evt = new nsUnblockOnloadEvent(this);
   nsresult rv =
-    Dispatch("nsUnblockOnloadEvent", TaskCategory::Other, evt.forget());
+    Dispatch(TaskCategory::Other, evt.forget());
   if (NS_SUCCEEDED(rv)) {
     // Stabilize block count so we don't post more events while this one is up
     ++mOnloadBlockCount;
   } else {
     NS_WARNING("failed to dispatch nsUnblockOnloadEvent");
   }
 }
 
@@ -9800,17 +9797,17 @@ void
 nsDocument::UnsuppressEventHandlingAndFireEvents(bool aFireEvents)
 {
   nsTArray<nsCOMPtr<nsIDocument>> documents;
   GetAndUnsuppressSubDocuments(this, &documents);
 
   if (aFireEvents) {
     MOZ_RELEASE_ASSERT(NS_IsMainThread());
     nsCOMPtr<nsIRunnable> ded = new nsDelayedEventDispatcher(documents);
-    Dispatch("nsDelayedEventDispatcher", TaskCategory::Other, ded.forget());
+    Dispatch(TaskCategory::Other, ded.forget());
   } else {
     FireOrClearDelayedEvents(documents, false);
   }
 }
 
 nsISupports*
 nsDocument::GetCurrentContentSink()
 {
@@ -10953,17 +10950,17 @@ private:
 };
 
 /* static */ void
 nsIDocument::AsyncExitFullscreen(nsIDocument* aDoc)
 {
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIRunnable> exit = new nsCallExitFullscreen(aDoc);
   if (aDoc) {
-    aDoc->Dispatch("nsCallExitFullscreen", TaskCategory::Other, exit.forget());
+    aDoc->Dispatch(TaskCategory::Other, exit.forget());
   } else {
     NS_DispatchToCurrentThread(exit.forget());
   }
 }
 
 static bool
 CountFullscreenSubDocuments(nsIDocument* aDoc, void* aData)
 {
@@ -11234,17 +11231,17 @@ nsDocument::AsyncRequestFullScreen(Uniqu
     MOZ_ASSERT_UNREACHABLE(
       "Must pass non-null element to nsDocument::AsyncRequestFullScreen");
     return;
   }
 
   // Request full-screen asynchronously.
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIRunnable> event = new nsCallRequestFullScreen(Move(aRequest));
-  Dispatch("nsCallRequestFullScreen", TaskCategory::Other, event.forget());
+  Dispatch(TaskCategory::Other, event.forget());
 }
 
 void
 nsIDocument::DispatchFullscreenError(const char* aMessage)
 {
   RefPtr<AsyncEventDispatcher> asyncDispatcher =
     new AsyncEventDispatcher(this,
                              NS_LITERAL_STRING("fullscreenerror"),
@@ -12111,17 +12108,17 @@ nsDocument::RequestPointerLock(Element* 
     DispatchPointerLockError(this, msg);
     return;
   }
 
   bool userInputOrSystemCaller = EventStateManager::IsHandlingUserInput() ||
                                  aCallerType == CallerType::System;
   nsCOMPtr<nsIRunnable> request =
     new PointerLockRequest(aElement, userInputOrSystemCaller);
-  Dispatch("PointerLockRequest", TaskCategory::Other, request.forget());
+  Dispatch(TaskCategory::Other, request.forget());
 }
 
 bool
 nsDocument::SetPointerLock(Element* aElement, int aCursorStyle)
 {
   MOZ_ASSERT(!aElement || aElement->OwnerDoc() == this,
              "We should be either unlocking pointer (aElement is nullptr), "
              "or locking pointer to an element in this document");
@@ -12296,17 +12293,17 @@ nsDocument::GetVisibilityState() const
 
 /* virtual */ void
 nsDocument::PostVisibilityUpdateEvent()
 {
   nsCOMPtr<nsIRunnable> event =
     NewRunnableMethod("nsDocument::UpdateVisibilityState",
                       this,
                       &nsDocument::UpdateVisibilityState);
-  Dispatch("nsDocument::UpdateVisibilityState", TaskCategory::Other, event.forget());
+  Dispatch(TaskCategory::Other, event.forget());
 }
 
 void
 nsDocument::MaybeActiveMediaComponents()
 {
   if (!mWindow) {
     return;
   }
@@ -12843,18 +12840,17 @@ nsDocument::ScheduleIntersectionObserver
   if (mIntersectionObservers.IsEmpty()) {
     return;
   }
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIRunnable> notification =
     NewRunnableMethod("nsDocument::NotifyIntersectionObservers",
                       this,
                       &nsDocument::NotifyIntersectionObservers);
-  Dispatch("nsDocument::IntersectionObserverNotification", TaskCategory::Other,
-           notification.forget());
+  Dispatch(TaskCategory::Other, notification.forget());
 }
 
 void
 nsDocument::NotifyIntersectionObservers()
 {
   nsTArray<RefPtr<DOMIntersectionObserver>> observers(mIntersectionObservers.Count());
   for (auto iter = mIntersectionObservers.Iter(); !iter.Done(); iter.Next()) {
     DOMIntersectionObserver* observer = iter.Get()->GetKey();
@@ -13135,18 +13131,17 @@ nsIDocument::RebuildUserFontSet()
   // which starts font loads, whose completion causes another style
   // change reflow).
   if (!mPostedFlushUserFontSet) {
     MOZ_RELEASE_ASSERT(NS_IsMainThread());
     nsCOMPtr<nsIRunnable> ev =
       NewRunnableMethod("nsIDocument::HandleRebuildUserFontSet",
                         this,
                         &nsIDocument::HandleRebuildUserFontSet);
-    if (NS_SUCCEEDED(Dispatch("nsIDocument::HandleRebuildUserFontSet",
-                              TaskCategory::Other, ev.forget()))) {
+    if (NS_SUCCEEDED(Dispatch(TaskCategory::Other, ev.forget()))) {
       mPostedFlushUserFontSet = true;
     }
   }
 }
 
 FontFaceSet*
 nsIDocument::Fonts()
 {
diff --git a/dom/base/nsGkAtomList.h b/dom/base/nsGkAtomList.h
--- a/dom/base/nsGkAtomList.h
+++ b/dom/base/nsGkAtomList.h
@@ -1029,16 +1029,17 @@ GK_ATOM(ontransitionrun, "ontransitionru
 GK_ATOM(ontransitionstart, "ontransitionstart")
 GK_ATOM(onunderflow, "onunderflow")
 GK_ATOM(onunload, "onunload")
 GK_ATOM(onupdatefound, "onupdatefound")
 GK_ATOM(onupdateready, "onupdateready")
 GK_ATOM(onupgradeneeded, "onupgradeneeded")
 GK_ATOM(onussdreceived, "onussdreceived")
 GK_ATOM(onversionchange, "onversionchange")
+GK_ATOM(onvisibilitychange, "onvisibilitychange")
 GK_ATOM(onvoicechange, "onvoicechange")
 GK_ATOM(onvoiceschanged, "onvoiceschanged")
 GK_ATOM(onvrdisplayactivate, "onvrdisplayactivate")
 GK_ATOM(onvrdisplayconnect, "onvrdisplayconnect")
 GK_ATOM(onvrdisplaydeactivate, "onvrdisplaydeactivate")
 GK_ATOM(onvrdisplaydisconnect, "onvrdisplaydisconnect")
 GK_ATOM(onvrdisplaypresentchange, "onvrdisplaypresentchange")
 GK_ATOM(onwebkitAnimationEnd, "onwebkitAnimationEnd")
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -19,16 +19,17 @@
 #include "nsIDOMStorageManager.h"
 #include "mozilla/dom/LocalStorage.h"
 #include "mozilla/dom/Storage.h"
 #include "mozilla/dom/IdleRequest.h"
 #include "mozilla/dom/Performance.h"
 #include "mozilla/dom/StorageEvent.h"
 #include "mozilla/dom/StorageEventBinding.h"
 #include "mozilla/dom/StorageNotifierService.h"
+#include "mozilla/dom/StorageUtils.h"
 #include "mozilla/dom/Timeout.h"
 #include "mozilla/dom/TimeoutHandler.h"
 #include "mozilla/dom/TimeoutManager.h"
 #include "mozilla/IntegerPrintfMacros.h"
 #if defined(MOZ_WIDGET_ANDROID)
 #include "mozilla/dom/WindowOrientationObserver.h"
 #endif
 #include "nsDOMOfflineResourceList.h"
@@ -493,17 +494,29 @@ public:
                              bool aPrivateBrowsing) override
   {
     if (mWindow) {
       mWindow->ObserveStorageNotification(aEvent, aStorageType,
                                           aPrivateBrowsing);
     }
   }
 
-  virtual nsIEventTarget*
+  nsIPrincipal*
+  GetPrincipal() const override
+  {
+    return mWindow ? mWindow->GetPrincipal() : nullptr;
+  }
+
+  bool
+  IsPrivateBrowsing() const override
+  {
+    return mWindow ? mWindow->IsPrivateBrowsing() : false;
+  }
+
+  nsIEventTarget*
   GetEventTarget() const override
   {
     return mWindow ? mWindow->EventTargetFor(TaskCategory::Other) : nullptr;
   }
 
 private:
   ~nsGlobalWindowObserver() = default;
 
@@ -676,22 +689,16 @@ NS_INTERFACE_MAP_END
 NS_IMETHODIMP
 IdleRequestExecutor::GetName(nsACString& aName)
 {
     aName.AssignASCII("IdleRequestExecutor");
     return NS_OK;
 }
 
 NS_IMETHODIMP
-IdleRequestExecutor::SetName(const char* aName)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
 IdleRequestExecutor::Run()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   mDispatched = false;
   if (mWindow) {
     return mWindow->ExecuteIdleRequest(mDeadline);
   }
@@ -9237,17 +9244,17 @@ nsGlobalWindow::PostMessageMozOuter(JSCo
   JS::Rooted<JS::Value> message(aCx, aMessage);
   JS::Rooted<JS::Value> transfer(aCx, aTransfer);
 
   event->Write(aCx, message, transfer, JS::CloneDataPolicy(), aError);
   if (NS_WARN_IF(aError.Failed())) {
     return;
   }
 
-  aError = Dispatch("PostMessageEvent", TaskCategory::Other, event.forget());
+  aError = Dispatch(TaskCategory::Other, event.forget());
 }
 
 void
 nsGlobalWindow::PostMessageMoz(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                                const nsAString& aTargetOrigin,
                                JS::Handle<JS::Value> aTransfer,
                                nsIPrincipal& aSubjectPrincipal,
                                ErrorResult& aError)
@@ -9289,17 +9296,17 @@ class nsCloseEvent : public Runnable {
   {}
 
 public:
 
   static nsresult
   PostCloseEvent(nsGlobalWindow* aWindow, bool aIndirect) {
     nsCOMPtr<nsIRunnable> ev = new nsCloseEvent(aWindow, aIndirect);
     nsresult rv =
-      aWindow->Dispatch("nsCloseEvent", TaskCategory::Other, ev.forget());
+      aWindow->Dispatch(TaskCategory::Other, ev.forget());
     if (NS_SUCCEEDED(rv))
       aWindow->MaybeForgiveSpamCount();
     return rv;
   }
 
   NS_IMETHOD Run() override {
     if (mWindow) {
       if (mIndirect) {
@@ -9820,18 +9827,17 @@ private:
   nsCString mTopic;
   nsWeakPtr mWindow;
 };
 
 void
 nsGlobalWindow::NotifyWindowIDDestroyed(const char* aTopic)
 {
   nsCOMPtr<nsIRunnable> runnable = new WindowDestroyedEvent(this, mWindowID, aTopic);
-  nsresult rv =
-    Dispatch("WindowDestroyedEvent", TaskCategory::Other, runnable.forget());
+  nsresult rv = Dispatch(TaskCategory::Other, runnable.forget());
   if (NS_SUCCEEDED(rv)) {
     mNotifiedIDDestroyed = true;
   }
 }
 
 // static
 void
 nsGlobalWindow::NotifyDOMWindowFrozen(nsGlobalWindow* aWindow) {
@@ -11089,17 +11095,17 @@ nsGlobalWindow::DispatchAsyncHashchange(
   rv = aNewURI->GetSpec(newSpec);
   NS_ENSURE_SUCCESS(rv, rv);
 
   NS_ConvertUTF8toUTF16 oldWideSpec(oldSpec);
   NS_ConvertUTF8toUTF16 newWideSpec(newSpec);
 
   nsCOMPtr<nsIRunnable> callback =
     new HashchangeCallback(oldWideSpec, newWideSpec, this);
-  return Dispatch("HashchangeCallback", TaskCategory::Other, callback.forget());
+  return Dispatch(TaskCategory::Other, callback.forget());
 }
 
 nsresult
 nsGlobalWindow::FireHashchange(const nsAString &aOldURL,
                                const nsAString &aNewURL)
 {
   MOZ_ASSERT(IsInnerWindow());
 
@@ -11689,18 +11695,17 @@ nsGlobalWindow::NotifyIdleObserver(IdleO
 {
   MOZ_ASSERT(aIdleObserverHolder);
   aIdleObserverHolder->mPrevNotificationIdle = aCallOnidle;
 
   nsCOMPtr<nsIRunnable> caller =
     new NotifyIdleObserverRunnable(aIdleObserverHolder->mIdleObserver,
                                    aIdleObserverHolder->mTimeInS,
                                    aCallOnidle, this);
-  if (NS_FAILED(Dispatch("NotifyIdleObserverRunnable", TaskCategory::Other,
-                         caller.forget()))) {
+  if (NS_FAILED(Dispatch(TaskCategory::Other, caller.forget()))) {
     NS_WARNING("Failed to dispatch thread for idle observer notification.");
   }
 }
 
 bool
 nsGlobalWindow::ContainsIdleObserver(nsIIdleObserver* aIdleObserver, uint32_t aTimeInS)
 {
   MOZ_ASSERT(aIdleObserver, "Idle observer not instantiated.");
@@ -12367,26 +12372,17 @@ nsGlobalWindow::Observe(nsISupports* aSu
 
 void
 nsGlobalWindow::ObserveStorageNotification(StorageEvent* aEvent,
                                            const char16_t* aStorageType,
                                            bool aPrivateBrowsing)
 {
   MOZ_ASSERT(aEvent);
 
-  // Enforce that the source storage area's private browsing state matches
-  // this window's state.  These flag checks and their maintenance independent
-  // from the principal's OriginAttributes matter because chrome docshells
-  // that are part of private browsing windows can be private browsing without
-  // having their OriginAttributes set (because they have the system
-  // principal).
-  bool isPrivateBrowsing = IsPrivateBrowsing();
-  if (isPrivateBrowsing != aPrivateBrowsing) {
-    return;
-  }
+  MOZ_DIAGNOSTIC_ASSERT(IsPrivateBrowsing() == aPrivateBrowsing);
 
   // LocalStorage can only exist on an inner window, and we don't want to
   // generate events on frozen or otherwise-navigated-away from windows.
   // (Actually, this code used to try and buffer events for frozen windows,
   // but it never worked, so we've removed it.  See bug 1285898.)
   if (!IsInnerWindow() || !AsInner()->IsCurrentInnerWindow() || IsFrozen()) {
     return;
   }
@@ -12428,28 +12424,19 @@ nsGlobalWindow::ObserveStorageNotificati
     fireMozStorageChanged = mSessionStorage == changingStorage;
     if (fireMozStorageChanged) {
       eventType.AssignLiteral("MozSessionStorageChanged");
     }
   }
 
   else {
     MOZ_ASSERT(!NS_strcmp(aStorageType, u"localStorage"));
-    nsIPrincipal* storagePrincipal = aEvent->GetPrincipal();
-    if (!storagePrincipal) {
-      return;
-    }
-
-    bool equals = false;
-    nsresult rv = storagePrincipal->Equals(principal, &equals);
-    NS_ENSURE_SUCCESS_VOID(rv);
-
-    if (!equals) {
-      return;
-    }
+
+    MOZ_DIAGNOSTIC_ASSERT(StorageUtils::PrincipalsEqual(aEvent->GetPrincipal(),
+                                                        principal));
 
     fireMozStorageChanged = mLocalStorage == aEvent->GetStorageArea();
 
     if (fireMozStorageChanged) {
       eventType.AssignLiteral("MozLocalStorageChanged");
     }
   }
 
@@ -12891,18 +12878,17 @@ public:
     MOZ_ASSERT(mWin);
     MOZ_ASSERT(mWin->IsOuterWindow());
   }
   ~AutoUnblockScriptClosing()
   {
     void (nsGlobalWindow::*run)() = &nsGlobalWindow::UnblockScriptedClosing;
     nsCOMPtr<nsIRunnable> caller = NewRunnableMethod(
       "AutoUnblockScriptClosing::~AutoUnblockScriptClosing", mWin, run);
-    mWin->Dispatch("nsGlobalWindow::UnblockScriptedClosing",
-                   TaskCategory::Other, caller.forget());
+    mWin->Dispatch(TaskCategory::Other, caller.forget());
   }
 };
 
 nsresult
 nsGlobalWindow::OpenInternal(const nsAString& aUrl, const nsAString& aName,
                              const nsAString& aOptions, bool aDialog,
                              bool aContentModal, bool aCalledNoScript,
                              bool aDoJSFixups, bool aNavigate,
@@ -15395,25 +15381,24 @@ nsPIDOMWindow<T>::GetDocGroup() const
   nsIDocument* doc = GetExtantDoc();
   if (doc) {
     return doc->GetDocGroup();
   }
   return nullptr;
 }
 
 nsresult
-nsGlobalWindow::Dispatch(const char* aName,
-                         TaskCategory aCategory,
+nsGlobalWindow::Dispatch(TaskCategory aCategory,
                          already_AddRefed<nsIRunnable>&& aRunnable)
 {
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
   if (GetDocGroup()) {
-    return GetDocGroup()->Dispatch(aName, aCategory, Move(aRunnable));
-  }
-  return DispatcherTrait::Dispatch(aName, aCategory, Move(aRunnable));
+    return GetDocGroup()->Dispatch(aCategory, Move(aRunnable));
+  }
+  return DispatcherTrait::Dispatch(aCategory, Move(aRunnable));
 }
 
 nsISerialEventTarget*
 nsGlobalWindow::EventTargetFor(TaskCategory aCategory) const
 {
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
   if (GetDocGroup()) {
     return GetDocGroup()->EventTargetFor(aCategory);
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1824,18 +1824,17 @@ private:
   mozilla::dom::TabGroup* TabGroupOuter();
 
   bool IsBackgroundInternal() const;
 
   void SetIsBackgroundInternal(bool aIsBackground);
 
 public:
   // Dispatch a runnable related to the global.
-  virtual nsresult Dispatch(const char* aName,
-                            mozilla::TaskCategory aCategory,
+  virtual nsresult Dispatch(mozilla::TaskCategory aCategory,
                             already_AddRefed<nsIRunnable>&& aRunnable) override;
 
   virtual nsISerialEventTarget*
   EventTargetFor(mozilla::TaskCategory aCategory) const override;
 
   virtual mozilla::AbstractThread*
   AbstractMainThreadFor(mozilla::TaskCategory aCategory) override;
 
diff --git a/dom/base/nsIDocument.h b/dom/base/nsIDocument.h
--- a/dom/base/nsIDocument.h
+++ b/dom/base/nsIDocument.h
@@ -2932,18 +2932,17 @@ public:
   virtual void RemoveIntersectionObserver(
     mozilla::dom::DOMIntersectionObserver* aObserver) = 0;
 
   virtual void UpdateIntersectionObservations() = 0;
   virtual void ScheduleIntersectionObserverNotification() = 0;
   virtual void NotifyIntersectionObservers() = 0;
 
   // Dispatch a runnable related to the document.
-  virtual nsresult Dispatch(const char* aName,
-                            mozilla::TaskCategory aCategory,
+  virtual nsresult Dispatch(mozilla::TaskCategory aCategory,
                             already_AddRefed<nsIRunnable>&& aRunnable) override;
 
   virtual nsISerialEventTarget*
   EventTargetFor(mozilla::TaskCategory aCategory) const override;
 
   virtual mozilla::AbstractThread*
   AbstractMainThreadFor(mozilla::TaskCategory aCategory) override;
 
diff --git a/dom/bindings/TypedArray.h b/dom/bindings/TypedArray.h
--- a/dom/bindings/TypedArray.h
+++ b/dom/bindings/TypedArray.h
@@ -193,17 +193,17 @@ public:
   }
 
 private:
   TypedArray_base(const TypedArray_base&) = delete;
 };
 
 template<typename T,
          JSObject* UnwrapArray(JSObject*),
-         T* GetData(JSObject*, bool* isShared, const JS::AutoCheckCannotGC&),
+         T* GetData(JSObject*, bool* isShared, const JS::AutoRequireNoGC&),
          void GetLengthAndDataAndSharedness(JSObject*, uint32_t*, bool*, T**),
          JSObject* CreateNew(JSContext*, uint32_t)>
 struct TypedArray
   : public TypedArray_base<T, UnwrapArray, GetLengthAndDataAndSharedness>
 {
 private:
   typedef TypedArray_base<T, UnwrapArray, GetLengthAndDataAndSharedness> Base;
 
diff --git a/dom/canvas/WebGLContextLossHandler.cpp b/dom/canvas/WebGLContextLossHandler.cpp
--- a/dom/canvas/WebGLContextLossHandler.cpp
+++ b/dom/canvas/WebGLContextLossHandler.cpp
@@ -1,46 +1,54 @@
 /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "WebGLContextLossHandler.h"
 
 #include "mozilla/DebugOnly.h"
+#include "nsINamed.h"
 #include "nsISupportsImpl.h"
 #include "nsITimer.h"
 #include "nsThreadUtils.h"
 #include "WebGLContext.h"
 
 namespace mozilla {
 
 class WatchdogTimerEvent final : public nsITimerCallback
+                               , public nsINamed
 {
     const WeakPtr<WebGLContextLossHandler> mHandler;
 
 public:
     NS_DECL_ISUPPORTS
 
     explicit WatchdogTimerEvent(WebGLContextLossHandler* handler)
         : mHandler(handler)
     { }
 
+    NS_IMETHOD GetName(nsACString& aName) override
+    {
+      aName.AssignLiteral("WatchdogTimerEvent");
+      return NS_OK;
+    }
+
 private:
     virtual ~WatchdogTimerEvent() { }
 
     NS_IMETHOD Notify(nsITimer*) override {
         if (mHandler) {
             mHandler->TimerCallback();
         }
         return NS_OK;
     }
 };
 
-NS_IMPL_ISUPPORTS(WatchdogTimerEvent, nsITimerCallback, nsISupports)
+NS_IMPL_ISUPPORTS(WatchdogTimerEvent, nsITimerCallback, nsINamed)
 
 ////////////////////////////////////////
 
 WebGLContextLossHandler::WebGLContextLossHandler(WebGLContext* webgl)
     : mWebGL(webgl)
     , mTimer(do_CreateInstance(NS_TIMER_CONTRACTID))
     , mTimerPending(false)
     , mShouldRunTimerAgain(false)
diff --git a/dom/canvas/test/imagebitmap_extensions_prepareSources.js b/dom/canvas/test/imagebitmap_extensions_prepareSources.js
--- a/dom/canvas/test/imagebitmap_extensions_prepareSources.js
+++ b/dom/canvas/test/imagebitmap_extensions_prepareSources.js
@@ -36,17 +36,16 @@ function prepareSources() {
     ok(gCtx, "[Prepare Sources] gCtx is ok.");
 
     // Prepare gGroundTruthImageData.
     gGroundTruthImageData = gCtx.getImageData(0, 0, gCanvas.width, gCanvas.height);
     ok(gGroundTruthImageData, "[Prepare Sources] gGroundTruthImageData is ok.");
 
     // Prepare image.
     gImage = document.createElement("img");
-    gImage.crossOrigin = "anonymous";
     gImage.src = gCanvas.toDataURL();
     var resolverImage;
     var promiseImage = new Promise(function(resolve, reject) {
       resolverImage = resolve;
     });
     gImage.onload = function() {
       resolverImage(true);
     }
@@ -87,9 +86,9 @@ function prepareSources() {
       promiseImage,
       promisePNGBlob,
       promiseJPEGBlob,
       promiseImageBitmap
     ]))
   }
 
   return promise;
-}
+}
\ No newline at end of file
diff --git a/dom/canvas/test/test_2d.fill.pattern.imageSmoothingEnabled.html b/dom/canvas/test/test_2d.fill.pattern.imageSmoothingEnabled.html
--- a/dom/canvas/test/test_2d.fill.pattern.imageSmoothingEnabled.html
+++ b/dom/canvas/test/test_2d.fill.pattern.imageSmoothingEnabled.html
@@ -35,17 +35,16 @@ function isNotPixel(ctx, x,y, r,g,b,a, p
 
 SimpleTest.waitForExplicitFinish();
 addLoadEvent(function () {
 
 var canvas = document.getElementById('c');
 var ctx = canvas.getContext('2d');
 
 var img = document.getElementById("img");
-img.crossOrigin = "anonymous";
 img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==";
 
 img.onload = function () {
   ctx.imageSmoothingEnabled = false;
   ctx.save();
   ctx.fillStyle = "rgb(127, 127, 127);";
   ctx.fillRect(0, 0, canvas.width, canvas.height);
   ctx.scale(16, 16);
diff --git a/dom/canvas/test/test_canvas.html b/dom/canvas/test/test_canvas.html
--- a/dom/canvas/test/test_canvas.html
+++ b/dom/canvas/test/test_canvas.html
@@ -20882,17 +20882,16 @@ img.onload = wrapFunction(function ()
     ctx667.drawImage(img, 0, 25);
     // (The alpha values do not really survive float->int conversion, so just
     // do approximate comparisons)
     isPixel(ctx667, 12,40, 1,3,254,255, 0);
     isPixel(ctx667, 37,40, 8,252,248,191, 2);
     isPixel(ctx667, 62,40, 6,10,250,127, 4);
     isPixel(ctx667, 87,40, 12,16,244,63, 8);
 });
-img.crossOrigin = "anonymous";
 img.src = canvas667.toDataURL();
 
 
 }
 </script>
 
 <!-- [[[ test_toDataURL.default.html ]]] -->
 
@@ -21009,17 +21008,16 @@ deferTest();
 img.onload = wrapFunction(function ()
 {
     ctx672.drawImage(img, 0, 0);
     isPixel(ctx672, 12,20, 255,255,0,255, 0);
     isPixel(ctx672, 50,20, 0,255,255,255, 0);
     isPixel(ctx672, 87,20, 0,0,255,255, 0);
     isPixel(ctx672, 50,45, 255,255,255,255, 0);
 });
-img.crossOrigin = "anonymous";
 img.src = data;
 
 
 }
 </script>
 
 <!-- [[[ test_toDataURL.unrecognised.html ]]] -->
 
diff --git a/dom/canvas/test/test_imagebitmap_cropping.html b/dom/canvas/test/test_imagebitmap_cropping.html
--- a/dom/canvas/test/test_imagebitmap_cropping.html
+++ b/dom/canvas/test/test_imagebitmap_cropping.html
@@ -157,17 +157,16 @@ function prepareSources() {
     gCanvas.height = gVideo.videoHeight;
     gCtx.drawImage(gVideo, 0, 0);
     ok(gCanvas, "[Prepare Sources] gCanvas is ok.");
     ok(gCtx, "[Prepare Sources] gCtx is ok.");
 
     // Prepare image.
     gImage = document.createElement("img");
     gImage.src = gCanvas.toDataURL();
-    gImage.crossOrigin = "anonymous";
     var resolverImage;
     var promiseImage = new Promise(function(resolve, reject) {
       resolverImage = resolve;
     });
     gImage.onload = function() {
       resolverImage(true);
     }
 
diff --git a/dom/canvas/test/test_toDataURL_alpha.html b/dom/canvas/test/test_toDataURL_alpha.html
--- a/dom/canvas/test/test_toDataURL_alpha.html
+++ b/dom/canvas/test/test_toDataURL_alpha.html
@@ -165,17 +165,16 @@ function do_canvas(row, col, type, optio
         b = colors[2]*colors[3];
 
     img.onload = function ()
     {
         ctx.drawImage(img, 0, 0);
         isPixel(ctx, 50,25, r,g,b,255, 8);
         finishedTests[row + '_' + col] = true;
     };
-    img.crossOrigin = "anonymous";
     img.src = data;
 }
 
 function checkFinished()
 {
     for (var t in finishedTests) {
         if (!finishedTests[t]) {
             setTimeout(checkFinished, 500);
diff --git a/dom/events/AsyncEventDispatcher.cpp b/dom/events/AsyncEventDispatcher.cpp
--- a/dom/events/AsyncEventDispatcher.cpp
+++ b/dom/events/AsyncEventDispatcher.cpp
@@ -79,24 +79,24 @@ AsyncEventDispatcher::Cancel()
 }
 
 nsresult
 AsyncEventDispatcher::PostDOMEvent()
 {
   RefPtr<AsyncEventDispatcher> ensureDeletionWhenFailing = this;
   if (NS_IsMainThread()) {
     if (nsCOMPtr<nsIGlobalObject> global = mTarget->GetOwnerGlobal()) {
-      return global->Dispatch("AsyncEventDispatcher", TaskCategory::Other, ensureDeletionWhenFailing.forget());
+      return global->Dispatch(TaskCategory::Other, ensureDeletionWhenFailing.forget());
     }
 
     // Sometimes GetOwnerGlobal returns null because it uses
     // GetScriptHandlingObject rather than GetScopeObject.
     if (nsCOMPtr<nsINode> node = do_QueryInterface(mTarget)) {
       nsCOMPtr<nsIDocument> doc = node->OwnerDoc();
-      return doc->Dispatch("AsyncEventDispatcher", TaskCategory::Other, ensureDeletionWhenFailing.forget());
+      return doc->Dispatch(TaskCategory::Other, ensureDeletionWhenFailing.forget());
     }
   }
   return NS_DispatchToCurrentThread(this);
 }
 
 void
 AsyncEventDispatcher::RunDOMEventWhenSafe()
 {
diff --git a/dom/events/DataTransferItem.cpp b/dom/events/DataTransferItem.cpp
--- a/dom/events/DataTransferItem.cpp
+++ b/dom/events/DataTransferItem.cpp
@@ -473,17 +473,17 @@ DataTransferItem::GetAsString(FunctionSt
   if (parent && !global) {
     if (nsCOMPtr<dom::EventTarget> target = do_QueryInterface(parent)) {
       global = target->GetOwnerGlobal();
     } else if (nsCOMPtr<nsIDOMEvent> event = do_QueryInterface(parent)) {
       global = event->InternalDOMEvent()->GetParentObject();
     }
   }
   if (global) {
-    rv = global->Dispatch("GASRunnable", TaskCategory::Other, runnable.forget());
+    rv = global->Dispatch(TaskCategory::Other, runnable.forget());
   } else {
     rv = NS_DispatchToMainThread(runnable);
   }
   if (NS_FAILED(rv)) {
     NS_WARNING("Dispatch to main thread Failed in "
                "DataTransferItem::GetAsString!");
   }
 }
diff --git a/dom/events/EventListenerService.cpp b/dom/events/EventListenerService.cpp
--- a/dom/events/EventListenerService.cpp
+++ b/dom/events/EventListenerService.cpp
@@ -366,20 +366,19 @@ EventListenerService::NotifyAboutMainThr
   }
 
   if (!mPendingListenerChanges) {
     mPendingListenerChanges = nsArrayBase::Create();
     nsCOMPtr<nsIRunnable> runnable =
       NewRunnableMethod("EventListenerService::NotifyPendingChanges",
                         this, &EventListenerService::NotifyPendingChanges);
     if (nsCOMPtr<nsIGlobalObject> global = aTarget->GetOwnerGlobal()) {
-      global->Dispatch(nullptr, TaskCategory::Other, runnable.forget());
+      global->Dispatch(TaskCategory::Other, runnable.forget());
     } else if (nsCOMPtr<nsINode> node = do_QueryInterface(aTarget)) {
-      node->OwnerDoc()->Dispatch(nullptr, TaskCategory::Other,
-                                 runnable.forget());
+      node->OwnerDoc()->Dispatch(TaskCategory::Other, runnable.forget());
     } else {
       NS_DispatchToCurrentThread(runnable);
     }
   }
 
   RefPtr<EventListenerChange> changes =
     mPendingListenerChangesSet.LookupForAdd(aTarget).OrInsert(
       [this, aTarget] () {
diff --git a/dom/events/EventNameList.h b/dom/events/EventNameList.h
--- a/dom/events/EventNameList.h
+++ b/dom/events/EventNameList.h
@@ -677,16 +677,21 @@ TOUCH_EVENT(touchcancel,
 DOCUMENT_ONLY_EVENT(readystatechange,
                     eReadyStateChange,
                     EventNameType_HTMLXUL,
                     eBasicEventClass)
 DOCUMENT_ONLY_EVENT(selectionchange,
                     eSelectionChange,
                     EventNameType_HTMLXUL,
                     eBasicEventClass)
+DOCUMENT_ONLY_EVENT(visibilitychange,
+                    eVisibilityChange,
+                    EventNameType_HTMLXUL,
+                    eBasicEventClass)
+
 
 NON_IDL_EVENT(MozMouseHittest,
               eMouseHitTest,
               EventNameType_None,
               eMouseEventClass)
 
 NON_IDL_EVENT(DOMAttrModified,
               eLegacyAttrModified,
diff --git a/dom/events/EventStateManager.cpp b/dom/events/EventStateManager.cpp
--- a/dom/events/EventStateManager.cpp
+++ b/dom/events/EventStateManager.cpp
@@ -232,22 +232,16 @@ UITimerCallback::Notify(nsITimer* aTimer
 
 NS_IMETHODIMP
 UITimerCallback::GetName(nsACString& aName)
 {
   aName.AssignASCII("UITimerCallback_timer");
   return NS_OK;
 }
 
-NS_IMETHODIMP
-UITimerCallback::SetName(const char* aName)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
 /******************************************************************/
 /* mozilla::OverOutElementsWrapper                                */
 /******************************************************************/
 
 OverOutElementsWrapper::OverOutElementsWrapper()
   : mLastOverFrame(nullptr)
 {
 }
diff --git a/dom/events/IMEContentObserver.cpp b/dom/events/IMEContentObserver.cpp
--- a/dom/events/IMEContentObserver.cpp
+++ b/dom/events/IMEContentObserver.cpp
@@ -1843,17 +1843,17 @@ IMEContentObserver::IMENotificationSende
       }
     }
   }
 
   nsIScriptGlobalObject* globalObject =
     aDocShell ? aDocShell->GetScriptGlobalObject() : nullptr;
   if (globalObject) {
     RefPtr<IMENotificationSender> queuedSender = this;
-    globalObject->Dispatch(nullptr, TaskCategory::Other,
+    globalObject->Dispatch(TaskCategory::Other,
                            queuedSender.forget());
   } else {
     NS_DispatchToCurrentThread(this);
   }
 }
 
 NS_IMETHODIMP
 IMEContentObserver::IMENotificationSender::Run()
diff --git a/dom/fetch/FetchConsumer.cpp b/dom/fetch/FetchConsumer.cpp
diff --git a/dom/fetch/FetchConsumer.h b/dom/fetch/FetchConsumer.h
diff --git a/dom/file/FileReader.cpp b/dom/file/FileReader.cpp
--- a/dom/file/FileReader.cpp
+++ b/dom/file/FileReader.cpp
@@ -66,16 +66,17 @@ NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INH
                                                DOMEventTargetHelper)
   NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mResultArrayBuffer)
 NS_IMPL_CYCLE_COLLECTION_TRACE_END
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(FileReader)
   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
   NS_INTERFACE_MAP_ENTRY(nsIInputStreamCallback)
   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
+  NS_INTERFACE_MAP_ENTRY(nsINamed)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 
 NS_IMPL_ADDREF_INHERITED(FileReader, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(FileReader, DOMEventTargetHelper)
 
 class MOZ_RAII FileReaderDecreaseBusyCounter
 {
   RefPtr<FileReader> mFileReader;
@@ -679,16 +680,24 @@ FileReader::OnInputStreamReady(nsIAsyncI
     NS_ENSURE_SUCCESS(rv, rv);
 
     StartProgressEventTimer();
   }
 
   return NS_OK;
 }
 
+// nsINamed
+NS_IMETHODIMP
+FileReader::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("FileReader");
+  return NS_OK;
+}
+
 nsresult
 FileReader::OnLoadEnd(nsresult aStatus)
 {
   // Cancel the progress event timer
   ClearProgressEventTimer();
 
   // FileReader must be in DONE stage after an operation
   mReadyState = DONE;
diff --git a/dom/file/FileReader.h b/dom/file/FileReader.h
--- a/dom/file/FileReader.h
+++ b/dom/file/FileReader.h
@@ -7,16 +7,17 @@
 #ifndef mozilla_dom_FileReader_h
 #define mozilla_dom_FileReader_h
 
 #include "mozilla/Attributes.h"
 #include "mozilla/DOMEventTargetHelper.h"
 
 #include "nsIAsyncInputStream.h"
 #include "nsIInterfaceRequestor.h"
+#include "nsINamed.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
 #include "nsWeakReference.h"
 #include "WorkerHolder.h"
 
 #define NS_PROGRESS_EVENT_INTERVAL 50
 
 class nsITimer;
@@ -36,29 +37,31 @@ extern const uint64_t kUnknownSize;
 
 class FileReaderDecreaseBusyCounter;
 
 class FileReader final : public DOMEventTargetHelper,
                          public nsIInterfaceRequestor,
                          public nsSupportsWeakReference,
                          public nsIInputStreamCallback,
                          public nsITimerCallback,
+                         public nsINamed,
                          public workers::WorkerHolder
 {
   friend class FileReaderDecreaseBusyCounter;
 
 public:
   FileReader(nsIGlobalObject* aGlobal,
              workers::WorkerPrivate* aWorkerPrivate);
 
   NS_DECL_ISUPPORTS_INHERITED
 
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSIINPUTSTREAMCALLBACK
   NS_DECL_NSIINTERFACEREQUESTOR
+  NS_DECL_NSINAMED
 
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED(FileReader,
                                                          DOMEventTargetHelper)
 
   virtual JSObject* WrapObject(JSContext* aCx,
                                JS::Handle<JSObject*> aGivenProto) override;
 
   // WebIDL
diff --git a/dom/file/ipc/IPCBlobInputStreamThread.cpp b/dom/file/ipc/IPCBlobInputStreamThread.cpp
--- a/dom/file/ipc/IPCBlobInputStreamThread.cpp
+++ b/dom/file/ipc/IPCBlobInputStreamThread.cpp
@@ -121,19 +121,17 @@ IPCBlobInputStreamThread::GetOrCreate()
   return gIPCBlobThread;
 }
 
 void
 IPCBlobInputStreamThread::Initialize()
 {
   if (!NS_IsMainThread()) {
     RefPtr<Runnable> runnable = new ThreadInitializeRunnable();
-    SystemGroup::Dispatch("IPCBlobInputStreamThread::Initialize",
-                          TaskCategory::Other,
-                          runnable.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, runnable.forget());
     return;
   }
 
   nsCOMPtr<nsIObserverService> obs = services::GetObserverService();
   if (NS_WARN_IF(!obs)) {
     return;
   }
 
diff --git a/dom/file/nsHostObjectProtocolHandler.cpp b/dom/file/nsHostObjectProtocolHandler.cpp
--- a/dom/file/nsHostObjectProtocolHandler.cpp
+++ b/dom/file/nsHostObjectProtocolHandler.cpp
@@ -464,23 +464,16 @@ public:
 
   NS_IMETHOD
   GetName(nsACString& aName) override
   {
     aName.AssignLiteral("ReleasingTimerHolder");
     return NS_OK;
   }
 
-  NS_IMETHOD
-  SetName(const char* aName) override
-  {
-    MOZ_CRASH("The name shall never be set!");
-    return NS_OK;
-  }
-
 private:
   explicit ReleasingTimerHolder(nsTArray<nsWeakPtr>&& aArray)
     : mURIs(aArray)
   {}
 
   ~ReleasingTimerHolder()
   {}
 
diff --git a/dom/flyweb/FlyWebService.cpp b/dom/flyweb/FlyWebService.cpp
--- a/dom/flyweb/FlyWebService.cpp
+++ b/dom/flyweb/FlyWebService.cpp
@@ -20,16 +20,17 @@
 #include "mozilla/dom/FlyWebDiscoveryManagerBinding.h"
 #include "prnetdb.h"
 #include "DNS.h"
 #include "nsContentPermissionHelper.h"
 #include "nsSocketTransportService2.h"
 #include "nsSocketTransport2.h"
 #include "nsHashPropertyBag.h"
 #include "nsNetUtil.h"
+#include "nsINamed.h"
 #include "nsISimpleEnumerator.h"
 #include "nsIProperty.h"
 #include "nsICertOverrideService.h"
 
 namespace mozilla {
 namespace dom {
 
 struct FlyWebPublishOptions;
@@ -154,16 +155,17 @@ NS_IMPL_ISUPPORTS(FlyWebPublishServerPer
                   nsIContentPermissionRequest,
                   nsIRunnable)
 
 class FlyWebMDNSService final
   : public nsIDNSServiceDiscoveryListener
   , public nsIDNSServiceResolveListener
   , public nsIDNSRegistrationListener
   , public nsITimerCallback
+  , public nsINamed
 {
   friend class FlyWebService;
 
 private:
   enum DiscoveryState {
     DISCOVERY_IDLE,
     DISCOVERY_STARTING,
     DISCOVERY_RUNNING,
@@ -175,16 +177,22 @@ public:
   NS_DECL_NSIDNSSERVICEDISCOVERYLISTENER
   NS_DECL_NSIDNSSERVICERESOLVELISTENER
   NS_DECL_NSIDNSREGISTRATIONLISTENER
   NS_DECL_NSITIMERCALLBACK
 
   explicit FlyWebMDNSService(FlyWebService* aService,
                              const nsACString& aServiceType);
 
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("FlyWebMDNSService");
+    return NS_OK;
+  }
+
 private:
   virtual ~FlyWebMDNSService() = default;
 
   nsresult Init();
   nsresult StartDiscovery();
   nsresult StopDiscovery();
 
   void ListDiscoveredServices(nsTArray<FlyWebDiscoveredService>& aServices);
@@ -291,17 +299,18 @@ LogDNSInfo(nsIDNSServiceInfo* aServiceIn
     LOG_I("%s: attributes end", aFunc);
   }
 }
 
 NS_IMPL_ISUPPORTS(FlyWebMDNSService,
                   nsIDNSServiceDiscoveryListener,
                   nsIDNSServiceResolveListener,
                   nsIDNSRegistrationListener,
-                  nsITimerCallback)
+                  nsITimerCallback,
+                  nsINamed)
 
 FlyWebMDNSService::FlyWebMDNSService(
         FlyWebService* aService,
         const nsACString& aServiceType)
   : mService(aService)
   , mServiceType(aServiceType)
   , mDiscoveryActive(false)
   , mNumConsecutiveStartDiscoveryFailures(0)
diff --git a/dom/geolocation/MLSFallback.cpp b/dom/geolocation/MLSFallback.cpp
--- a/dom/geolocation/MLSFallback.cpp
+++ b/dom/geolocation/MLSFallback.cpp
@@ -4,17 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "MLSFallback.h"
 #include "nsGeoPosition.h"
 #include "nsIGeolocationProvider.h"
 #include "nsServiceManagerUtils.h"
 
-NS_IMPL_ISUPPORTS(MLSFallback, nsITimerCallback)
+NS_IMPL_ISUPPORTS(MLSFallback, nsITimerCallback, nsINamed)
 
 MLSFallback::MLSFallback(uint32_t delay)
 : mDelayMs(delay)
 {
 }
 
 MLSFallback::~MLSFallback()
 {
@@ -54,16 +54,23 @@ MLSFallback::Shutdown()
 }
 
 NS_IMETHODIMP
 MLSFallback::Notify(nsITimer* aTimer)
 {
   return CreateMLSFallbackProvider();
 }
 
+NS_IMETHODIMP
+MLSFallback::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("MLSFallback");
+  return NS_OK;
+}
+
 nsresult
 MLSFallback::CreateMLSFallbackProvider()
 {
   if (mMLSFallbackProvider || !mUpdateWatcher) {
     return NS_OK;
   }
 
   nsresult rv;
diff --git a/dom/geolocation/MLSFallback.h b/dom/geolocation/MLSFallback.h
--- a/dom/geolocation/MLSFallback.h
+++ b/dom/geolocation/MLSFallback.h
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsCOMPtr.h"
 #include "nsITimer.h"
+#include "nsINamed.h"
 
 class nsIGeolocationUpdate;
 class nsIGeolocationProvider;
 
 /*
  This class wraps the NetworkGeolocationProvider in a delayed startup.
  It is for providing a fallback to MLS when:
  1) using another provider as the primary provider, and
@@ -23,20 +24,22 @@ class nsIGeolocationProvider;
 
  MLS has an average response of 3s, so with the 2s default delay, a response can
  be expected in 5s.
 
  Telemetry is recommended to monitor that the primary provider is responding
  first when expected to do so.
 */
 class MLSFallback : public nsITimerCallback
+                  , public nsINamed
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   explicit MLSFallback(uint32_t delayMs = 2000);
   nsresult Startup(nsIGeolocationUpdate* aWatcher);
   nsresult Shutdown();
 
 private:
   nsresult CreateMLSFallbackProvider();
   virtual ~MLSFallback();
diff --git a/dom/geolocation/nsGeolocation.cpp b/dom/geolocation/nsGeolocation.cpp
--- a/dom/geolocation/nsGeolocation.cpp
+++ b/dom/geolocation/nsGeolocation.cpp
@@ -16,16 +16,17 @@
 #include "mozilla/Unused.h"
 #include "mozilla/WeakPtr.h"
 #include "nsComponentManagerUtils.h"
 #include "nsContentPermissionHelper.h"
 #include "nsContentUtils.h"
 #include "nsDOMClassInfoID.h"
 #include "nsGlobalWindow.h"
 #include "nsIDocument.h"
+#include "nsINamed.h"
 #include "nsIObserverService.h"
 #include "nsIScriptError.h"
 #include "nsPIDOMWindow.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 #include "nsXULAppAPI.h"
 
 class nsIPrincipal;
@@ -91,25 +92,32 @@ class nsGeolocationRequest final
   nsIPrincipal* GetPrincipal();
 
   bool IsWatch() { return mIsWatchPositionRequest; }
   int32_t WatchId() { return mWatchId; }
  private:
   virtual ~nsGeolocationRequest();
 
   class TimerCallbackHolder final : public nsITimerCallback
+                                  , public nsINamed
   {
   public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSITIMERCALLBACK
 
     explicit TimerCallbackHolder(nsGeolocationRequest* aRequest)
       : mRequest(aRequest)
     {}
 
+    NS_IMETHOD GetName(nsACString& aName) override
+    {
+      aName.AssignLiteral("nsGeolocationRequest::TimerCallbackHolder");
+      return NS_OK;
+    }
+
   private:
     ~TimerCallbackHolder() = default;
     WeakPtr<nsGeolocationRequest> mRequest;
   };
 
   void Notify();
 
   bool mIsWatchPositionRequest;
@@ -632,17 +640,19 @@ nsGeolocationRequest::Shutdown()
   }
 }
 
 
 ////////////////////////////////////////////////////
 // nsGeolocationRequest::TimerCallbackHolder
 ////////////////////////////////////////////////////
 
-NS_IMPL_ISUPPORTS(nsGeolocationRequest::TimerCallbackHolder, nsISupports, nsITimerCallback)
+NS_IMPL_ISUPPORTS(nsGeolocationRequest::TimerCallbackHolder,
+                  nsITimerCallback,
+                  nsINamed)
 
 NS_IMETHODIMP
 nsGeolocationRequest::TimerCallbackHolder::Notify(nsITimer*)
 {
   if (mRequest && mRequest->mLocator) {
     RefPtr<nsGeolocationRequest> request(mRequest);
     request->Notify();
   }
diff --git a/dom/html/HTMLCanvasElement.cpp b/dom/html/HTMLCanvasElement.cpp
--- a/dom/html/HTMLCanvasElement.cpp
+++ b/dom/html/HTMLCanvasElement.cpp
@@ -525,19 +525,17 @@ HTMLCanvasElement::DispatchPrintCallback
     NS_ENSURE_SUCCESS(rv, rv);
   }
   mPrintState = new HTMLCanvasPrintState(this, mCurrentContext, aCallback);
 
   RefPtr<nsRunnableMethod<HTMLCanvasElement>> renderEvent =
     NewRunnableMethod("dom::HTMLCanvasElement::CallPrintCallback",
                       this,
                       &HTMLCanvasElement::CallPrintCallback);
-  return OwnerDoc()->Dispatch("HTMLCanvasElement::CallPrintCallback",
-                              TaskCategory::Other,
-                              renderEvent.forget());
+  return OwnerDoc()->Dispatch(TaskCategory::Other, renderEvent.forget());
 }
 
 void
 HTMLCanvasElement::CallPrintCallback()
 {
   ErrorResult rv;
   GetMozPrintCallback()->Call(*mPrintState, rv);
 }
@@ -847,17 +845,16 @@ HTMLCanvasElement::ToBlob(JSContext* aCx
   MOZ_ASSERT(global);
 
   nsIntSize elemSize = GetWidthHeight();
   if (elemSize.width == 0 || elemSize.height == 0) {
     // According to spec, blob should return null if either its horizontal
     // dimension or its vertical dimension is zero. See link below.
     // https://html.spec.whatwg.org/multipage/scripting.html#dom-canvas-toblob
     OwnerDoc()->Dispatch(
-      "FireNullBlobEvent",
       TaskCategory::Other,
       NewRunnableMethod<Blob*, const char*>(
         "dom::HTMLCanvasElement::ToBlob",
         &aCallback,
         static_cast<void (BlobCallback::*)(Blob*, const char*)>(
           &BlobCallback::Call),
         nullptr,
         nullptr));
diff --git a/dom/html/HTMLTrackElement.cpp b/dom/html/HTMLTrackElement.cpp
--- a/dom/html/HTMLTrackElement.cpp
+++ b/dom/html/HTMLTrackElement.cpp
@@ -440,18 +440,17 @@ HTMLTrackElement::DispatchTrackRunnable(
   if (!doc) {
     return;
   }
   nsCOMPtr<nsIRunnable> runnable = NewRunnableMethod<const nsString>(
     "dom::HTMLTrackElement::DispatchTrustedEvent",
     this,
     &HTMLTrackElement::DispatchTrustedEvent,
     aEventName);
-  doc->Dispatch("HTMLTrackElement::DispatchTrackRunnable",
-                TaskCategory::Other, runnable.forget());
+  doc->Dispatch(TaskCategory::Other, runnable.forget());
 }
 
 void
 HTMLTrackElement::DispatchTrustedEvent(const nsAString& aName)
 {
   nsIDocument* doc = OwnerDoc();
   if (!doc) {
     return;
diff --git a/dom/html/TextTrackManager.cpp b/dom/html/TextTrackManager.cpp
--- a/dom/html/TextTrackManager.cpp
+++ b/dom/html/TextTrackManager.cpp
@@ -625,17 +625,16 @@ void
 TextTrackManager::DispatchUpdateCueDisplay()
 {
   if (!mUpdateCueDisplayDispatched && !mShutdown &&
       (mMediaElement->GetHasUserInteraction() || mMediaElement->IsCurrentlyPlaying())) {
     WEBVTT_LOG("DispatchUpdateCueDisplay");
     nsPIDOMWindowInner* win = mMediaElement->OwnerDoc()->GetInnerWindow();
     if (win) {
       nsGlobalWindow::Cast(win)->Dispatch(
-        "TextTrackManager::UpdateCueDisplay",
         TaskCategory::Other,
         NewRunnableMethod("dom::TextTrackManager::UpdateCueDisplay",
                           this,
                           &TextTrackManager::UpdateCueDisplay));
       mUpdateCueDisplayDispatched = true;
     }
   }
 }
@@ -648,17 +647,16 @@ TextTrackManager::DispatchTimeMarchesOn(
   // through its usual monotonic increase during normal playback; current
   // executing call upon completion will check queue for further 'work'.
   if (!mTimeMarchesOnDispatched && !mShutdown &&
       (mMediaElement->GetHasUserInteraction() || mMediaElement->IsCurrentlyPlaying())) {
     WEBVTT_LOG("DispatchTimeMarchesOn");
     nsPIDOMWindowInner* win = mMediaElement->OwnerDoc()->GetInnerWindow();
     if (win) {
       nsGlobalWindow::Cast(win)->Dispatch(
-        "TextTrackManager::TimeMarchesOn",
         TaskCategory::Other,
         NewRunnableMethod("dom::TextTrackManager::TimeMarchesOn",
                           this,
                           &TextTrackManager::TimeMarchesOn));
       mTimeMarchesOnDispatched = true;
     }
   }
 }
diff --git a/dom/html/nsGenericHTMLElement.cpp b/dom/html/nsGenericHTMLElement.cpp
--- a/dom/html/nsGenericHTMLElement.cpp
+++ b/dom/html/nsGenericHTMLElement.cpp
@@ -482,17 +482,17 @@ nsGenericHTMLElement::BindToTree(nsIDocu
 {
   nsresult rv = nsGenericHTMLElementBase::BindToTree(aDocument, aParent,
                                                      aBindingParent,
                                                      aCompileEventHandlers);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (aDocument) {
     RegAccessKey();
-    if (HasName()) {
+    if (CanHaveName(NodeInfo()->NameAtom()) && HasName()) {
       aDocument->
         AddToNameTable(this, GetParsedAttr(nsGkAtoms::name)->GetAtomValue());
     }
 
     if (HasFlag(NODE_IS_EDITABLE) && GetContentEditableValue() == eTrue) {
       nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(aDocument);
       if (htmlDocument) {
         htmlDocument->ChangeContentEditableCount(this, +1);
@@ -771,25 +771,26 @@ nsGenericHTMLElement::AfterSetAttr(int32
       }
       ChangeEditableState(editableCountDelta);
     } else if (aName == nsGkAtoms::accesskey) {
       if (aValue && !aValue->Equals(EmptyString(), eIgnoreCase)) {
         SetFlags(NODE_HAS_ACCESSKEY);
         RegAccessKey();
       }
     } else if (aName == nsGkAtoms::name) {
-      if (aValue && !aValue->Equals(EmptyString(), eIgnoreCase) &&
-          CanHaveName(NodeInfo()->NameAtom())) {
+      if (aValue && !aValue->Equals(EmptyString(), eIgnoreCase)) {
         // This may not be quite right because we can have subclass code run
         // before here. But in practice subclasses don't care about this flag,
         // and in particular selector matching does not care.  Otherwise we'd
         // want to handle it like we handle id attributes (in PreIdMaybeChange
         // and PostIdMaybeChange).
         SetHasName();
-        AddToNameTable(aValue->GetAtomValue());
+        if (CanHaveName(NodeInfo()->NameAtom())) {
+          AddToNameTable(aValue->GetAtomValue());
+        }
       }
     }
   }
 
   return nsGenericHTMLElementBase::AfterSetAttr(aNamespaceID, aName,
                                                 aValue, aOldValue, aNotify);
 }
 
diff --git a/dom/html/nsGenericHTMLElement.h b/dom/html/nsGenericHTMLElement.h
--- a/dom/html/nsGenericHTMLElement.h
+++ b/dom/html/nsGenericHTMLElement.h
@@ -728,17 +728,17 @@ protected:
   void AddToNameTable(nsIAtom* aName) {
     NS_ASSERTION(HasName(), "Node doesn't have name?");
     nsIDocument* doc = GetUncomposedDoc();
     if (doc && !IsInAnonymousSubtree()) {
       doc->AddToNameTable(this, aName);
     }
   }
   void RemoveFromNameTable() {
-    if (HasName()) {
+    if (CanHaveName(NodeInfo()->NameAtom()) && HasName()) {
       nsIDocument* doc = GetUncomposedDoc();
       if (doc) {
         doc->RemoveFromNameTable(this, GetParsedAttr(nsGkAtoms::name)->
                                          GetAtomValue());
       }
     }
   }
 
diff --git a/dom/html/nsHTMLDocument.cpp b/dom/html/nsHTMLDocument.cpp
--- a/dom/html/nsHTMLDocument.cpp
+++ b/dom/html/nsHTMLDocument.cpp
@@ -2033,16 +2033,21 @@ nsHTMLDocument::Writeln(JSContext* cx, c
   WriteCommon(cx, aText, true, rv);
 }
 
 bool
 nsHTMLDocument::MatchNameAttribute(Element* aElement, int32_t aNamespaceID,
                                    nsIAtom* aAtom, void* aData)
 {
   NS_PRECONDITION(aElement, "Must have element to work with!");
+
+  if (!aElement->HasName()) {
+    return false;
+  }
+
   nsString* elementName = static_cast<nsString*>(aData);
   return
     aElement->GetNameSpaceID() == kNameSpaceID_XHTML &&
     aElement->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
                           *elementName, eCaseMatters);
 }
 
 /* static */
diff --git a/dom/html/nsHTMLDocument.h b/dom/html/nsHTMLDocument.h
--- a/dom/html/nsHTMLDocument.h
+++ b/dom/html/nsHTMLDocument.h
@@ -188,18 +188,21 @@ public:
   nsIHTMLCollection* Links();
   nsIHTMLCollection* Forms()
   {
     return nsHTMLDocument::GetForms();
   }
   nsIHTMLCollection* Scripts();
   already_AddRefed<nsContentList> GetElementsByName(const nsAString & aName)
   {
-    return NS_GetFuncStringNodeList(this, MatchNameAttribute, nullptr,
-                                    UseExistingNameString, aName);
+    return GetFuncStringContentList<nsCachableElementsByNameNodeList>(this,
+                                                                      MatchNameAttribute,
+                                                                      nullptr,
+                                                                      UseExistingNameString,
+                                                                      aName);
   }
   already_AddRefed<nsIDocument> Open(JSContext* cx,
                                      const nsAString& aType,
                                      const nsAString& aReplace,
                                      mozilla::ErrorResult& rv);
   already_AddRefed<nsPIDOMWindowOuter>
   Open(JSContext* cx,
        const nsAString& aURL,
diff --git a/dom/html/test/mochitest.ini b/dom/html/test/mochitest.ini
--- a/dom/html/test/mochitest.ini
+++ b/dom/html/test/mochitest.ini
@@ -606,8 +606,9 @@ skip-if = os == "android" # up/down arro
 [test_bug1295719_event_sequence_for_number_keys.html]
 [test_bug1310865.html]
 [test_bug1315146.html]
 [test_fakepath.html]
 [test_script_module.html]
 support-files =
   file_script_module.html
   file_script_nomodule.html
+[test_getElementsByName_after_mutation.html]
diff --git a/dom/html/test/test_getElementsByName_after_mutation.html b/dom/html/test/test_getElementsByName_after_mutation.html
new file mode 100644
--- /dev/null
+++ b/dom/html/test/test_getElementsByName_after_mutation.html
@@ -0,0 +1,51 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1376695
+-->
+<head>
+  <title>Test for Bug 1376695</title>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1376695">Mozilla Bug 1376695</a>
+<p id="display"></p>
+<div id="originalFoo" name="foo">
+<pre id="test">
+<script type="application/javascript">
+
+/** Test to ensure that the list returned by getElementsByName is updated after
+  * mutations.
+  **/
+
+var fooList = document.getElementsByName("foo");
+var originalDiv = document.getElementById("originalFoo");
+
+is(fooList.length, 1, "Should find one element with name 'foo' initially");
+is(fooList[0], originalDiv, "Element should be the original div");
+
+var newTree = document.createElement("p");
+var child1 = document.createElement("div");
+var child2 = document.createElement("div");
+child2.setAttribute("name", "foo");
+
+newTree.appendChild(child1);
+newTree.appendChild(child2);
+document.body.appendChild(newTree);
+
+is(fooList.length, 2,
+   "Should find two elements with name 'foo' after appending the new tree");
+is(fooList[1], child2, "Element should be the new appended div with name 'foo'");
+
+document.body.removeChild(newTree);
+
+is(fooList.length, 1,
+   "Should find one element with name 'foo' after removing the new tree");
+is(fooList[0], originalDiv,
+   "Element should be the original div after removing the new tree");
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/dom/indexedDB/ActorsParent.cpp b/dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp
+++ b/dom/indexedDB/ActorsParent.cpp
@@ -9878,25 +9878,23 @@ CheckWasmModule(FileHelper* aFileHelper,
                                                             Move(buildId),
                                                             nullptr,
                                                             0,
                                                             0);
   if (NS_WARN_IF(!module)) {
     return NS_ERROR_FAILURE;
   }
 
-  size_t compiledSize;
-  module->serializedSize(nullptr, &compiledSize);
-
+  size_t compiledSize = module->compiledSerializedSize();
   UniquePtr<uint8_t[]> compiled(new (fallible) uint8_t[compiledSize]);
   if (NS_WARN_IF(!compiled)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
-  module->serialize(nullptr, 0, compiled.get(), compiledSize);
+  module->compiledSerialize(compiled.get(), compiledSize);
 
   nsCOMPtr<nsIInputStream> inputStream;
   rv = NS_NewByteInputStream(getter_AddRefs(inputStream),
                              reinterpret_cast<const char*>(compiled.get()),
                              compiledSize);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
diff --git a/dom/indexedDB/IDBObjectStore.cpp b/dom/indexedDB/IDBObjectStore.cpp
--- a/dom/indexedDB/IDBObjectStore.cpp
+++ b/dom/indexedDB/IDBObjectStore.cpp
@@ -344,35 +344,30 @@ StructuredCloneWriteCallback(JSContext* 
       return true;
     }
   }
 
   if (JS::IsWasmModuleObject(aObj)) {
     RefPtr<JS::WasmModule> module = JS::GetWasmModule(aObj);
     MOZ_ASSERT(module);
 
-    size_t bytecodeSize;
-    size_t compiledSize;
-    module->serializedSize(&bytecodeSize, &compiledSize);
-
+    size_t bytecodeSize = module->bytecodeSerializedSize();
     UniquePtr<uint8_t[]> bytecode(new uint8_t[bytecodeSize]);
     MOZ_ASSERT(bytecode);
-
-    UniquePtr<uint8_t[]> compiled(new uint8_t[compiledSize]);
-    MOZ_ASSERT(compiled);
-
-    module->serialize(bytecode.get(),
-                      bytecodeSize,
-                      compiled.get(),
-                      compiledSize);
+    module->bytecodeSerialize(bytecode.get(), bytecodeSize);
 
     RefPtr<BlobImpl> blobImpl =
       new MemoryBlobImpl(bytecode.release(), bytecodeSize, EmptyString());
     RefPtr<Blob> bytecodeBlob = Blob::Create(nullptr, blobImpl);
 
+    size_t compiledSize = module->compiledSerializedSize();
+    UniquePtr<uint8_t[]> compiled(new uint8_t[compiledSize]);
+    MOZ_ASSERT(compiled);
+    module->compiledSerialize(compiled.get(), compiledSize);
+
     blobImpl =
       new MemoryBlobImpl(compiled.release(), compiledSize, EmptyString());
     RefPtr<Blob> compiledBlob = Blob::Create(nullptr, blobImpl);
 
     if (cloneWriteInfo->mFiles.Length() + 1 > size_t(UINT32_MAX)) {
       MOZ_ASSERT(false, "Fix the structured clone data to use a bigger type!");
       return false;
     }
diff --git a/dom/indexedDB/IndexedDatabaseManager.cpp b/dom/indexedDB/IndexedDatabaseManager.cpp
--- a/dom/indexedDB/IndexedDatabaseManager.cpp
+++ b/dom/indexedDB/IndexedDatabaseManager.cpp
@@ -1102,17 +1102,18 @@ IndexedDatabaseManager::GetLocale()
   MOZ_ASSERT(idbManager, "IDBManager is not ready!");
 
   return idbManager->mLocale;
 }
 #endif
 
 NS_IMPL_ADDREF(IndexedDatabaseManager)
 NS_IMPL_RELEASE_WITH_DESTROY(IndexedDatabaseManager, Destroy())
-NS_IMPL_QUERY_INTERFACE(IndexedDatabaseManager, nsIObserver, nsITimerCallback)
+NS_IMPL_QUERY_INTERFACE(IndexedDatabaseManager, nsIObserver, nsITimerCallback,
+                        nsINamed)
 
 NS_IMETHODIMP
 IndexedDatabaseManager::Observe(nsISupports* aSubject, const char* aTopic,
                                 const char16_t* aData)
 {
   NS_ASSERTION(IsMainProcess(), "Wrong process!");
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
 
@@ -1158,16 +1159,23 @@ IndexedDatabaseManager::Notify(nsITimer*
     runnable->Dispatch();
   }
 
   mPendingDeleteInfos.Clear();
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+IndexedDatabaseManager::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("IndexedDatabaseManager");
+  return NS_OK;
+}
+
 already_AddRefed<FileManager>
 FileManagerInfo::GetFileManager(PersistenceType aPersistenceType,
                                 const nsAString& aName) const
 {
   AssertIsOnIOThread();
 
   const nsTArray<RefPtr<FileManager> >& managers =
     GetImmutableArray(aPersistenceType);
diff --git a/dom/indexedDB/IndexedDatabaseManager.h b/dom/indexedDB/IndexedDatabaseManager.h
--- a/dom/indexedDB/IndexedDatabaseManager.h
+++ b/dom/indexedDB/IndexedDatabaseManager.h
@@ -11,16 +11,17 @@
 
 #include "js/TypeDecls.h"
 #include "mozilla/Atomics.h"
 #include "mozilla/dom/quota/PersistenceType.h"
 #include "mozilla/Mutex.h"
 #include "nsClassHashtable.h"
 #include "nsCOMPtr.h"
 #include "nsHashKeys.h"
+#include "nsINamed.h"
 #include "nsITimer.h"
 
 class nsIEventTarget;
 
 namespace mozilla {
 
 class EventChainPostVisitor;
 
@@ -40,16 +41,17 @@ class BackgroundUtilsChild;
 class FileManager;
 class FileManagerInfo;
 
 } // namespace indexedDB
 
 class IndexedDatabaseManager final
   : public nsIObserver
   , public nsITimerCallback
+  , public nsINamed
 {
   typedef mozilla::dom::quota::PersistenceType PersistenceType;
   typedef mozilla::dom::quota::QuotaManager QuotaManager;
   typedef mozilla::dom::indexedDB::FileManager FileManager;
   typedef mozilla::dom::indexedDB::FileManagerInfo FileManagerInfo;
 
 public:
   enum LoggingMode
@@ -59,16 +61,17 @@ public:
     Logging_Detailed,
     Logging_ConciseProfilerMarks,
     Logging_DetailedProfilerMarks
   };
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOBSERVER
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   // Returns a non-owning reference.
   static IndexedDatabaseManager*
   GetOrCreate();
 
   // Returns a non-owning reference.
   static IndexedDatabaseManager*
   Get();
diff --git a/dom/indexedDB/Key.cpp b/dom/indexedDB/Key.cpp
--- a/dom/indexedDB/Key.cpp
+++ b/dom/indexedDB/Key.cpp
@@ -3,21 +3,23 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 
 #include "Key.h"
 
 #include <algorithm>
+#include <stdint.h> // for UINT32_MAX, uintptr_t
 #include "IndexedDatabaseManager.h"
 #include "js/Date.h"
 #include "js/Value.h"
 #include "jsfriendapi.h"
 #include "mozilla/Casting.h"
+#include "mozilla/CheckedInt.h"
 #include "mozilla/EndianUtils.h"
 #include "mozilla/FloatingPoint.h"
 #include "mozIStorageStatement.h"
 #include "mozIStorageValueArray.h"
 #include "nsAlgorithm.h"
 #include "nsJSUtils.h"
 #include "ReportInternalError.h"
 #include "xpcpublic.h"
@@ -191,17 +193,20 @@ Key::ToLocaleBasedKey(Key& aTarget, cons
       }
     } else {
       // Decode string and reencode
       uint8_t typeOffset = *it - eString;
       MOZ_ASSERT((typeOffset % eArray == 0) && (typeOffset / eArray <= 2));
 
       nsDependentString str;
       DecodeString(it, end, str);
-      aTarget.EncodeLocaleString(str, typeOffset, aLocale);
+      nsresult rv = aTarget.EncodeLocaleString(str, typeOffset, aLocale);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
     }
   }
   aTarget.TrimBuffer();
   return NS_OK;
 }
 #endif
 
 nsresult
@@ -216,18 +221,17 @@ Key::EncodeJSValInternal(JSContext* aCx,
   }
 
   if (aVal.isString()) {
     nsAutoJSString str;
     if (!str.init(aCx, aVal)) {
       IDB_REPORT_INTERNAL_ERR();
       return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
     }
-    EncodeString(str, aTypeOffset);
-    return NS_OK;
+    return EncodeString(str, aTypeOffset);
   }
 
   if (aVal.isNumber()) {
     double d = aVal.toNumber();
     if (mozilla::IsNaN(d)) {
       return NS_ERROR_DOM_INDEXEDDB_DATA_ERR;
     }
     EncodeNumber(d, eFloat + aTypeOffset);
@@ -294,23 +298,21 @@ Key::EncodeJSValInternal(JSContext* aCx,
         IDB_REPORT_INTERNAL_ERR();
         return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
       }
       EncodeNumber(t, eDate + aTypeOffset);
       return NS_OK;
     }
 
     if (JS_IsArrayBufferObject(obj)) {
-      EncodeBinary(obj, /* aIsViewObject */ false, aTypeOffset);
-      return NS_OK;
+      return EncodeBinary(obj, /* aIsViewObject */ false, aTypeOffset);
     }
 
     if (JS_IsArrayBufferViewObject(obj)) {
-      EncodeBinary(obj, /* aIsViewObject */ true, aTypeOffset);
-      return NS_OK;
+      return EncodeBinary(obj, /* aIsViewObject */ true, aTypeOffset);
     }
   }
 
   return NS_ERROR_DOM_INDEXEDDB_DATA_ERR;
 }
 
 // static
 nsresult
@@ -410,54 +412,74 @@ Key::DecodeJSValInternal(const unsigned 
 nsresult
 Key::EncodeJSVal(JSContext* aCx,
                  JS::Handle<JS::Value> aVal,
                  uint8_t aTypeOffset)
 {
   return EncodeJSValInternal(aCx, aVal, aTypeOffset, 0);
 }
 
-void
+nsresult
 Key::EncodeString(const nsAString& aString, uint8_t aTypeOffset)
 {
   const char16_t* start = aString.BeginReading();
   const char16_t* end = aString.EndReading();
-  EncodeString(start, end, aTypeOffset);
+  return EncodeString(start, end, aTypeOffset);
+}
+
+template <typename T>
+nsresult
+Key::EncodeString(const T* aStart, const T* aEnd, uint8_t aTypeOffset)
+{
+  return EncodeAsString(aStart, aEnd, eString + aTypeOffset);
 }
 
 template <typename T>
-void
-Key::EncodeString(const T* aStart, const T* aEnd, uint8_t aTypeOffset)
-{
-  EncodeAsString(aStart, aEnd, eString + aTypeOffset);
-}
-
-template <typename T>
-void
+nsresult
 Key::EncodeAsString(const T* aStart, const T* aEnd, uint8_t aType)
 {
   // First measure how long the encoded string will be.
+  if (NS_WARN_IF(aStart > aEnd || UINT32_MAX - 2 < uintptr_t(aEnd - aStart))) {
+    IDB_REPORT_INTERNAL_ERR();
+    return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
+  }
 
   // The +2 is for initial 3 and trailing 0. We'll compensate for multi-byte
   // chars below.
-  uint32_t size = (aEnd - aStart) + 2;
+  uint32_t checkedSize = aEnd - aStart;
+  CheckedUint32 size = checkedSize;
+  size += 2;
+
+  MOZ_ASSERT(size.isValid());
 
   const T* start = aStart;
   const T* end = aEnd;
   for (const T* iter = start; iter < end; ++iter) {
     if (*iter > ONE_BYTE_LIMIT) {
       size += char16_t(*iter) > TWO_BYTE_LIMIT ? 2 : 1;
+      if (!size.isValid()) {
+        IDB_REPORT_INTERNAL_ERR();
+        return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
+      }
     }
   }
 
   // Allocate memory for the new size
   uint32_t oldLen = mBuffer.Length();
+  size += oldLen;
+
+  if (!size.isValid()) {
+    IDB_REPORT_INTERNAL_ERR();
+    return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
+  }
+
   char* buffer;
-  if (!mBuffer.GetMutableData(&buffer, oldLen + size)) {
-    return;
+  if (!mBuffer.GetMutableData(&buffer, size.value())) {
+    IDB_REPORT_INTERNAL_ERR();
+    return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
   }
   buffer += oldLen;
 
   // Write type marker
   *(buffer++) = aType;
 
   // Encode string
   for (const T* iter = start; iter < end; ++iter) {
@@ -476,16 +498,18 @@ Key::EncodeAsString(const T* aStart, con
       *(buffer++) = (char)c;
     }
   }
 
   // Write end marker
   *(buffer++) = eTerminator;
 
   NS_ASSERTION(buffer == mBuffer.EndReading(), "Wrote wrong number of bytes");
+
+  return NS_OK;
 }
 
 #ifdef ENABLE_INTL_API
 nsresult
 Key::EncodeLocaleString(const nsDependentString& aString, uint8_t aTypeOffset,
                         const nsCString& aLocale)
 {
   const int length = aString.Length();
@@ -512,20 +536,19 @@ Key::EncodeLocaleString(const nsDependen
                                     sortKeyLength);
   }
 
   ucol_close(collator);
   if (NS_WARN_IF(sortKeyLength == 0)) {
     return NS_ERROR_FAILURE;
   }
 
-  EncodeString(keyBuffer.Elements(),
-               keyBuffer.Elements()+sortKeyLength,
-               aTypeOffset);
-  return NS_OK;
+  return EncodeString(keyBuffer.Elements(),
+                      keyBuffer.Elements()+sortKeyLength,
+                      aTypeOffset);
 }
 #endif
 
 // static
 nsresult
 Key::DecodeJSVal(const unsigned char*& aPos,
                  const unsigned char* aEnd,
                  JSContext* aCx,
@@ -635,30 +658,30 @@ Key::DecodeNumber(const unsigned char*& 
   // Note: The subtraction from 0 below is necessary to fix
   // MSVC build warning C4146 (negating an unsigned value).
   const uint64_t signbit = FloatingPoint<double>::kSignBit;
   uint64_t bits = number & signbit ? (number & ~signbit) : (0 - number);
 
   return BitwiseCast<double>(bits);
 }
 
-void
+nsresult
 Key::EncodeBinary(JSObject* aObject, bool aIsViewObject, uint8_t aTypeOffset)
 {
   uint8_t* bufferData;
   uint32_t bufferLength;
   bool unused;
 
   if (aIsViewObject) {
     js::GetArrayBufferViewLengthAndData(aObject, &bufferLength, &unused, &bufferData);
   } else {
     js::GetArrayBufferLengthAndData(aObject, &bufferLength, &unused, &bufferData);
   }
 
-  EncodeAsString(bufferData, bufferData + bufferLength, eBinary + aTypeOffset);
+  return EncodeAsString(bufferData, bufferData + bufferLength, eBinary + aTypeOffset);
 }
 
 // static
 JSObject*
 Key::DecodeBinary(const unsigned char*& aPos,
                   const unsigned char* aEnd,
                   JSContext* aCx)
 {
diff --git a/dom/indexedDB/Key.h b/dom/indexedDB/Key.h
--- a/dom/indexedDB/Key.h
+++ b/dom/indexedDB/Key.h
@@ -282,37 +282,37 @@ private:
 
     mBuffer.Truncate(end + 1 - mBuffer.BeginReading());
   }
 
   // Encoding functions. These append the encoded value to the end of mBuffer
   nsresult
   EncodeJSVal(JSContext* aCx, JS::Handle<JS::Value> aVal, uint8_t aTypeOffset);
 
-  void
+  nsresult
   EncodeString(const nsAString& aString, uint8_t aTypeOffset);
 
   template <typename T>
-  void
+  nsresult
   EncodeString(const T* aStart, const T* aEnd, uint8_t aTypeOffset);
 
   template <typename T>
-  void
+  nsresult
   EncodeAsString(const T* aStart, const T* aEnd, uint8_t aType);
 
 #ifdef ENABLE_INTL_API
   nsresult
   EncodeLocaleString(const nsDependentString& aString, uint8_t aTypeOffset,
                      const nsCString& aLocale);
 #endif
 
   void
   EncodeNumber(double aFloat, uint8_t aType);
 
-  void
+  nsresult
   EncodeBinary(JSObject* aObject, bool aIsViewObject, uint8_t aTypeOffset);
 
   // Decoding functions. aPos points into mBuffer and is adjusted to point
   // past the consumed value.
   static nsresult
   DecodeJSVal(const unsigned char*& aPos,
               const unsigned char* aEnd,
               JSContext* aCx,
diff --git a/dom/indexedDB/ScriptErrorHelper.cpp b/dom/indexedDB/ScriptErrorHelper.cpp
--- a/dom/indexedDB/ScriptErrorHelper.cpp
+++ b/dom/indexedDB/ScriptErrorHelper.cpp
@@ -209,19 +209,17 @@ ScriptErrorHelper::Dump(const nsAString&
       new ScriptErrorRunnable(aMessage,
                               aFilename,
                               aLineNumber,
                               aColumnNumber,
                               aSeverityFlag,
                               aIsChrome,
                               aInnerWindowID);
     MOZ_ALWAYS_SUCCEEDS(
-      SystemGroup::Dispatch("indexedDB::ScriptErrorHelper::Dump",
-                            TaskCategory::Other,
-                            runnable.forget()));
+      SystemGroup::Dispatch(TaskCategory::Other, runnable.forget()));
   }
 }
 
 /*static*/ void
 ScriptErrorHelper::DumpLocalizedMessage(const nsACString& aMessageName,
                                         const nsAString& aFilename,
                                         uint32_t aLineNumber,
                                         uint32_t aColumnNumber,
@@ -242,17 +240,15 @@ ScriptErrorHelper::DumpLocalizedMessage(
       new ScriptErrorRunnable(aMessageName,
                               aFilename,
                               aLineNumber,
                               aColumnNumber,
                               aSeverityFlag,
                               aIsChrome,
                               aInnerWindowID);
     MOZ_ALWAYS_SUCCEEDS(
-      SystemGroup::Dispatch("indexedDB::ScriptErrorHelper::DumpLocalizedMessage",
-                            TaskCategory::Other,
-                            runnable.forget()));
+      SystemGroup::Dispatch(TaskCategory::Other, runnable.forget()));
   }
 }
 
 } // namespace indexedDB
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/interfaces/payments/nsIPaymentActionResponse.idl b/dom/interfaces/payments/nsIPaymentActionResponse.idl
--- a/dom/interfaces/payments/nsIPaymentActionResponse.idl
+++ b/dom/interfaces/payments/nsIPaymentActionResponse.idl
@@ -1,15 +1,57 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
 #include "nsIVariant.idl"
+#include "nsIPaymentAddress.idl"
+
+[builtinclass, scriptable, uuid(2a338575-c688-40ee-a157-7488ab292ef2)]
+interface nsIPaymentResponseData: nsISupports
+{
+  const uint32_t GENERAL_RESPONSE = 0;
+  const uint32_t BASICCARD_RESPONSE = 1;
+
+  readonly attribute uint32_t type;
+  void init(in uint32_t aType);
+};
+
+[builtinclass, scriptable, uuid(b986773e-2b30-4ed2-b8fe-6a96631c8000)]
+interface nsIGeneralResponseData : nsIPaymentResponseData
+{
+  readonly attribute AString data;
+
+  [implicit_jscontext]
+  void initData(in jsval aData);
+};
+
+/*
+  Since PaymentAddress is an no constructor interface type, UI code can not
+  easy create PaymentAddress by calling new PaymentAddress().
+  Unfortunately, BasicCardResponse has a PaymentAddress attribute, billingAddress
+  , it means UI can not create BsaicCardResponse by calling the init() with a
+  given JSObject directly, because PaymentAddress creation in JS code is hard.
+  To let UI code can create BasicCardResponse easier, nsIBasicCardResponse is
+  provided for UI by passing the raw data of BasicCardResponse,
+*/
+[builtinclass, scriptable, uuid(0d55a5e6-d185-44f0-b992-a8e1321e4bce)]
+interface nsIBasicCardResponseData : nsIPaymentResponseData
+{
+  readonly attribute AString data;
+
+  void initData(in AString aCardholderName,
+                in AString aCardNumber,
+                in AString aExpiryMonth,
+                in AString aExpiryYear,
+                in AString aCardSecurityCode,
+                in nsIPaymentAddress billingAddress);
+};
 
 [builtinclass, scriptable, uuid(a607c095-ef60-4a9b-a3d0-0506c60728b3)]
 interface nsIPaymentActionResponse : nsISupports
 {
   /*
    *  Align type to nsIPaymentActionRequest types,
    *  where 1 is for payment request creation.
    *  the action expects no response from UI module.
@@ -89,17 +131,17 @@ interface nsIPaymentShowActionResponse :
   readonly attribute AString payerPhone;
 
   /*
    *  Initialize function for this response.
    */
   void init(in AString aRequestId,
             in uint32_t aAcceptStatus,
             in AString aMethodName,
-            in AString aData,
+            in nsIPaymentResponseData aData,
             in AString aPayerName,
             in AString aPayerEmail,
             in AString aPayerPhone);
 
   /*
    *  Check if the payment is accpeted
    */
   bool isAccepted();
@@ -137,16 +179,26 @@ interface nsIPaymentCompleteActionRespon
 
   /*
    *  Check if the UI is finished.
    */
   bool isCompleted();
 };
 
 %{C++
+#define NS_GENERAL_RESPONSE_DATA_CID \
+  { 0xb986773e, 0x2b30, 0x4ed2, { 0xb8, 0xfe, 0x6a, 0x96, 0x63, 0x1c, 0x80, 0x00 } }
+#define NS_GENERAL_RESPONSE_DATA_CONTRACT_ID \
+  "@mozilla.org/dom/payments/general-response-data;1"
+
+#define NS_BASICCARD_RESPONSE_DATA_CID \
+  { 0x0d55a5e6, 0xd185, 0x44f0, { 0xb9, 0x92, 0xa8, 0xe1, 0x32, 0x1e, 0x4b, 0xce } }
+#define NS_BASICCARD_RESPONSE_DATA_CONTRACT_ID \
+  "@mozilla.org/dom/payments/basiccard-response-data;1"
+
 #define NS_PAYMENT_CANMAKE_ACTION_RESPONSE_CID \
   { 0x52fc3f9f, 0xc0cb, 0x4874, { 0xb3, 0xd4, 0xee, 0x4b, 0x6e, 0x9c, 0xbe, 0x9c } }
 #define NS_PAYMENT_CANMAKE_ACTION_RESPONSE_CONTRACT_ID \
   "@mozilla.org/dom/payments/payment-canmake-action-response;1"
 
 #define NS_PAYMENT_SHOW_ACTION_RESPONSE_CID \
   { 0x184385cb, 0x2d35, 0x4b99, { 0xa9, 0xa3, 0x7c, 0x78, 0x0b, 0xf6, 0x6b, 0x9b } }
 #define NS_PAYMENT_SHOW_ACTION_RESPONSE_CONTRACT_ID \
diff --git a/dom/interfaces/payments/nsIPaymentRequest.idl b/dom/interfaces/payments/nsIPaymentRequest.idl
--- a/dom/interfaces/payments/nsIPaymentRequest.idl
+++ b/dom/interfaces/payments/nsIPaymentRequest.idl
@@ -7,17 +7,18 @@
 #include "nsIVariant.idl"
 
 interface nsIArray;
 
 [scriptable, builtinclass, uuid(2fe296cc-d917-4820-b492-aa42df23f9b4)]
 interface nsIPaymentMethodData : nsISupports
 {
   readonly attribute AString supportedMethods;
-  readonly attribute AString data;
+  [implicit_jscontext]
+  readonly attribute jsval data;
 };
 
 [scriptable, builtinclass, uuid(d22a6f5f-767b-4fea-bf92-68b0b8003eba)]
 interface nsIPaymentCurrencyAmount : nsISupports
 {
   readonly attribute AString currency;
   readonly attribute AString value;
 };
@@ -31,17 +32,18 @@ interface nsIPaymentItem : nsISupports
 };
 
 [scriptable, builtinclass, uuid(74259861-c318-40e8-b3d5-518e701bed80)]
 interface nsIPaymentDetailsModifier : nsISupports
 {
   readonly attribute AString supportedMethods;
   readonly attribute nsIPaymentItem total;
   readonly attribute nsIArray additionalDisplayItems;
-  readonly attribute AString data;
+  [implicit_jscontext]
+  readonly attribute jsval data;
 };
 
 [scriptable, builtinclass, uuid(68341551-3605-4381-b936-41e830aa88fb)]
 interface nsIPaymentShippingOption : nsISupports
 {
   readonly attribute AString id;
   readonly attribute AString label;
   readonly attribute nsIPaymentCurrencyAmount amount;
diff --git a/dom/ipc/ProcessPriorityManager.cpp b/dom/ipc/ProcessPriorityManager.cpp
--- a/dom/ipc/ProcessPriorityManager.cpp
+++ b/dom/ipc/ProcessPriorityManager.cpp
@@ -13,16 +13,17 @@
 #include "mozilla/IntegerPrintfMacros.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
 #include "mozilla/Unused.h"
 #include "mozilla/Logging.h"
 #include "nsPrintfCString.h"
 #include "nsXULAppAPI.h"
 #include "nsIFrameLoader.h"
+#include "nsINamed.h"
 #include "nsIObserverService.h"
 #include "StaticPtr.h"
 #include "nsIMozBrowserFrame.h"
 #include "nsIObserver.h"
 #include "nsITimer.h"
 #include "nsIPropertyBag2.h"
 #include "nsComponentManagerUtils.h"
 #include "nsCRT.h"
@@ -221,16 +222,17 @@ private:
 /**
  * This class manages the priority of one particular process.  It is
  * main-process only.
  */
 class ParticularProcessPriorityManager final
   : public WakeLockObserver
   , public nsIObserver
   , public nsITimerCallback
+  , public nsINamed
   , public nsSupportsWeakReference
 {
   ~ParticularProcessPriorityManager();
 public:
   explicit ParticularProcessPriorityManager(ContentParent* aContentParent);
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOBSERVER
@@ -269,16 +271,22 @@ public:
   void ResetPriority();
   void ResetPriorityNow();
   void SetPriorityNow(ProcessPriority aPriority);
 
   void TabActivityChanged(TabParent* aTabParent, bool aIsActive);
 
   void ShutDown();
 
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("ParticularProcessPriorityManager");
+    return NS_OK;
+  }
+
 private:
   static uint32_t sBackgroundPerceivableGracePeriodMS;
   static uint32_t sBackgroundGracePeriodMS;
 
   void FireTestOnlyObserverNotification(
     const char* aTopic,
     const nsACString& aData = EmptyCString());
 
@@ -556,17 +564,18 @@ ProcessPriorityManagerImpl::TabActivityC
   }
 
   pppm->TabActivityChanged(aTabParent, aIsActive);
 }
 
 NS_IMPL_ISUPPORTS(ParticularProcessPriorityManager,
                   nsIObserver,
                   nsITimerCallback,
-                  nsISupportsWeakReference);
+                  nsISupportsWeakReference,
+                  nsINamed);
 
 ParticularProcessPriorityManager::ParticularProcessPriorityManager(
   ContentParent* aContentParent)
   : mContentParent(aContentParent)
   , mChildID(aContentParent->ChildID())
   , mPriority(PROCESS_PRIORITY_UNKNOWN)
   , mHoldsCPUWakeLock(false)
   , mHoldsHighPriorityWakeLock(false)
diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -3539,24 +3539,23 @@ TabChildGlobal::GetPrincipal()
 JSObject*
 TabChildGlobal::GetGlobalJSObject()
 {
   NS_ENSURE_TRUE(mTabChild, nullptr);
   return mTabChild->GetGlobal();
 }
 
 nsresult
-TabChildGlobal::Dispatch(const char* aName,
-                         TaskCategory aCategory,
+TabChildGlobal::Dispatch(TaskCategory aCategory,
                          already_AddRefed<nsIRunnable>&& aRunnable)
 {
   if (mTabChild && mTabChild->TabGroup()) {
-    return mTabChild->TabGroup()->Dispatch(aName, aCategory, Move(aRunnable));
+    return mTabChild->TabGroup()->Dispatch(aCategory, Move(aRunnable));
   }
-  return DispatcherTrait::Dispatch(aName, aCategory, Move(aRunnable));
+  return DispatcherTrait::Dispatch(aCategory, Move(aRunnable));
 }
 
 nsISerialEventTarget*
 TabChildGlobal::EventTargetFor(TaskCategory aCategory) const
 {
   if (mTabChild && mTabChild->TabGroup()) {
     return mTabChild->TabGroup()->EventTargetFor(aCategory);
   }
diff --git a/dom/ipc/TabChild.h b/dom/ipc/TabChild.h
--- a/dom/ipc/TabChild.h
+++ b/dom/ipc/TabChild.h
@@ -147,18 +147,17 @@ public:
   virtual JSObject* GetGlobalJSObject() override;
 
   virtual JSObject* WrapObject(JSContext* cx, JS::Handle<JSObject*> aGivenProto) override
   {
     MOZ_CRASH("TabChildGlobal doesn't use DOM bindings!");
   }
 
   // Dispatch a runnable related to the global.
-  virtual nsresult Dispatch(const char* aName,
-                            mozilla::TaskCategory aCategory,
+  virtual nsresult Dispatch(mozilla::TaskCategory aCategory,
                             already_AddRefed<nsIRunnable>&& aRunnable) override;
 
   virtual nsISerialEventTarget*
   EventTargetFor(mozilla::TaskCategory aCategory) const override;
 
   virtual AbstractThread*
   AbstractMainThreadFor(mozilla::TaskCategory aCategory) override;
 
diff --git a/dom/ipc/TabParent.cpp b/dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp
+++ b/dom/ipc/TabParent.cpp
@@ -168,16 +168,17 @@ TabParent::TabParent(nsIContentParent* a
 #ifdef DEBUG
   , mActiveSupressDisplayportCount(0)
 #endif
   , mLayerTreeEpoch(0)
   , mPreserveLayers(false)
   , mHasPresented(false)
   , mHasBeforeUnload(false)
   , mIsReadyToHandleInputEvents(false)
+  , mIsMouseEnterIntoWidgetEventSuppressed(false)
 {
   MOZ_ASSERT(aManager);
 }
 
 TabParent::~TabParent()
 {
 }
 
@@ -1087,17 +1088,17 @@ TabParent::SendKeyEvent(const nsAString&
   }
   Unused << PBrowserParent::SendKeyEvent(nsString(aType), aKeyCode, aCharCode,
                                          aModifiers, aPreventDefault);
 }
 
 void
 TabParent::SendRealMouseEvent(WidgetMouseEvent& aEvent)
 {
-  if (mIsDestroyed || !mIsReadyToHandleInputEvents) {
+  if (mIsDestroyed) {
     return;
   }
   aEvent.mRefPoint += GetChildProcessOffset();
 
   nsCOMPtr<nsIWidget> widget = GetWidget();
   if (widget) {
     // When we mouseenter the tab, the tab's cursor should
     // become the current cursor.  When we mouseexit, we stop.
@@ -1108,21 +1109,43 @@ TabParent::SendRealMouseEvent(WidgetMous
                           mCustomCursorHotspotX, mCustomCursorHotspotY);
       } else if (mCursor != nsCursor(-1)) {
         widget->SetCursor(mCursor);
       }
     } else if (eMouseExitFromWidget == aEvent.mMessage) {
       mTabSetsCursor = false;
     }
   }
+  if (!mIsReadyToHandleInputEvents) {
+    if (eMouseEnterIntoWidget == aEvent.mMessage) {
+      MOZ_ASSERT(!mIsMouseEnterIntoWidgetEventSuppressed);
+      mIsMouseEnterIntoWidgetEventSuppressed = true;
+    } else if (eMouseExitFromWidget == aEvent.mMessage) {
+      MOZ_ASSERT(mIsMouseEnterIntoWidgetEventSuppressed);
+      mIsMouseEnterIntoWidgetEventSuppressed = false;
+    }
+    return;
+  }
 
   ScrollableLayerGuid guid;
   uint64_t blockId;
   ApzAwareEventRoutingToChild(&guid, &blockId, nullptr);
 
+  if (mIsMouseEnterIntoWidgetEventSuppressed) {
+    // In the case that the TabParent suppressed the eMouseEnterWidget event due
+    // to its corresponding TabChild wasn't ready to handle it, we have to
+    // resend it when the TabChild is ready.
+    mIsMouseEnterIntoWidgetEventSuppressed = false;
+    WidgetMouseEvent localEvent(aEvent);
+    localEvent.mMessage = eMouseEnterIntoWidget;
+    DebugOnly<bool> ret = SendRealMouseButtonEvent(localEvent, guid, blockId);
+    NS_WARNING_ASSERTION(ret, "SendRealMouseButtonEvent(eMouseEnterIntoWidget) failed");
+    MOZ_ASSERT(!ret || localEvent.HasBeenPostedToRemoteProcess());
+  }
+
   if (eMouseMove == aEvent.mMessage) {
     if (aEvent.mReason == WidgetMouseEvent::eSynthesized) {
       DebugOnly<bool> ret = SendSynthMouseMoveEvent(aEvent, guid, blockId);
       NS_WARNING_ASSERTION(ret, "SendSynthMouseMoveEvent() failed");
       MOZ_ASSERT(!ret || aEvent.HasBeenPostedToRemoteProcess());
       return;
     }
     DebugOnly<bool> ret = SendRealMouseMoveEvent(aEvent, guid, blockId);
diff --git a/dom/ipc/TabParent.h b/dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h
+++ b/dom/ipc/TabParent.h
@@ -781,16 +781,21 @@ private:
 
   // True if at least one window hosted in the TabChild has added a
   // beforeunload event listener.
   bool mHasBeforeUnload;
 
   // True when the remote browser is created and ready to handle input events.
   bool mIsReadyToHandleInputEvents;
 
+  // True if we suppress the eMouseEnterIntoWidget event due to the TabChild was
+  // not ready to handle it. We will resend it when the next time we fire a
+  // mouse event and the TabChild is ready.
+  bool mIsMouseEnterIntoWidgetEventSuppressed;
+
 public:
   static TabParent* GetTabParentFromLayersId(uint64_t aLayersId);
 };
 
 struct MOZ_STACK_CLASS TabParent::AutoUseNewTab final
 {
 public:
   AutoUseNewTab(TabParent* aNewTab, nsCString* aURLToLoad)
diff --git a/dom/locales/en-US/chrome/dom/dom.properties b/dom/locales/en-US/chrome/dom/dom.properties
--- a/dom/locales/en-US/chrome/dom/dom.properties
+++ b/dom/locales/en-US/chrome/dom/dom.properties
@@ -182,17 +182,17 @@ UseOfDOM3LoadMethodWarning=Use of docume
 # LOCALIZATION NOTE: Do not translate "window.showModalDialog()" or "window.open()"
 ShowModalDialogWarning=Use of window.showModalDialog() is deprecated. Use window.open() instead. For more help https://developer.mozilla.org/en-US/docs/Web/API/Window.open
 # LOCALIZATION NOTE: Do not translate "window._content" or "window.content"
 Window_ContentWarning=window._content is deprecated.  Please use window.content instead.
 # LOCALIZATION NOTE: Do not translate "XMLHttpRequest"
 SyncXMLHttpRequestWarning=Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end users experience. For more help http://xhr.spec.whatwg.org/
 ImplicitMetaViewportTagFallback=No meta-viewport tag found. Please explicitly specify one to prevent unexpected behavioural changes in future versions. For more help https://developer.mozilla.org/en/docs/Mozilla/Mobile/Viewport_meta_tag
 # LOCALIZATION NOTE: Do not translate "window.controllers/Controllers"
-Window_ControllersWarning=window.controllers/Controllers is deprecated. Do not use it for UA detection.
+Window_Cc_ontrollersWarning=window.controllers/Controllers is deprecated. Do not use it for UA detection.
 ImportXULIntoContentWarning=Importing XUL nodes into a content document is deprecated. This functionality may be removed soon.
 XMLDocumentLoadPrincipalMismatch=Use of document.load forbidden on Documents that come from other Windows. Only the Window in which a Document was created is allowed to call .load on that Document. Preferably, use XMLHttpRequest instead.
 # LOCALIZATION NOTE: Do not translate "IndexedDB".
 IndexedDBTransactionAbortNavigation=An IndexedDB transaction that was not yet complete has been aborted due to page navigation.
 # LOCALIZATION NOTE: Do not translate Will-change, %1$S,%2$S are numbers.
 IgnoringWillChangeOverBudgetWarning=Will-change memory consumption is too high. Budget limit is the document surface area multiplied by %1$S (%2$S px). Occurrences of will-change over the budget will be ignored.
 # LOCALIZATION NOTE: Do not translate "Worker".
 HittingMaxWorkersPerDomain2=A Worker could not be started immediately because other documents in the same origin are already using the maximum number of workers. The Worker is now queued and will be started after some of the other workers have completed.
diff --git a/dom/media/DecoderDoctorDiagnostics.cpp b/dom/media/DecoderDoctorDiagnostics.cpp
--- a/dom/media/DecoderDoctorDiagnostics.cpp
+++ b/dom/media/DecoderDoctorDiagnostics.cpp
@@ -821,22 +821,16 @@ DecoderDoctorDocumentWatcher::Notify(nsI
 
 NS_IMETHODIMP
 DecoderDoctorDocumentWatcher::GetName(nsACString& aName)
 {
   aName.AssignASCII("DecoderDoctorDocumentWatcher_timer");
   return NS_OK;
 }
 
-NS_IMETHODIMP
-DecoderDoctorDocumentWatcher::SetName(const char* aName)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
 void
 DecoderDoctorDiagnostics::StoreFormatDiagnostics(nsIDocument* aDocument,
                                                  const nsAString& aFormat,
                                                  bool aCanPlay,
                                                  const char* aCallSite)
 {
   MOZ_ASSERT(NS_IsMainThread());
   // Make sure we only store once.
diff --git a/dom/media/FileBlockCache.cpp b/dom/media/FileBlockCache.cpp
--- a/dom/media/FileBlockCache.cpp
+++ b/dom/media/FileBlockCache.cpp
@@ -201,18 +201,17 @@ FileBlockCache::Close()
                              // nsIThread::Shutdown()
                              // can cause events to run before it completes,
                              // which could end up
                              // opening more streams, while the media cache is
                              // shutting down and
                              // releasing memory etc!
                              nsCOMPtr<nsIRunnable> event =
                                new ShutdownThreadEvent(thread);
-                             SystemGroup::Dispatch("ShutdownThreadEvent",
-                                                   TaskCategory::Other,
+                             SystemGroup::Dispatch(TaskCategory::Other,
                                                    event.forget());
                            }),
     NS_DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS_VOID(rv);
 }
 
 template<typename Container, typename Value>
 bool
diff --git a/dom/media/MediaCache.cpp b/dom/media/MediaCache.cpp
--- a/dom/media/MediaCache.cpp
+++ b/dom/media/MediaCache.cpp
@@ -1504,19 +1504,17 @@ MediaCache::QueueUpdate()
                "Queuing an update while we're in an update");
   if (mUpdateQueued)
     return;
   mUpdateQueued = true;
   // XXX MediaCache does updates when decoders are still running at
   // shutdown and get freed in the final cycle-collector cleanup.  So
   // don't leak a runnable in that case.
   nsCOMPtr<nsIRunnable> event = new UpdateEvent(this);
-  SystemGroup::Dispatch("MediaCache::UpdateEvent",
-                        TaskCategory::Other,
-                        event.forget());
+  SystemGroup::Dispatch(TaskCategory::Other, event.forget());
 }
 
 void
 MediaCache::QueueSuspendedStatusUpdate(int64_t aResourceID)
 {
   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
   if (!mSuspendedStatusToNotify.Contains(aResourceID)) {
     mSuspendedStatusToNotify.AppendElement(aResourceID);
diff --git a/dom/media/MediaDevices.cpp b/dom/media/MediaDevices.cpp
--- a/dom/media/MediaDevices.cpp
+++ b/dom/media/MediaDevices.cpp
@@ -5,46 +5,53 @@
 #include "mozilla/dom/MediaDevices.h"
 #include "mozilla/dom/MediaStreamBinding.h"
 #include "mozilla/dom/MediaDeviceInfo.h"
 #include "mozilla/dom/MediaDevicesBinding.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/MediaManager.h"
 #include "MediaTrackConstraints.h"
 #include "nsIEventTarget.h"
+#include "nsINamed.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIPermissionManager.h"
 #include "nsPIDOMWindow.h"
 #include "nsQueryObject.h"
 
 #define DEVICECHANGE_HOLD_TIME_IN_MS 1000
 
 namespace mozilla {
 namespace dom {
 
-class FuzzTimerCallBack final : public nsITimerCallback
+class FuzzTimerCallBack final : public nsITimerCallback, public nsINamed
 {
   ~FuzzTimerCallBack() {}
 
 public:
   explicit FuzzTimerCallBack(MediaDevices* aMediaDevices) : mMediaDevices(aMediaDevices) {}
 
   NS_DECL_ISUPPORTS
 
   NS_IMETHOD Notify(nsITimer* aTimer) final
   {
     mMediaDevices->DispatchTrustedEvent(NS_LITERAL_STRING("devicechange"));
     return NS_OK;
   }
 
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("FuzzTimerCallBack");
+    return NS_OK;
+  }
+
 private:
   nsCOMPtr<MediaDevices> mMediaDevices;
 };
 
-NS_IMPL_ISUPPORTS(FuzzTimerCallBack, nsITimerCallback)
+NS_IMPL_ISUPPORTS(FuzzTimerCallBack, nsITimerCallback, nsINamed)
 
 class MediaDevices::GumResolver : public nsIDOMGetUserMediaSuccessCallback
 {
 public:
   NS_DECL_ISUPPORTS
 
   explicit GumResolver(Promise* aPromise) : mPromise(aPromise) {}
 
diff --git a/dom/media/MediaFormatReader.cpp b/dom/media/MediaFormatReader.cpp
--- a/dom/media/MediaFormatReader.cpp
+++ b/dom/media/MediaFormatReader.cpp
@@ -112,17 +112,16 @@ private:
   GlobalAllocPolicy& mPolicy; // reference to a singleton object.
 };
 
 GlobalAllocPolicy::GlobalAllocPolicy()
   : mMonitor("DecoderAllocPolicy::mMonitor")
   , mDecoderLimit(MediaPrefs::MediaDecoderLimit())
 {
   SystemGroup::Dispatch(
-    "GlobalAllocPolicy::ClearOnShutdown",
     TaskCategory::Other,
     NS_NewRunnableFunction("GlobalAllocPolicy::GlobalAllocPolicy", [this]() {
       ClearOnShutdown(this, ShutdownPhase::ShutdownThreads);
     }));
 }
 
 GlobalAllocPolicy::~GlobalAllocPolicy()
 {
diff --git a/dom/media/MediaQueue.h b/dom/media/MediaQueue.h
--- a/dom/media/MediaQueue.h
+++ b/dom/media/MediaQueue.h
@@ -1,17 +1,17 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #if !defined(MediaQueue_h_)
 #define MediaQueue_h_
 
-#include "mozilla/ReentrantMonitor.h"
+#include "mozilla/RecursiveMutex.h"
 #include "mozilla/TaskQueue.h"
 
 #include "nsDeque.h"
 #include "MediaEventSource.h"
 #include "TimeUnits.h"
 
 namespace mozilla {
 
@@ -24,103 +24,103 @@ class MediaQueueDeallocator : public nsD
   }
 };
 
 template <class T>
 class MediaQueue : private nsDeque {
 public:
   MediaQueue()
     : nsDeque(new MediaQueueDeallocator<T>()),
-      mReentrantMonitor("mediaqueue"),
+      mRecursiveMutex("mediaqueue"),
       mEndOfStream(false)
   {}
 
   ~MediaQueue() {
     Reset();
   }
 
   inline size_t GetSize() const {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     return nsDeque::GetSize();
   }
 
   inline void Push(T* aItem) {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     MOZ_ASSERT(!mEndOfStream);
     MOZ_ASSERT(aItem);
     NS_ADDREF(aItem);
     MOZ_ASSERT(aItem->GetEndTime() >= aItem->mTime);
     nsDeque::Push(aItem);
     mPushEvent.Notify(RefPtr<T>(aItem));
   }
 
   inline already_AddRefed<T> PopFront() {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     RefPtr<T> rv = dont_AddRef(static_cast<T*>(nsDeque::PopFront()));
     if (rv) {
       mPopEvent.Notify(rv);
     }
     return rv.forget();
   }
 
   inline RefPtr<T> PeekFront() const {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     return static_cast<T*>(nsDeque::PeekFront());
   }
 
   void Reset() {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     while (GetSize() > 0) {
       RefPtr<T> x = dont_AddRef(static_cast<T*>(nsDeque::PopFront()));
     }
     mEndOfStream = false;
   }
 
   bool AtEndOfStream() const {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     return GetSize() == 0 && mEndOfStream;
   }
 
   // Returns true if the media queue has had its last item added to it.
   // This happens when the media stream has been completely decoded. Note this
   // does not mean that the corresponding stream has finished playback.
   bool IsFinished() const {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     return mEndOfStream;
   }
 
   // Informs the media queue that it won't be receiving any more items.
   void Finish() {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     if (!mEndOfStream) {
       mEndOfStream = true;
       mFinishEvent.Notify();
     }
   }
 
   // Returns the approximate number of microseconds of items in the queue.
   int64_t Duration() {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     if (GetSize() == 0) {
       return 0;
     }
     T* last = static_cast<T*>(nsDeque::Peek());
     T* first = static_cast<T*>(nsDeque::PeekFront());
     return (last->GetEndTime() - first->mTime).ToMicroseconds();
   }
 
   void LockedForEach(nsDequeFunctor& aFunctor) const {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     ForEach(aFunctor);
   }
 
   // Extracts elements from the queue into aResult, in order.
   // Elements whose start time is before aTime are ignored.
   void GetElementsAfter(int64_t aTime, nsTArray<RefPtr<T>>* aResult) {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     if (GetSize() == 0)
       return;
     size_t i;
     for (i = GetSize() - 1; i > 0; --i) {
       T* v = static_cast<T*>(ObjectAt(i));
       if (v->GetEndTime().ToMicroseconds() < aTime)
         break;
     }
@@ -133,24 +133,24 @@ public:
   }
 
   void GetElementsAfter(const media::TimeUnit& aTime,
                         nsTArray<RefPtr<T>>* aResult) {
     GetElementsAfter(aTime.ToMicroseconds(), aResult);
   }
 
   void GetFirstElements(uint32_t aMaxElements, nsTArray<RefPtr<T>>* aResult) {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     for (size_t i = 0; i < aMaxElements && i < GetSize(); ++i) {
       *aResult->AppendElement() = static_cast<T*>(ObjectAt(i));
     }
   }
 
   uint32_t FrameCount() {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     uint32_t frames = 0;
     for (size_t i = 0; i < GetSize(); ++i) {
       T* v = static_cast<T*>(ObjectAt(i));
       frames += v->mFrames;
     }
     return frames;
   }
 
@@ -162,17 +162,17 @@ public:
     return mPushEvent;
   }
 
   MediaEventSource<void>& FinishEvent() {
     return mFinishEvent;
   }
 
 private:
-  mutable ReentrantMonitor mReentrantMonitor;
+  mutable RecursiveMutex mRecursiveMutex;
   MediaEventProducer<RefPtr<T>> mPopEvent;
   MediaEventProducer<RefPtr<T>> mPushEvent;
   MediaEventProducer<void> mFinishEvent;
   // True when we've decoded the last frame of data in the
   // bitstream for which we're queueing frame data.
   bool mEndOfStream;
 };
 
diff --git a/dom/media/MediaResource.cpp b/dom/media/MediaResource.cpp
--- a/dom/media/MediaResource.cpp
+++ b/dom/media/MediaResource.cpp
@@ -59,17 +59,16 @@ void
 MediaResource::Destroy()
 {
   // Ensures we only delete the MediaResource on the main thread.
   if (NS_IsMainThread()) {
     delete this;
     return;
   }
   nsresult rv = SystemGroup::Dispatch(
-    "MediaResource::Destroy",
     TaskCategory::Other,
     NewNonOwningRunnableMethod(
       "MediaResource::Destroy", this, &MediaResource::Destroy));
   MOZ_ALWAYS_SUCCEEDS(rv);
 }
 
 NS_IMPL_ADDREF(MediaResource)
 NS_IMPL_RELEASE_WITH_DESTROY(MediaResource, Destroy())
diff --git a/dom/media/MediaStreamGraph.cpp b/dom/media/MediaStreamGraph.cpp
--- a/dom/media/MediaStreamGraph.cpp
+++ b/dom/media/MediaStreamGraph.cpp
@@ -1526,16 +1526,22 @@ MediaStreamGraphImpl::Notify(nsITimer* a
   MonitorAutoLock lock(mMonitor);
   NS_ASSERTION(!mForceShutdownTicket, "MediaStreamGraph took too long to shut down!");
   // Sigh, graph took too long to shut down.  Stop blocking system
   // shutdown and hope all is well.
   mForceShutdownTicket = nullptr;
   return NS_OK;
 }
 
+NS_IMETHODIMP
+MediaStreamGraphImpl::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("MediaStreamGraphImpl");
+  return NS_OK;
+}
 
 /* static */ StaticRefPtr<nsIAsyncShutdownBlocker> gMediaStreamGraphShutdownBlocker;
 
 namespace {
 
 class MediaStreamGraphShutDownRunnable : public Runnable {
 public:
   explicit MediaStreamGraphShutDownRunnable(MediaStreamGraphImpl* aGraph)
@@ -3618,17 +3624,18 @@ MediaStreamGraph::DestroyNonRealtimeInst
 
   if (!graph->mNonRealtimeProcessing) {
     // Start the graph, but don't produce anything
     graph->StartNonRealtimeProcessing(0);
   }
   graph->ForceShutDown(nullptr);
 }
 
-NS_IMPL_ISUPPORTS(MediaStreamGraphImpl, nsIMemoryReporter, nsITimerCallback)
+NS_IMPL_ISUPPORTS(MediaStreamGraphImpl, nsIMemoryReporter, nsITimerCallback,
+                  nsINamed)
 
 NS_IMETHODIMP
 MediaStreamGraphImpl::CollectReports(nsIHandleReportCallback* aHandleReport,
                                      nsISupports* aData, bool aAnonymize)
 {
   if (mLifecycleState >= LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN) {
     // Shutting down, nothing to report.
     FinishCollectReports(aHandleReport, aData, nsTArray<AudioNodeSizes>());
diff --git a/dom/media/MediaStreamGraphImpl.h b/dom/media/MediaStreamGraphImpl.h
--- a/dom/media/MediaStreamGraphImpl.h
+++ b/dom/media/MediaStreamGraphImpl.h
@@ -9,16 +9,17 @@
 #include "MediaStreamGraph.h"
 
 #include "nsDataHashtable.h"
 
 #include "nsITimer.h"
 #include "mozilla/Monitor.h"
 #include "mozilla/TimeStamp.h"
 #include "nsIMemoryReporter.h"
+#include "nsINamed.h"
 #include "nsIThread.h"
 #include "nsIRunnable.h"
 #include "nsIAsyncShutdown.h"
 #include "Latency.h"
 #include "mozilla/Services.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WeakPtr.h"
 #include "GraphDriver.h"
@@ -94,22 +95,24 @@ public:
  * be able to friend it.
  *
  * There can be multiple MediaStreamGraph per process: one per AudioChannel.
  * Additionaly, each OfflineAudioContext object creates its own MediaStreamGraph
  * object too.
  */
 class MediaStreamGraphImpl : public MediaStreamGraph,
                              public nsIMemoryReporter,
-                             public nsITimerCallback
+                             public nsITimerCallback,
+                             public nsINamed
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIMEMORYREPORTER
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   /**
    * Use aGraphDriverRequested with SYSTEM_THREAD_DRIVER or AUDIO_THREAD_DRIVER
    * to create a MediaStreamGraph which provides support for real-time audio
    * and/or video.  Set it to OFFLINE_THREAD_DRIVER in order to create a
    * non-realtime instance which just churns through its inputs and produces
    * output.  Those objects currently only support audio, and are used to
    * implement OfflineAudioContext.  They do not support MediaStream inputs.
diff --git a/dom/media/TextTrack.cpp b/dom/media/TextTrack.cpp
--- a/dom/media/TextTrack.cpp
+++ b/dom/media/TextTrack.cpp
@@ -332,17 +332,16 @@ void
 TextTrack::DispatchAsyncTrustedEvent(const nsString& aEventName)
 {
   nsPIDOMWindowInner* win = GetOwner();
   if (!win) {
     return;
   }
   RefPtr<TextTrack> self = this;
   nsGlobalWindow::Cast(win)->Dispatch(
-    "TextTrack::DispatchAsyncTrustedEvent",
     TaskCategory::Other,
     NS_NewRunnableFunction(
       "dom::TextTrack::DispatchAsyncTrustedEvent",
       [self, aEventName]() { self->DispatchTrustedEvent(aEventName); }));
 }
 
 bool
 TextTrack::IsLoaded()
diff --git a/dom/media/TextTrackList.cpp b/dom/media/TextTrackList.cpp
--- a/dom/media/TextTrackList.cpp
+++ b/dom/media/TextTrackList.cpp
@@ -188,19 +188,17 @@ TextTrackList::CreateAndDispatchChangeEv
 
     mPendingTextTrackChange = true;
     RefPtr<Event> event = NS_NewDOMEvent(this, nullptr, nullptr);
 
     event->InitEvent(NS_LITERAL_STRING("change"), false, false);
     event->SetTrusted(true);
 
     nsCOMPtr<nsIRunnable> eventRunner = new ChangeEventRunner(this, event);
-    nsGlobalWindow::Cast(win)->Dispatch(
-      "TextTrackList::CreateAndDispatchChangeEvent", TaskCategory::Other,
-      eventRunner.forget());
+    nsGlobalWindow::Cast(win)->Dispatch(TaskCategory::Other, eventRunner.forget());
   }
 }
 
 void
 TextTrackList::CreateAndDispatchTrackEventRunner(TextTrack* aTrack,
                                                  const nsAString& aEventName)
 {
   DebugOnly<nsresult> rv;
diff --git a/dom/media/VideoUtils.cpp b/dom/media/VideoUtils.cpp
--- a/dom/media/VideoUtils.cpp
+++ b/dom/media/VideoUtils.cpp
@@ -336,16 +336,23 @@ SimpleTimer::Notify(nsITimer *timer) {
   RefPtr<SimpleTimer> deathGrip(this);
   if (mTask) {
     mTask->Run();
     mTask = nullptr;
   }
   return NS_OK;
 }
 
+NS_IMETHODIMP
+SimpleTimer::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("SimpleTimer");
+  return NS_OK;
+}
+
 nsresult
 SimpleTimer::Init(nsIRunnable* aTask, uint32_t aTimeoutMs, nsIEventTarget* aTarget)
 {
   nsresult rv;
 
   // Get target thread first, so we don't have to cancel the timer if it fails.
   nsCOMPtr<nsIEventTarget> target;
   if (aTarget) {
@@ -373,17 +380,17 @@ SimpleTimer::Init(nsIRunnable* aTask, ui
     return rv;
   }
 
   mTimer = timer.forget();
   mTask = aTask;
   return NS_OK;
 }
 
-NS_IMPL_ISUPPORTS(SimpleTimer, nsITimerCallback)
+NS_IMPL_ISUPPORTS(SimpleTimer, nsITimerCallback, nsINamed)
 
 already_AddRefed<SimpleTimer>
 SimpleTimer::Create(nsIRunnable* aTask, uint32_t aTimeoutMs, nsIEventTarget* aTarget)
 {
   RefPtr<SimpleTimer> t(new SimpleTimer());
   if (NS_FAILED(t->Init(aTask, aTimeoutMs, aTarget))) {
     return nullptr;
   }
@@ -392,17 +399,17 @@ SimpleTimer::Create(nsIRunnable* aTask, 
 
 void
 LogToBrowserConsole(const nsAString& aMsg)
 {
   if (!NS_IsMainThread()) {
     nsString msg(aMsg);
     nsCOMPtr<nsIRunnable> task = NS_NewRunnableFunction(
       "LogToBrowserConsole", [msg]() { LogToBrowserConsole(msg); });
-    SystemGroup::Dispatch("LogToBrowserConsole", TaskCategory::Other, task.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, task.forget());
     return;
   }
   nsCOMPtr<nsIConsoleService> console(
     do_GetService("@mozilla.org/consoleservice;1"));
   if (!console) {
     NS_WARNING("Failed to log message to console.");
     return;
   }
diff --git a/dom/media/VideoUtils.h b/dom/media/VideoUtils.h
--- a/dom/media/VideoUtils.h
+++ b/dom/media/VideoUtils.h
@@ -15,16 +15,17 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/CheckedInt.h"
 #include "mozilla/MozPromise.h"
 #include "mozilla/ReentrantMonitor.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/UniquePtr.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
+#include "nsINamed.h"
 #include "nsIThread.h"
 #include "nsITimer.h"
 #include "nsRect.h"
 #include "nsSize.h"
 #include "nsThreadUtils.h"
 #include "prtime.h"
 
 using mozilla::CheckedInt64;
@@ -279,20 +280,21 @@ RefPtr<GenericPromise> InvokeUntil(Work 
     }
   };
 
   Helper::Iteration(p, aWork, aCondition);
   return p.forget();
 }
 
 // Simple timer to run a runnable after a timeout.
-class SimpleTimer : public nsITimerCallback
+class SimpleTimer : public nsITimerCallback, public nsINamed
 {
 public:
   NS_DECL_ISUPPORTS
+  NS_DECL_NSINAMED
 
   // Create a new timer to run aTask after aTimeoutMs milliseconds
   // on thread aTarget. If aTarget is null, task is run on the main thread.
   static already_AddRefed<SimpleTimer> Create(nsIRunnable* aTask,
                                               uint32_t aTimeoutMs,
                                               nsIEventTarget* aTarget = nullptr);
   void Cancel();
 
diff --git a/dom/media/gmp/GMPCrashHelper.cpp b/dom/media/gmp/GMPCrashHelper.cpp
--- a/dom/media/gmp/GMPCrashHelper.cpp
+++ b/dom/media/gmp/GMPCrashHelper.cpp
@@ -14,17 +14,16 @@ NS_IMPL_RELEASE_WITH_DESTROY(GMPCrashHel
 
 void
 GMPCrashHelper::Destroy()
 {
   if (NS_IsMainThread()) {
     delete this;
   } else {
     // Don't addref, as then we'd end up releasing after the detele runs!
-    SystemGroup::Dispatch("GMPCrashHelper::Destroy",
-                          TaskCategory::Other,
+    SystemGroup::Dispatch(TaskCategory::Other,
                           NewNonOwningRunnableMethod("GMPCrashHelper::Destroy",
                                                      this,
                                                      &GMPCrashHelper::Destroy));
   }
 }
 
 } // namespace mozilla
diff --git a/dom/media/gmp/GMPServiceChild.cpp b/dom/media/gmp/GMPServiceChild.cpp
--- a/dom/media/gmp/GMPServiceChild.cpp
+++ b/dom/media/gmp/GMPServiceChild.cpp
@@ -392,17 +392,17 @@ GeckoMediaPluginServiceChild::GetService
     if (!contentChild) {
       return GetServiceChildPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
     }
     MozPromiseHolder<GetServiceChildPromise>* holder = mGetServiceChildPromises.AppendElement();
     RefPtr<GetServiceChildPromise> promise = holder->Ensure(__func__);
     if (mGetServiceChildPromises.Length() == 1) {
       nsCOMPtr<nsIRunnable> r = WrapRunnable(
         contentChild, &dom::ContentChild::SendCreateGMPService);
-      SystemGroup::Dispatch("SendCreateGMPService", TaskCategory::Other, r.forget());
+      SystemGroup::Dispatch(TaskCategory::Other, r.forget());
     }
     return promise;
   }
   return GetServiceChildPromise::CreateAndResolve(mServiceChild.get(), __func__);
 }
 
 void
 GeckoMediaPluginServiceChild::SetServiceChild(UniquePtr<GMPServiceChild>&& aServiceChild)
diff --git a/dom/media/gtest/GMPTestMonitor.h b/dom/media/gtest/GMPTestMonitor.h
--- a/dom/media/gtest/GMPTestMonitor.h
+++ b/dom/media/gtest/GMPTestMonitor.h
@@ -30,17 +30,16 @@ private:
     MOZ_ASSERT(NS_IsMainThread());
     mFinished = true;
   }
 
 public:
   void SetFinished()
   {
     mozilla::SystemGroup::Dispatch(
-      "GMPTestMonitor::SetFinished",
       mozilla::TaskCategory::Other,
       mozilla::NewNonOwningRunnableMethod(
         "GMPTestMonitor::MarkFinished", this, &GMPTestMonitor::MarkFinished));
   }
 
 private:
   bool mFinished;
 };
diff --git a/dom/media/gtest/TestGMPCrossOrigin.cpp b/dom/media/gtest/TestGMPCrossOrigin.cpp
--- a/dom/media/gtest/TestGMPCrossOrigin.cpp
+++ b/dom/media/gtest/TestGMPCrossOrigin.cpp
@@ -423,17 +423,17 @@ private:
 NS_IMPL_ISUPPORTS(ClearGMPStorageTask, nsIRunnable, nsIObserver)
 
 static void
 ClearGMPStorage(already_AddRefed<nsIRunnable> aContinuation,
                 nsIThread* aTarget, PRTime aSince = -1)
 {
   RefPtr<ClearGMPStorageTask> task(
     new ClearGMPStorageTask(Move(aContinuation), aTarget, aSince));
-  SystemGroup::Dispatch("ClearGMPStorage", TaskCategory::Other, task.forget());
+  SystemGroup::Dispatch(TaskCategory::Other, task.forget());
 }
 
 static void
 SimulatePBModeExit()
 {
   // SystemGroup::EventTargetFor() doesn't support NS_DISPATCH_SYNC.
   NS_DispatchToMainThread(new NotifyObserversTask("last-pb-context-exited"), NS_DISPATCH_SYNC);
 }
@@ -794,18 +794,17 @@ class GMPStorageTest : public GMPDecrypt
 
     UniquePtr<NodeInfo> siteInfo(
         new NodeInfo(NS_LITERAL_CSTRING("http://example1.com"),
                      pattern));
     // Collect nodeIds that are expected to remain for later comparison.
     EnumerateGMPStorageDir(NS_LITERAL_CSTRING("id"),
                            NodeIdCollector(siteInfo.get()));
     // Invoke "Forget this site" on the main thread.
-    SystemGroup::Dispatch("TestForgetThisSite_Forget",
-                          TaskCategory::Other,
+    SystemGroup::Dispatch(TaskCategory::Other,
                           NewRunnableMethod<UniquePtr<NodeInfo>&&>(
                             "GMPStorageTest::TestForgetThisSite_Forget",
                             this,
                             &GMPStorageTest::TestForgetThisSite_Forget,
                             Move(siteInfo)));
   }
 
   void TestForgetThisSite_Forget(UniquePtr<NodeInfo>&& aSiteInfo) {
@@ -1214,17 +1213,17 @@ class GMPStorageTest : public GMPDecrypt
       return;
     }
     EXPECT_FALSE(mNodeId.IsEmpty());
     RefPtr<GMPShutdownObserver> task(new GMPShutdownObserver(
       NewRunnableMethod(
         "GMPStorageTest::Shutdown", this, &GMPStorageTest::Shutdown),
       Move(aContinuation),
       mNodeId));
-    SystemGroup::Dispatch("GMPShutdownObserver", TaskCategory::Other, task.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, task.forget());
   }
 
   void Shutdown() {
     if (mDecryptor) {
       mDecryptor->Close();
       mDecryptor = nullptr;
       mNodeId = EmptyCString();
     }
@@ -1233,17 +1232,17 @@ class GMPStorageTest : public GMPDecrypt
   void Dummy() {
   }
 
   void SetFinished() {
     mFinished = true;
     Shutdown();
     nsCOMPtr<nsIRunnable> task =
       NewRunnableMethod("GMPStorageTest::Dummy", this, &GMPStorageTest::Dummy);
-    SystemGroup::Dispatch("GMPStorageTest::Dummy", TaskCategory::Other, task.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, task.forget());
   }
 
   void SessionMessage(const nsCString& aSessionId,
                       mozilla::dom::MediaKeyMessageType aMessageType,
                       const nsTArray<uint8_t>& aMessage) override
   {
     MonitorAutoLock mon(mMonitor);
 
diff --git a/dom/media/imagecapture/CaptureTask.cpp b/dom/media/imagecapture/CaptureTask.cpp
--- a/dom/media/imagecapture/CaptureTask.cpp
+++ b/dom/media/imagecapture/CaptureTask.cpp
@@ -189,14 +189,12 @@ CaptureTask::PostTrackEndEvent()
     }
 
   protected:
     RefPtr<CaptureTask> mTask;
   };
 
   IC_LOG("Got MediaStream track removed or finished event.");
   nsCOMPtr<nsIRunnable> event = new TrackEndRunnable(this);
-  SystemGroup::Dispatch("CaptureTask::TaskComplete",
-                        TaskCategory::Other,
-                        event.forget());
+  SystemGroup::Dispatch(TaskCategory::Other, event.forget());
 }
 
 } // namespace mozilla
diff --git a/dom/media/mediasource/AutoTaskQueue.h b/dom/media/mediasource/AutoTaskQueue.h
--- a/dom/media/mediasource/AutoTaskQueue.h
+++ b/dom/media/mediasource/AutoTaskQueue.h
@@ -57,16 +57,16 @@ public:
 
 private:
   ~AutoTaskQueue()
   {
     RefPtr<TaskQueue> taskqueue = mTaskQueue;
     nsCOMPtr<nsIRunnable> task =
       NS_NewRunnableFunction("AutoTaskQueue::~AutoTaskQueue",
                              [taskqueue]() { taskqueue->BeginShutdown(); });
-    SystemGroup::Dispatch("~AutoTaskQueue", TaskCategory::Other, task.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, task.forget());
   }
   RefPtr<TaskQueue> mTaskQueue;
 };
 
 } // namespace mozilla
 
 #endif
diff --git a/dom/media/ogg/OggDemuxer.cpp b/dom/media/ogg/OggDemuxer.cpp
--- a/dom/media/ogg/OggDemuxer.cpp
+++ b/dom/media/ogg/OggDemuxer.cpp
@@ -137,19 +137,17 @@ OggDemuxer::~OggDemuxer()
                 ("OggDemuxer(%p)::%s: Reporting telemetry "
                  "MEDIA_OGG_LOADED_IS_CHAINED=%d",
                  ptr,
                  __func__,
                  isChained));
         Telemetry::Accumulate(
           Telemetry::HistogramID::MEDIA_OGG_LOADED_IS_CHAINED, isChained);
       });
-    SystemGroup::Dispatch("~OggDemuxer::report_telemetry",
-                          TaskCategory::Other,
-                          task.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, task.forget());
   }
 }
 
 void
 OggDemuxer::SetChainingEvents(TimedMetadataEventProducer* aMetadataEvent,
                               MediaEventProducer<void>* aOnSeekableEvent)
 {
   mTimedMetadataEvent = aMetadataEvent;
diff --git a/dom/media/platforms/wmf/WMFAudioMFTManager.cpp b/dom/media/platforms/wmf/WMFAudioMFTManager.cpp
--- a/dom/media/platforms/wmf/WMFAudioMFTManager.cpp
+++ b/dom/media/platforms/wmf/WMFAudioMFTManager.cpp
@@ -252,19 +252,17 @@ WMFAudioMFTManager::Output(int64_t aStre
 
   if (!sample) {
     LOG("Audio MFTDecoder returned success but null output.");
     nsCOMPtr<nsIRunnable> task = NS_NewRunnableFunction("WMFAudioMFTManager::Output",
                                                         []() -> void {
       LOG("Reporting telemetry AUDIO_MFT_OUTPUT_NULL_SAMPLES");
       Telemetry::Accumulate(Telemetry::HistogramID::AUDIO_MFT_OUTPUT_NULL_SAMPLES, 1);
     });
-    SystemGroup::Dispatch("WMFAudioMFTManager::Output()::report_telemetry",
-                          TaskCategory::Other,
-                          task.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, task.forget());
     return E_FAIL;
   }
 
   RefPtr<IMFMediaBuffer> buffer;
   hr = sample->ConvertToContiguousBuffer(getter_AddRefs(buffer));
   NS_ENSURE_TRUE(SUCCEEDED(hr), hr);
 
   BYTE* data = nullptr; // Note: *data will be owned by the IMFMediaBuffer, we
diff --git a/dom/media/platforms/wmf/WMFMediaDataDecoder.cpp b/dom/media/platforms/wmf/WMFMediaDataDecoder.cpp
--- a/dom/media/platforms/wmf/WMFMediaDataDecoder.cpp
+++ b/dom/media/platforms/wmf/WMFMediaDataDecoder.cpp
@@ -62,19 +62,17 @@ SendTelemetry(unsigned long hr)
   }
 
   nsCOMPtr<nsIRunnable> runnable = NS_NewRunnableFunction(
     "SendTelemetry",
     [sample] {
       Telemetry::Accumulate(Telemetry::MEDIA_WMF_DECODE_ERROR, sample);
     });
 
-  SystemGroup::Dispatch("WMFMediaDataDecoder::SendTelemetry",
-                        TaskCategory::Other,
-                        runnable.forget());
+  SystemGroup::Dispatch(TaskCategory::Other, runnable.forget());
 }
 
 RefPtr<ShutdownPromise>
 WMFMediaDataDecoder::Shutdown()
 {
   MOZ_DIAGNOSTIC_ASSERT(!mIsShutDown);
 
   mIsShutDown = true;
diff --git a/dom/media/platforms/wmf/WMFVideoMFTManager.cpp b/dom/media/platforms/wmf/WMFVideoMFTManager.cpp
--- a/dom/media/platforms/wmf/WMFVideoMFTManager.cpp
+++ b/dom/media/platforms/wmf/WMFVideoMFTManager.cpp
@@ -88,17 +88,17 @@ public:
   }
 private:
   nsAutoPtr<T> mObject;
 };
 
 template<class T>
 void DeleteOnMainThread(nsAutoPtr<T>& aObject) {
   nsCOMPtr<nsIRunnable> r = new DeleteObjectTask<T>(aObject);
-  SystemGroup::Dispatch("VideoUtils::DeleteObjectTask", TaskCategory::Other, r.forget());
+  SystemGroup::Dispatch(TaskCategory::Other, r.forget());
 }
 
 LayersBackend
 GetCompositorBackendType(layers::KnowsCompositor* aKnowsCompositor)
 {
   if (aKnowsCompositor) {
     return aKnowsCompositor->GetCompositorBackendType();
   }
@@ -155,19 +155,17 @@ WMFVideoMFTManager::~WMFVideoMFTManager(
   nsCOMPtr<nsIRunnable> task = NS_NewRunnableFunction("WMFVideoMFTManager::~WMFVideoMFTManager",
                                                       [=]() -> void {
     LOG(nsPrintfCString("Reporting telemetry VIDEO_MFT_OUTPUT_NULL_SAMPLES=%d",
                         telemetry)
         .get());
     Telemetry::Accumulate(Telemetry::HistogramID::VIDEO_MFT_OUTPUT_NULL_SAMPLES,
                           telemetry);
   });
-  SystemGroup::Dispatch("~WMFVideoMFTManager::report_telemetry",
-                        TaskCategory::Other,
-                        task.forget());
+  SystemGroup::Dispatch(TaskCategory::Other, task.forget());
 }
 
 const GUID&
 WMFVideoMFTManager::GetMFTGUID()
 {
   MOZ_ASSERT(mStreamType != Unknown);
   switch (mStreamType) {
     case H264: return CLSID_CMSH264DecoderMFT;
diff --git a/dom/media/webaudio/MediaBufferDecoder.cpp b/dom/media/webaudio/MediaBufferDecoder.cpp
--- a/dom/media/webaudio/MediaBufferDecoder.cpp
+++ b/dom/media/webaudio/MediaBufferDecoder.cpp
@@ -264,19 +264,17 @@ MediaDecodeTask::OnMetadataRead(Metadata
   nsCOMPtr<nsIRunnable> task = NS_NewRunnableFunction(
     "MediaDecodeTask::OnMetadataRead", [codec]() -> void {
       MOZ_ASSERT(!codec.IsEmpty());
       MOZ_LOG(gMediaDecoderLog,
               LogLevel::Debug,
               ("Telemetry (WebAudio) MEDIA_CODEC_USED= '%s'", codec.get()));
       Telemetry::Accumulate(Telemetry::HistogramID::MEDIA_CODEC_USED, codec);
     });
-  SystemGroup::Dispatch("MediaDecodeTask::OnMetadataRead()::report_telemetry",
-                        TaskCategory::Other,
-                        task.forget());
+  SystemGroup::Dispatch(TaskCategory::Other, task.forget());
 
   RequestSample();
 }
 
 void
 MediaDecodeTask::OnMetadataNotRead(const MediaResult& aReason)
 {
   mDecoderReader->Shutdown();
diff --git a/dom/media/webaudio/WebAudioUtils.cpp b/dom/media/webaudio/WebAudioUtils.cpp
--- a/dom/media/webaudio/WebAudioUtils.cpp
+++ b/dom/media/webaudio/WebAudioUtils.cpp
@@ -99,18 +99,17 @@ WebAudioUtils::LogToDeveloperConsole(uin
   // This implementation is derived from dom/media/VideoUtils.cpp, but we
   // use a windowID so that the message is delivered to the developer console.
   // It is similar to ContentUtils::ReportToConsole, but also works off main
   // thread.
   if (!NS_IsMainThread()) {
     nsCOMPtr<nsIRunnable> task = NS_NewRunnableFunction(
       "dom::WebAudioUtils::LogToDeveloperConsole",
       [aWindowID, aKey] { LogToDeveloperConsole(aWindowID, aKey); });
-    SystemGroup::Dispatch("dom::WebAudioUtils::LogToDeveloperConsole",
-        TaskCategory::Other, task.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, task.forget());
     return;
   }
 
   nsCOMPtr<nsIConsoleService> console(
     do_GetService("@mozilla.org/consoleservice;1"));
   if (!console) {
     NS_WARNING("Failed to log message to console.");
     return;
diff --git a/dom/media/webrtc/MediaEngineDefault.cpp b/dom/media/webrtc/MediaEngineDefault.cpp
--- a/dom/media/webrtc/MediaEngineDefault.cpp
+++ b/dom/media/webrtc/MediaEngineDefault.cpp
@@ -27,17 +27,17 @@
 #endif
 
 #define AUDIO_RATE mozilla::MediaEngine::DEFAULT_SAMPLE_RATE
 #define DEFAULT_AUDIO_TIMER_MS 10
 namespace mozilla {
 
 using namespace mozilla::gfx;
 
-NS_IMPL_ISUPPORTS(MediaEngineDefaultVideoSource, nsITimerCallback)
+NS_IMPL_ISUPPORTS(MediaEngineDefaultVideoSource, nsITimerCallback, nsINamed)
 /**
  * Default video source.
  */
 
 MediaEngineDefaultVideoSource::MediaEngineDefaultVideoSource()
 #ifdef MOZ_WEBRTC
   : MediaEngineCameraVideoSource("FakeVideo.Monitor")
 #else
@@ -281,16 +281,23 @@ MediaEngineDefaultVideoSource::Notify(ns
   MonitorAutoLock lock(mMonitor);
 
   // implicitly releases last image
   mImage = ycbcr_image.forget();
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+MediaEngineDefaultVideoSource::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("MediaEngineDefaultVideoSource");
+  return NS_OK;
+}
+
 void
 MediaEngineDefaultVideoSource::NotifyPull(MediaStreamGraph* aGraph,
                                           SourceMediaStream *aSource,
                                           TrackID aID,
                                           StreamTime aDesiredTime,
                                           const PrincipalHandle& aPrincipalHandle)
 {
   // AddTrack takes ownership of segment
diff --git a/dom/media/webrtc/MediaEngineDefault.h b/dom/media/webrtc/MediaEngineDefault.h
--- a/dom/media/webrtc/MediaEngineDefault.h
+++ b/dom/media/webrtc/MediaEngineDefault.h
@@ -1,15 +1,16 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef MEDIAENGINEDEFAULT_H_
 #define MEDIAENGINEDEFAULT_H_
 
+#include "nsINamed.h"
 #include "nsITimer.h"
 
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "DOMMediaStream.h"
 #include "nsComponentManagerUtils.h"
 #include "mozilla/Monitor.h"
 
@@ -31,16 +32,17 @@ class ImageContainer;
 } // namespace layers
 
 class MediaEngineDefault;
 
 /**
  * The default implementation of the MediaEngine interface.
  */
 class MediaEngineDefaultVideoSource : public nsITimerCallback,
+                                      public nsINamed,
 #ifdef MOZ_WEBRTC
                                       public MediaEngineCameraVideoSource
 #else
                                       public MediaEngineVideoSource
 #endif
 {
 public:
   MediaEngineDefaultVideoSource();
@@ -82,16 +84,17 @@ public:
 
   nsresult TakePhoto(MediaEnginePhotoCallback* aCallback) override
   {
     return NS_ERROR_NOT_IMPLEMENTED;
   }
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
 protected:
   ~MediaEngineDefaultVideoSource();
 
   friend class MediaEngineDefault;
 
   TrackID mTrackID;
   nsCOMPtr<nsITimer> mTimer;
diff --git a/dom/messagechannel/MessagePort.cpp b/dom/messagechannel/MessagePort.cpp
--- a/dom/messagechannel/MessagePort.cpp
+++ b/dom/messagechannel/MessagePort.cpp
@@ -557,17 +557,17 @@ MessagePort::Dispatch()
 
   RefPtr<SharedMessagePortMessage> data = mMessages.ElementAt(0);
   mMessages.RemoveElementAt(0);
 
   mPostMessageRunnable = new PostMessageRunnable(this, data);
 
   nsCOMPtr<nsIGlobalObject> global = GetOwnerGlobal();
   if (NS_IsMainThread() && global) {
-    MOZ_ALWAYS_SUCCEEDS(global->Dispatch("MessagePortMessage", TaskCategory::Other, do_AddRef(mPostMessageRunnable)));
+    MOZ_ALWAYS_SUCCEEDS(global->Dispatch(TaskCategory::Other, do_AddRef(mPostMessageRunnable)));
     return;
   }
 
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToCurrentThread(mPostMessageRunnable));
 }
 
 void
 MessagePort::Close()
diff --git a/dom/notification/Notification.cpp b/dom/notification/Notification.cpp
--- a/dom/notification/Notification.cpp
+++ b/dom/notification/Notification.cpp
@@ -221,17 +221,18 @@ public:
     rv = notificationStorage->Get(mOrigin, mTag, mCallback);
     //XXXnsm Is it guaranteed mCallback will be called in case of failure?
     Unused << NS_WARN_IF(NS_FAILED(rv));
     return rv;
   }
 };
 
 class NotificationPermissionRequest : public nsIContentPermissionRequest,
-                                      public nsIRunnable
+                                      public nsIRunnable,
+                                      public nsINamed
 {
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_NSICONTENTPERMISSIONREQUEST
   NS_DECL_NSIRUNNABLE
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(NotificationPermissionRequest,
                                            nsIContentPermissionRequest)
 
@@ -242,16 +243,22 @@ public:
       mPermission(NotificationPermission::Default),
       mPromise(aPromise),
       mCallback(aCallback)
   {
     MOZ_ASSERT(aPromise);
     mRequester = new nsContentPermissionRequester(mWindow);
   }
 
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("NotificationPermissionRequest");
+    return NS_OK;
+  }
+
 protected:
   virtual ~NotificationPermissionRequest() {}
 
   nsresult ResolvePromise();
   nsresult DispatchResolvePromise();
   nsCOMPtr<nsIPrincipal> mPrincipal;
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
   NotificationPermission mPermission;
@@ -523,16 +530,17 @@ protected:
 uint32_t Notification::sCount = 0;
 
 NS_IMPL_CYCLE_COLLECTION(NotificationPermissionRequest, mWindow, mPromise,
                                                         mCallback)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(NotificationPermissionRequest)
   NS_INTERFACE_MAP_ENTRY(nsIContentPermissionRequest)
   NS_INTERFACE_MAP_ENTRY(nsIRunnable)
+  NS_INTERFACE_MAP_ENTRY(nsINamed)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentPermissionRequest)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(NotificationPermissionRequest)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(NotificationPermissionRequest)
 
 NS_IMETHODIMP
 NotificationPermissionRequest::Run()
@@ -1792,18 +1800,17 @@ Notification::RequestPermission(const Gl
   }
   NotificationPermissionCallback* permissionCallback = nullptr;
   if (aCallback.WasPassed()) {
     permissionCallback = &aCallback.Value();
   }
   nsCOMPtr<nsIRunnable> request =
     new NotificationPermissionRequest(principal, window, promise, permissionCallback);
 
-  global->Dispatch("Notification::RequestPermission", TaskCategory::Other,
-                   request.forget());
+  global->Dispatch(TaskCategory::Other, request.forget());
 
   return promise.forget();
 }
 
 // static
 NotificationPermission
 Notification::GetPermission(const GlobalObject& aGlobal, ErrorResult& aRv)
 {
@@ -1990,18 +1997,17 @@ Notification::Get(nsPIDOMWindowInner* aW
   }
 
   nsCOMPtr<nsINotificationStorageCallback> callback =
     new NotificationStorageCallback(global, aScope, promise);
 
   RefPtr<NotificationGetRunnable> r =
     new NotificationGetRunnable(origin, aFilter.mTag, callback);
 
-  aRv = global->Dispatch("Notification::Get", TaskCategory::Other,
-                         r.forget());
+  aRv = global->Dispatch(TaskCategory::Other, r.forget());
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
diff --git a/dom/payments/BasicCardPayment.cpp b/dom/payments/BasicCardPayment.cpp
new file mode 100644
--- /dev/null
+++ b/dom/payments/BasicCardPayment.cpp
@@ -0,0 +1,390 @@
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "BasicCardPayment.h"
+#include "PaymentAddress.h"
+#include "mozilla/ClearOnShutdown.h"
+#include "nsArrayUtils.h"
+#include "nsISupportsPrimitives.h"
+#include "nsCharSeparatedTokenizer.h"
+#include "nsDataHashtable.h"
+
+namespace mozilla {
+namespace dom {
+#ifndef PaymentBasicCardMacros
+#define PaymentBasicCardMacros
+
+#define AMEX NS_LITERAL_STRING("amex")
+#define CARTEBANCAIRE NS_LITERAL_STRING("cartebancaire")
+#define DINERS NS_LITERAL_STRING("diners")
+#define DISCOVER NS_LITERAL_STRING("discover")
+#define JCB NS_LITERAL_STRING("jcb")
+#define MASTERCARD NS_LITERAL_STRING("mastercard")
+#define MIR NS_LITERAL_STRING("mir")
+#define UNIONPAY NS_LITERAL_STRING("unionpay")
+#define VISA NS_LITERAL_STRING("visa")
+
+#define CardholderName NS_LITERAL_STRING("cardholderName")
+#define CardNumber NS_LITERAL_STRING("cardNumber")
+#define ExpiryMonth NS_LITERAL_STRING("expiryMonth")
+#define ExpiryYear NS_LITERAL_STRING("expiryYear")
+#define CardSecurityCode NS_LITERAL_STRING("cardSecurityCode")
+
+#define Country NS_LITERAL_STRING("country")
+#define AddressLine NS_LITERAL_STRING("addressLine")
+#define Region NS_LITERAL_STRING("region")
+#define City NS_LITERAL_STRING("city")
+#define DependentLocality NS_LITERAL_STRING("dependentLocality")
+#define PostalCode NS_LITERAL_STRING("postalCode")
+#define SortingCode NS_LITERAL_STRING("sortingCode")
+#define LanguageCode NS_LITERAL_STRING("languageCode")
+#define Organization NS_LITERAL_STRING("organization")
+#define Recipient NS_LITERAL_STRING("recipient")
+#define Phone NS_LITERAL_STRING("phone")
+
+#define PropertySpliter NS_LITERAL_STRING(";")
+#define KeyValueSpliter NS_LITERAL_STRING(":")
+#define AddressLineSpliter NS_LITERAL_STRING("%")
+
+#define EncodeBasicCardProperty(aPropertyName, aPropertyValue, aResult)        \
+  do {                                                                         \
+    if (!(aPropertyValue).IsEmpty()) {                                         \
+      (aResult) += (aPropertyName)                                             \
+                 + KeyValueSpliter                                             \
+                 + (aPropertyValue)                                            \
+                 + PropertySpliter;                                            \
+    }                                                                          \
+  } while(0)
+
+#define EncodeAddressProperty(aAddress, aPropertyName, aResult)                \
+  do {                                                                         \
+    nsAutoString propertyValue;                                                \
+    NS_ENSURE_SUCCESS((aAddress)->Get##aPropertyName(propertyValue),           \
+                                                     NS_ERROR_FAILURE);        \
+    EncodeBasicCardProperty((aPropertyName) ,propertyValue , (aResult));       \
+  } while(0)
+
+#define DecodeBasicCardProperty(aPropertyName, aPropertyValue,                 \
+                                aMatchPropertyName, aResponse)                 \
+  do {                                                                         \
+    if ((aPropertyName).Equals((aMatchPropertyName))) {                        \
+      (aResponse).m##aMatchPropertyName.Construct();                           \
+      (aResponse).m##aMatchPropertyName.Value() = (aPropertyValue);            \
+    }                                                                          \
+  } while(0)
+
+#define DecodeAddressProperty(aPropertyName, aPropertyValue,                   \
+                              aMatchPropertyName, aMatchPropertyValue)         \
+  do {                                                                         \
+    if ((aPropertyName).Equals((aMatchPropertyName))) {                        \
+      (aMatchPropertyValue) = (aPropertyValue);                                \
+    }                                                                          \
+  } while(0)
+
+#endif
+
+namespace {
+
+bool IsValidNetwork(const nsAString& aNetwork)
+{
+  return AMEX.Equals(aNetwork) ||
+         CARTEBANCAIRE.Equals(aNetwork) ||
+         DINERS.Equals(aNetwork) ||
+         DISCOVER.Equals(aNetwork) ||
+         JCB.Equals(aNetwork) ||
+         MASTERCARD.Equals(aNetwork) ||
+         MIR.Equals(aNetwork) ||
+         UNIONPAY.Equals(aNetwork) ||
+         VISA.Equals(aNetwork);
+}
+
+bool IsBasicCardKey(const nsAString& aKey)
+{
+  return CardholderName.Equals(aKey) ||
+         CardNumber.Equals(aKey) ||
+         ExpiryMonth.Equals(aKey) ||
+         ExpiryYear.Equals(aKey) ||
+         CardSecurityCode.Equals(aKey);
+}
+
+bool IsAddressKey(const nsAString& aKey)
+{
+  return Country.Equals(aKey) ||
+         AddressLine.Equals(aKey) ||
+         Region.Equals(aKey) ||
+         City.Equals(aKey) ||
+         DependentLocality.Equals(aKey) ||
+         PostalCode.Equals(aKey) ||
+         SortingCode.Equals(aKey) ||
+         LanguageCode.Equals(aKey) ||
+         Organization.Equals(aKey) ||
+         Recipient.Equals(aKey) ||
+         Phone.Equals(aKey);
+}
+
+} // end of namespace
+
+
+StaticRefPtr<BasicCardService> gBasicCardService;
+
+already_AddRefed<BasicCardService>
+BasicCardService::GetService()
+{
+  if (!gBasicCardService) {
+    gBasicCardService = new BasicCardService();
+    ClearOnShutdown(&gBasicCardService);
+  }
+  RefPtr<BasicCardService> service = gBasicCardService;
+  return service.forget();
+}
+
+bool
+BasicCardService::IsBasicCardPayment(const nsAString& aSupportedMethods)
+{
+  return aSupportedMethods.Equals(NS_LITERAL_STRING("basic-card"));
+}
+
+bool
+BasicCardService::IsValidBasicCardRequest(JSContext* aCx,
+                                          JSObject* aData,
+                                          nsAString& aErrorMsg)
+{
+  if (!aData) {
+    return true;
+  }
+  JS::RootedValue data(aCx, JS::ObjectValue(*aData));
+
+  BasicCardRequest request;
+  if (!request.Init(aCx, data)) {
+    aErrorMsg.AssignLiteral("Fail to convert methodData.data to BasicCardRequest.");
+    return false;
+  }
+
+  if (request.mSupportedNetworks.WasPassed()) {
+    for (const nsString& network : request.mSupportedNetworks.Value()) {
+      if (!IsValidNetwork(network)) {
+        aErrorMsg.Assign(network + NS_LITERAL_STRING(" is not an valid network."));
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+bool
+BasicCardService::IsValidExpiryMonth(const nsAString& aExpiryMonth)
+{
+  // ExpiryMonth can only be
+  //   1. empty string
+  //   2. 01 ~ 12
+  if (aExpiryMonth.IsEmpty()) {
+    return true;
+  }
+  if (aExpiryMonth.Length() != 2) {
+    return false;
+  }
+  // can only be 00 ~ 09
+  if (aExpiryMonth.CharAt(0) == '0') {
+    if (aExpiryMonth.CharAt(1) < '0' || aExpiryMonth.CharAt(1) > '9') {
+      return false;
+    }
+    return true;
+  }
+  // can only be 11 or 12
+  if (aExpiryMonth.CharAt(0) == '1') {
+    if (aExpiryMonth.CharAt(1) != '1' && aExpiryMonth.CharAt(1) != '2') {
+      return false;
+    }
+    return true;
+  }
+  return false;
+}
+
+bool
+BasicCardService::IsValidExpiryYear(const nsAString& aExpiryYear)
+{
+  // ExpiryYear can only be
+  //   1. empty string
+  //   2. 0000 ~ 9999
+  if (!aExpiryYear.IsEmpty()) {
+    if (aExpiryYear.Length() != 4) {
+      return false;
+    }
+    for (uint32_t index = 0; index < 4; ++index) {
+      if (aExpiryYear.CharAt(index) < '0' ||
+          aExpiryYear.CharAt(index) > '9') {
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+nsresult
+BasicCardService::EncodeBasicCardData(const nsAString& aCardholderName,
+                                      const nsAString& aCardNumber,
+                                      const nsAString& aExpiryMonth,
+                                      const nsAString& aExpiryYear,
+                                      const nsAString& aCardSecurityCode,
+                                      nsIPaymentAddress* aBillingAddress,
+                                      nsAString& aResult)
+{
+  // aBillingAddress can be nullptr
+  if (aCardNumber.IsEmpty()) {
+    return NS_ERROR_FAILURE;
+  }
+  EncodeBasicCardProperty(CardholderName, aCardholderName, aResult);
+  EncodeBasicCardProperty(CardNumber, aCardNumber, aResult);
+  EncodeBasicCardProperty(ExpiryMonth, aExpiryMonth, aResult);
+  EncodeBasicCardProperty(ExpiryYear, aExpiryYear, aResult);
+  EncodeBasicCardProperty(CardSecurityCode, aCardSecurityCode, aResult);
+  if (!aBillingAddress) {
+    return NS_OK;
+  }
+  EncodeAddressProperty(aBillingAddress, Country, aResult);
+  nsCOMPtr<nsIArray> addressLine;
+  NS_ENSURE_SUCCESS(aBillingAddress->GetAddressLine(getter_AddRefs(addressLine)),
+                                                    NS_ERROR_FAILURE);
+  uint32_t length;
+  nsAutoString addressLineString;
+  NS_ENSURE_SUCCESS(addressLine->GetLength(&length), NS_ERROR_FAILURE);
+  for (uint32_t index = 0; index < length; ++index) {
+    nsCOMPtr<nsISupportsString> address = do_QueryElementAt(addressLine, index);
+    MOZ_ASSERT(address);
+    nsAutoString addressString;
+    NS_ENSURE_SUCCESS(address->GetData(addressString), NS_ERROR_FAILURE);
+    addressLineString += addressString + AddressLineSpliter;
+  }
+  EncodeBasicCardProperty(AddressLine ,addressLineString , aResult);
+  EncodeAddressProperty(aBillingAddress, Region, aResult);
+  EncodeAddressProperty(aBillingAddress, City, aResult);
+  EncodeAddressProperty(aBillingAddress, DependentLocality, aResult);
+  EncodeAddressProperty(aBillingAddress, PostalCode, aResult);
+  EncodeAddressProperty(aBillingAddress, SortingCode, aResult);
+  EncodeAddressProperty(aBillingAddress, LanguageCode, aResult);
+  EncodeAddressProperty(aBillingAddress, Organization, aResult);
+  EncodeAddressProperty(aBillingAddress, Recipient, aResult);
+  EncodeAddressProperty(aBillingAddress, Phone, aResult);
+  return NS_OK;
+}
+
+nsresult
+BasicCardService::DecodeBasicCardData(const nsAString& aData,
+                                      nsPIDOMWindowInner* aWindow,
+                                      BasicCardResponse& aResponse)
+{
+  // aWindow can be nullptr
+  bool isBillingAddressPassed = false;
+  nsTArray<nsString> addressLine;
+  nsAutoString country;
+  nsAutoString region;
+  nsAutoString city;
+  nsAutoString dependentLocality;
+  nsAutoString postalCode;
+  nsAutoString sortingCode;
+  nsAutoString languageCode;
+  nsAutoString organization;
+  nsAutoString recipient;
+  nsAutoString phone;
+
+  nsCharSeparatedTokenizer propertyTokenizer(aData, PropertySpliter.CharAt(0));
+  while (propertyTokenizer.hasMoreTokens()) {
+    nsDependentSubstring property = propertyTokenizer.nextToken();
+    nsCharSeparatedTokenizer keyValueTokenizer(property, KeyValueSpliter.CharAt(0));
+    MOZ_ASSERT(keyValueTokenizer.hasMoreTokens());
+    nsDependentSubstring key = keyValueTokenizer.nextToken();
+    nsDependentSubstring value = keyValueTokenizer.nextToken();
+    if (IsAddressKey(key) && !isBillingAddressPassed) {
+      isBillingAddressPassed = true;
+    }
+    if (!IsAddressKey(key) && !IsBasicCardKey(key)) {
+      return NS_ERROR_FAILURE;
+    }
+
+    if (key.Equals(CardNumber)) {
+      aResponse.mCardNumber = (value);
+    }
+
+    DecodeBasicCardProperty(key, value, CardholderName, aResponse);
+    DecodeBasicCardProperty(key, value, ExpiryMonth, aResponse);
+    DecodeBasicCardProperty(key, value, ExpiryYear, aResponse);
+    DecodeBasicCardProperty(key, value, CardSecurityCode, aResponse);
+
+    DecodeAddressProperty(key, value, Country, country);
+    DecodeAddressProperty(key, value, Region, region);
+    DecodeAddressProperty(key, value, City, city);
+    DecodeAddressProperty(key, value, DependentLocality, dependentLocality);
+    DecodeAddressProperty(key, value, PostalCode, postalCode);
+    DecodeAddressProperty(key, value, SortingCode, sortingCode);
+    DecodeAddressProperty(key, value, LanguageCode, languageCode);
+    DecodeAddressProperty(key, value, Organization, organization);
+    DecodeAddressProperty(key, value, Recipient, recipient);
+    DecodeAddressProperty(key, value, Phone, phone);
+
+    if ((key).Equals(AddressLine)) {
+      nsCharSeparatedTokenizer addressTokenizer(value, AddressLineSpliter.CharAt(0));
+      while (addressTokenizer.hasMoreTokens()) {
+        addressLine.AppendElement(addressTokenizer.nextToken());
+      }
+    }
+  }
+  if (isBillingAddressPassed) {
+    aResponse.mBillingAddress.Construct();
+    aResponse.mBillingAddress.Value() = new PaymentAddress(aWindow,
+                                                           country,
+                                                           addressLine,
+                                                           region,
+                                                           city,
+                                                           dependentLocality,
+                                                           postalCode,
+                                                           sortingCode,
+                                                           languageCode,
+                                                           organization,
+                                                           recipient,
+                                                           phone);
+  }
+  return NS_OK;
+}
+
+#ifdef PaymentBasicCardMacros
+#undef PaymentBasicCardMacros
+#undef EncodeBasicCardProperty
+#undef EncodeAddressProperty
+#undef DecodeBasicCardProperty
+#undef DecodeBasicCardCardNumber
+#undef DecodeAddressProperty
+#undef DecodeAddressLine
+#undef AMEX
+#undef CARTEBANCAIRE
+#undef DINERS
+#undef DISCOVER
+#undef JCB
+#undef MASTERCARD
+#undef MIR
+#undef UNIONPAY
+#undef VISA
+#undef CardholderName
+#undef CardNumber
+#undef ExpiryMonth
+#undef ExpiryYear
+#undef CardSecurityCode
+#undef Country
+#undef AddressLine
+#undef Region
+#undef City
+#undef DependentLocality
+#undef PostalCode
+#undef SortingCode
+#undef LanguageCode
+#undef Organization
+#undef Recipient
+#undef Phone
+#undef PropertySpliter
+#undef KeyValueSpliter
+#undef AddressLineSpliter
+#endif
+
+} // end of namespace dom
+} // end of namespace mozilla
diff --git a/dom/payments/BasicCardPayment.h b/dom/payments/BasicCardPayment.h
new file mode 100644
--- /dev/null
+++ b/dom/payments/BasicCardPayment.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BasicCardPayment_h
+#define mozilla_dom_BasicCardPayment_h
+
+#include "mozilla/dom/BasicCardPaymentBinding.h"
+#include "nsPIDOMWindow.h"
+#include "nsIPaymentAddress.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+
+class BasicCardService final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(BasicCardService)
+
+  static already_AddRefed<BasicCardService> GetService();
+
+  bool IsBasicCardPayment(const nsAString& aSupportedMethods);
+  bool IsValidBasicCardRequest(JSContext* aCx, JSObject* aData, nsAString& aErrorMsg);
+  bool IsValidExpiryMonth(const nsAString& aExpiryMonth);
+  bool IsValidExpiryYear(const nsAString& aExpiryYear);
+
+/*
+  To let BasicCardResponse using the same data type with non-BasicCard response
+  in IPC transferring, following two methods is used to Encode/Decode the raw
+  data of BasicCardResponse.
+*/
+  nsresult EncodeBasicCardData(const nsAString& aCardholderName,
+                               const nsAString& aCardNumber,
+                               const nsAString& aExpiryMonth,
+                               const nsAString& aExpiryYear,
+                               const nsAString& aCardSecurityCode,
+                               nsIPaymentAddress* aBillingAddress,
+                               nsAString& aResult);
+
+  nsresult DecodeBasicCardData(const nsAString& aData,
+                               nsPIDOMWindowInner* aWindow,
+                               BasicCardResponse& aResponse);
+private:
+  BasicCardService() = default;
+  ~BasicCardService() = default;
+};
+
+} // end of namespace dom
+} // end of namespace mozilla
+
+#endif
diff --git a/dom/payments/PaymentActionResponse.cpp b/dom/payments/PaymentActionResponse.cpp
--- a/dom/payments/PaymentActionResponse.cpp
+++ b/dom/payments/PaymentActionResponse.cpp
@@ -1,20 +1,130 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "PaymentActionResponse.h"
-#include "nsIRunnable.h"
+#include "PaymentRequestUtils.h"
+#include "BasicCardPayment.h"
 
 namespace mozilla {
 namespace dom {
 
+/* PaymentResponseData */
+
+NS_IMPL_ISUPPORTS(PaymentResponseData, nsIPaymentResponseData)
+
+NS_IMETHODIMP
+PaymentResponseData::GetType(uint32_t* aType)
+{
+  NS_ENSURE_ARG_POINTER(aType);
+  *aType = mType;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+PaymentResponseData::Init(const uint32_t aType)
+{
+  if (aType != nsIPaymentResponseData::GENERAL_RESPONSE &&
+      aType != nsIPaymentResponseData::BASICCARD_RESPONSE) {
+    return NS_ERROR_FAILURE;
+  }
+  mType = aType;
+  return NS_OK;
+}
+
+/* GeneralResponseData */
+
+NS_IMPL_ISUPPORTS_INHERITED(GeneralResponseData,
+                            PaymentResponseData,
+                            nsIGeneralResponseData)
+
+GeneralResponseData::GeneralResponseData()
+  : mData(NS_LITERAL_STRING("{}"))
+{
+  Init(nsIPaymentResponseData::GENERAL_RESPONSE);
+}
+
+NS_IMETHODIMP
+GeneralResponseData::GetData(nsAString& aData)
+{
+  aData = mData;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+GeneralResponseData::InitData(JS::HandleValue aValue, JSContext* aCx)
+{
+  if (aValue.isNullOrUndefined()) {
+    return NS_ERROR_FAILURE;
+  }
+  nsresult rv = SerializeFromJSVal(aCx, aValue, mData);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+  return NS_OK;
+}
+
+/* BasicCardResponseData */
+
+NS_IMPL_ISUPPORTS_INHERITED(BasicCardResponseData,
+                            PaymentResponseData,
+                            nsIBasicCardResponseData)
+
+BasicCardResponseData::BasicCardResponseData()
+{
+  Init(nsIPaymentResponseData::BASICCARD_RESPONSE);
+}
+
+NS_IMETHODIMP
+BasicCardResponseData::GetData(nsAString& aData)
+{
+  aData = mData;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+BasicCardResponseData::InitData(const nsAString& aCardholderName,
+                                const nsAString& aCardNumber,
+                                const nsAString& aExpiryMonth,
+                                const nsAString& aExpiryYear,
+                                const nsAString& aCardSecurityCode,
+                                nsIPaymentAddress* aBillingAddress)
+{
+  // cardNumber is a required attribute, cannot be empty;
+  if (aCardNumber.IsEmpty()) {
+    return NS_ERROR_FAILURE;
+  }
+
+  RefPtr<BasicCardService> service = BasicCardService::GetService();
+  MOZ_ASSERT(service);
+
+  if (!service->IsValidExpiryMonth(aExpiryMonth)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  if (!service->IsValidExpiryYear(aExpiryYear)) {
+    return NS_ERROR_FAILURE;
+  }
+  nsresult rv = service->EncodeBasicCardData(aCardholderName,
+                                             aCardNumber,
+                                             aExpiryMonth,
+                                             aExpiryYear,
+                                             aCardSecurityCode,
+                                             aBillingAddress,
+                                             mData);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+  return NS_OK;
+}
+
 /* PaymentActionResponse */
 
 NS_IMPL_ISUPPORTS(PaymentActionResponse,
                   nsIPaymentActionResponse)
 
 PaymentActionResponse::PaymentActionResponse()
   : mRequestId(EmptyString())
   , mType(nsIPaymentActionResponse::NO_TYPE)
@@ -116,25 +226,59 @@ PaymentShowActionResponse::GetPayerPhone
   aPayerPhone = mPayerPhone;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 PaymentShowActionResponse::Init(const nsAString& aRequestId,
                                 const uint32_t aAcceptStatus,
                                 const nsAString& aMethodName,
-                                const nsAString& aData,
+                                nsIPaymentResponseData* aData,
                                 const nsAString& aPayerName,
                                 const nsAString& aPayerEmail,
                                 const nsAString& aPayerPhone)
 {
+  NS_ENSURE_ARG_POINTER(aData);
   mRequestId = aRequestId;
   mAcceptStatus = aAcceptStatus;
   mMethodName = aMethodName;
-  mData = aData;
+
+  RefPtr<BasicCardService> service = BasicCardService::GetService();
+  MOZ_ASSERT(service);
+  bool isBasicCardPayment = service->IsBasicCardPayment(mMethodName);
+
+  uint32_t responseType;
+  NS_ENSURE_SUCCESS(aData->GetType(&responseType), NS_ERROR_FAILURE);
+  switch (responseType) {
+    case nsIPaymentResponseData::GENERAL_RESPONSE: {
+      if (isBasicCardPayment) {
+        return NS_ERROR_FAILURE;
+      }
+      nsCOMPtr<nsIGeneralResponseData> data = do_QueryInterface(aData);
+      MOZ_ASSERT(data);
+      NS_ENSURE_SUCCESS(data->GetData(mData), NS_ERROR_FAILURE);
+      break;
+    }
+    case nsIPaymentResponseData::BASICCARD_RESPONSE: {
+      if (!isBasicCardPayment) {
+        return NS_ERROR_FAILURE;
+      }
+      nsCOMPtr<nsIBasicCardResponseData> data = do_QueryInterface(aData);
+      MOZ_ASSERT(data);
+      NS_ENSURE_SUCCESS(data->GetData(mData), NS_ERROR_FAILURE);
+      break;
+    }
+    default: {
+      return NS_ERROR_FAILURE;
+    }
+  }
+  if (mData.IsEmpty()) {
+    return NS_ERROR_FAILURE;
+  }
+
   mPayerName = aPayerName;
   mPayerEmail = aPayerEmail;
   mPayerPhone = aPayerPhone;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 PaymentShowActionResponse::IsAccepted(bool* aIsAccepted)
diff --git a/dom/payments/PaymentActionResponse.h b/dom/payments/PaymentActionResponse.h
--- a/dom/payments/PaymentActionResponse.h
+++ b/dom/payments/PaymentActionResponse.h
@@ -9,16 +9,63 @@
 
 #include "nsIPaymentActionResponse.h"
 
 namespace mozilla {
 namespace dom {
 
 class PaymentRequestParent;
 
+class PaymentResponseData : public nsIPaymentResponseData
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIPAYMENTRESPONSEDATA
+
+  PaymentResponseData() = default;
+
+protected:
+  virtual ~PaymentResponseData() = default;
+
+  uint32_t mType;
+};
+
+class GeneralResponseData final : public PaymentResponseData
+                                , public nsIGeneralResponseData
+{
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_FORWARD_NSIPAYMENTRESPONSEDATA(PaymentResponseData::)
+  NS_DECL_NSIGENERALRESPONSEDATA
+
+  GeneralResponseData();
+
+private:
+  ~GeneralResponseData() = default;
+
+  nsString mData;
+};
+
+class BasicCardResponseData final : public nsIBasicCardResponseData
+                                  , public PaymentResponseData
+{
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_FORWARD_NSIPAYMENTRESPONSEDATA(PaymentResponseData::)
+  NS_DECL_NSIBASICCARDRESPONSEDATA
+
+  BasicCardResponseData();
+
+private:
+  ~BasicCardResponseData() = default;
+
+  nsString mData;
+  nsCOMPtr<nsIPaymentAddress> mBillingAddress;
+};
+
 class PaymentActionResponse : public nsIPaymentActionResponse
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIPAYMENTACTIONRESPONSE
 
   PaymentActionResponse();
 
diff --git a/dom/payments/PaymentRequest.cpp b/dom/payments/PaymentRequest.cpp
--- a/dom/payments/PaymentRequest.cpp
+++ b/dom/payments/PaymentRequest.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/PaymentRequest.h"
 #include "mozilla/dom/PaymentResponse.h"
 #include "nsContentUtils.h"
+#include "BasicCardPayment.h"
 #include "PaymentRequestManager.h"
 
 namespace mozilla {
 namespace dom {
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(PaymentRequest)
 
 NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(PaymentRequest,
@@ -47,30 +48,44 @@ NS_IMPL_RELEASE_INHERITED(PaymentRequest
 
 bool
 PaymentRequest::PrefEnabled(JSContext* aCx, JSObject* aObj)
 {
   return Preferences::GetBool("dom.payments.request.enabled");
 }
 
 bool
-PaymentRequest::IsValidMethodData(const Sequence<PaymentMethodData>& aMethodData,
+PaymentRequest::IsValidMethodData(JSContext* aCx,
+                                  const Sequence<PaymentMethodData>& aMethodData,
                                   nsAString& aErrorMsg)
 {
   if (!aMethodData.Length()) {
     aErrorMsg.AssignLiteral("At least one payment method is required.");
     return false;
   }
 
   for (const PaymentMethodData& methodData : aMethodData) {
-    if (!methodData.mSupportedMethods.Length()) {
+    if (methodData.mSupportedMethods.IsEmpty()) {
       aErrorMsg.AssignLiteral(
-        "At least one payment method identifier is required.");
+        "Payment method identifier is required.");
       return false;
     }
+    RefPtr<BasicCardService> service = BasicCardService::GetService();
+    MOZ_ASSERT(service);
+    if (service->IsBasicCardPayment(methodData.mSupportedMethods)) {
+      if (!methodData.mData.WasPassed()) {
+        continue;
+      }
+      MOZ_ASSERT(aCx);
+      if (!service->IsValidBasicCardRequest(aCx,
+                                            methodData.mData.Value(),
+                                            aErrorMsg)) {
+        return false;
+      }
+    }
   }
 
   return true;
 }
 
 bool
 PaymentRequest::IsValidNumber(const nsAString& aItem,
                               const nsAString& aStr,
@@ -254,17 +269,19 @@ PaymentRequest::Constructor(const Global
         }
       }
     }
     node = parentNode;
   } while (node);
 
   // Check payment methods and details
   nsAutoString message;
-  if (!IsValidMethodData(aMethodData, message) ||
+  if (!IsValidMethodData(nsContentUtils::GetCurrentJSContext(),
+                         aMethodData,
+                         message) ||
       !IsValidDetailsInit(aDetails, message)) {
     aRv.ThrowTypeError<MSG_ILLEGAL_PR_CONSTRUCTOR>(message);
     return nullptr;
   }
 
   RefPtr<PaymentRequestManager> manager = PaymentRequestManager::GetSingleton();
   if (NS_WARN_IF(!manager)) {
     return nullptr;
diff --git a/dom/payments/PaymentRequest.h b/dom/payments/PaymentRequest.h
--- a/dom/payments/PaymentRequest.h
+++ b/dom/payments/PaymentRequest.h
@@ -31,17 +31,18 @@ public:
   virtual JSObject* WrapObject(JSContext* aCx,
                                JS::Handle<JSObject*> aGivenProto) override;
 
   static already_AddRefed<PaymentRequest>
   CreatePaymentRequest(nsPIDOMWindowInner* aWindow, nsresult& aRv);
 
   static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
 
-  static bool IsValidMethodData(const Sequence<PaymentMethodData>& aMethodData,
+  static bool IsValidMethodData(JSContext* aCx,
+                                const Sequence<PaymentMethodData>& aMethodData,
                                 nsAString& aErrorMsg);
 
   static bool
   IsValidNumber(const nsAString& aItem,
                 const nsAString& aStr,
                 nsAString& aErrorMsg);
   static bool
   IsNonNegativeNumber(const nsAString& aItem,
diff --git a/dom/payments/PaymentRequestData.cpp b/dom/payments/PaymentRequestData.cpp
--- a/dom/payments/PaymentRequestData.cpp
+++ b/dom/payments/PaymentRequestData.cpp
@@ -39,19 +39,26 @@ PaymentMethodData::Create(const IPCPayme
 NS_IMETHODIMP
 PaymentMethodData::GetSupportedMethods(nsAString& aSupportedMethods)
 {
   aSupportedMethods = mSupportedMethods;
   return NS_OK;
 }
 
 NS_IMETHODIMP
-PaymentMethodData::GetData(nsAString& aData)
+PaymentMethodData::GetData(JSContext* aCx, JS::MutableHandleValue aData)
 {
-  aData = mData;
+  if (mData.IsEmpty()) {
+    aData.set(JS::NullValue());
+    return NS_OK;
+  }
+  nsresult rv = DeserializeToJSValue(mData, aCx ,aData);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
   return NS_OK;
 }
 
 /* PaymentCurrencyAmount */
 
 NS_IMPL_ISUPPORTS(PaymentCurrencyAmount,
                   nsIPaymentCurrencyAmount)
 
@@ -217,19 +224,26 @@ PaymentDetailsModifier::GetAdditionalDis
 {
   NS_ENSURE_ARG_POINTER(aAdditionalDisplayItems);
   nsCOMPtr<nsIArray> additionalItems = mAdditionalDisplayItems;
   additionalItems.forget(aAdditionalDisplayItems);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-PaymentDetailsModifier::GetData(nsAString& aData)
+PaymentDetailsModifier::GetData(JSContext* aCx, JS::MutableHandleValue aData)
 {
-  aData = mData;
+  if (mData.IsEmpty()) {
+    aData.set(JS::NullValue());
+    return NS_OK;
+  }
+  nsresult rv = DeserializeToJSValue(mData, aCx ,aData);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
   return NS_OK;
 }
 
 /* PaymentShippingOption */
 
 NS_IMPL_ISUPPORTS(PaymentShippingOption,
                   nsIPaymentShippingOption)
 
diff --git a/dom/payments/PaymentRequestModule.cpp b/dom/payments/PaymentRequestModule.cpp
--- a/dom/payments/PaymentRequestModule.cpp
+++ b/dom/payments/PaymentRequestModule.cpp
@@ -5,79 +5,91 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/ModuleUtils.h"
 #include "PaymentActionRequest.h"
 #include "PaymentActionResponse.h"
 #include "PaymentRequestData.h"
 #include "PaymentRequestService.h"
 
+using mozilla::dom::GeneralResponseData;
+using mozilla::dom::BasicCardResponseData;
 using mozilla::dom::PaymentActionRequest;
 using mozilla::dom::PaymentCreateActionRequest;
 using mozilla::dom::PaymentCompleteActionRequest;
 using mozilla::dom::PaymentUpdateActionRequest;
 using mozilla::dom::PaymentCanMakeActionResponse;
 using mozilla::dom::PaymentAbortActionResponse;
 using mozilla::dom::PaymentShowActionResponse;
 using mozilla::dom::PaymentCompleteActionResponse;
 using mozilla::dom::payments::PaymentAddress;
 using mozilla::dom::PaymentRequestService;
 
+NS_GENERIC_FACTORY_CONSTRUCTOR(GeneralResponseData)
+NS_GENERIC_FACTORY_CONSTRUCTOR(BasicCardResponseData)
 NS_GENERIC_FACTORY_CONSTRUCTOR(PaymentActionRequest)
 NS_GENERIC_FACTORY_CONSTRUCTOR(PaymentCreateActionRequest)
 NS_GENERIC_FACTORY_CONSTRUCTOR(PaymentCompleteActionRequest)
 NS_GENERIC_FACTORY_CONSTRUCTOR(PaymentUpdateActionRequest)
 NS_GENERIC_FACTORY_CONSTRUCTOR(PaymentCanMakeActionResponse)
 NS_GENERIC_FACTORY_CONSTRUCTOR(PaymentAbortActionResponse)
 NS_GENERIC_FACTORY_CONSTRUCTOR(PaymentShowActionResponse)
 NS_GENERIC_FACTORY_CONSTRUCTOR(PaymentCompleteActionResponse)
 NS_GENERIC_FACTORY_CONSTRUCTOR(PaymentAddress)
 NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(PaymentRequestService,
                                          PaymentRequestService::GetSingleton)
 
+NS_DEFINE_NAMED_CID(NS_GENERAL_RESPONSE_DATA_CID);
+NS_DEFINE_NAMED_CID(NS_BASICCARD_RESPONSE_DATA_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_ACTION_REQUEST_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_CREATE_ACTION_REQUEST_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_COMPLETE_ACTION_REQUEST_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_UPDATE_ACTION_REQUEST_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_CANMAKE_ACTION_RESPONSE_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_ABORT_ACTION_RESPONSE_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_SHOW_ACTION_RESPONSE_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_COMPLETE_ACTION_RESPONSE_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_ADDRESS_CID);
 NS_DEFINE_NAMED_CID(NS_PAYMENT_REQUEST_SERVICE_CID);
 
 static const mozilla::Module::CIDEntry kPaymentRequestCIDs[] = {
+  { &kNS_GENERAL_RESPONSE_DATA_CID, false, nullptr, GeneralResponseDataConstructor},
+  { &kNS_BASICCARD_RESPONSE_DATA_CID, false, nullptr, BasicCardResponseDataConstructor},
   { &kNS_PAYMENT_ACTION_REQUEST_CID, false, nullptr, PaymentActionRequestConstructor},
   { &kNS_PAYMENT_CREATE_ACTION_REQUEST_CID, false, nullptr, PaymentCreateActionRequestConstructor},
   { &kNS_PAYMENT_COMPLETE_ACTION_REQUEST_CID, false, nullptr, PaymentCompleteActionRequestConstructor},
   { &kNS_PAYMENT_UPDATE_ACTION_REQUEST_CID, false, nullptr, PaymentUpdateActionRequestConstructor},
   { &kNS_PAYMENT_CANMAKE_ACTION_RESPONSE_CID, false, nullptr, PaymentCanMakeActionResponseConstructor},
   { &kNS_PAYMENT_ABORT_ACTION_RESPONSE_CID, false, nullptr, PaymentAbortActionResponseConstructor},
   { &kNS_PAYMENT_SHOW_ACTION_RESPONSE_CID, false, nullptr, PaymentShowActionResponseConstructor},
   { &kNS_PAYMENT_COMPLETE_ACTION_RESPONSE_CID, false, nullptr, PaymentCompleteActionResponseConstructor},
   { &kNS_PAYMENT_ADDRESS_CID, false, nullptr, PaymentAddressConstructor},
   { &kNS_PAYMENT_REQUEST_SERVICE_CID, true, nullptr, PaymentRequestServiceConstructor },
   { nullptr }
 };
 
 static const mozilla::Module::ContractIDEntry kPaymentRequestContracts[] = {
+  { NS_GENERAL_RESPONSE_DATA_CONTRACT_ID, &kNS_GENERAL_RESPONSE_DATA_CID },
+  { NS_BASICCARD_RESPONSE_DATA_CONTRACT_ID, &kNS_BASICCARD_RESPONSE_DATA_CID },
   { NS_PAYMENT_ACTION_REQUEST_CONTRACT_ID, &kNS_PAYMENT_ACTION_REQUEST_CID },
   { NS_PAYMENT_CREATE_ACTION_REQUEST_CONTRACT_ID, &kNS_PAYMENT_CREATE_ACTION_REQUEST_CID },
   { NS_PAYMENT_COMPLETE_ACTION_REQUEST_CONTRACT_ID, &kNS_PAYMENT_COMPLETE_ACTION_REQUEST_CID },
   { NS_PAYMENT_UPDATE_ACTION_REQUEST_CONTRACT_ID, &kNS_PAYMENT_UPDATE_ACTION_REQUEST_CID },
   { NS_PAYMENT_CANMAKE_ACTION_RESPONSE_CONTRACT_ID, &kNS_PAYMENT_CANMAKE_ACTION_RESPONSE_CID },
   { NS_PAYMENT_ABORT_ACTION_RESPONSE_CONTRACT_ID, &kNS_PAYMENT_ABORT_ACTION_RESPONSE_CID },
   { NS_PAYMENT_SHOW_ACTION_RESPONSE_CONTRACT_ID, &kNS_PAYMENT_SHOW_ACTION_RESPONSE_CID },
   { NS_PAYMENT_COMPLETE_ACTION_RESPONSE_CONTRACT_ID, &kNS_PAYMENT_COMPLETE_ACTION_RESPONSE_CID },
   { NS_PAYMENT_ADDRESS_CONTRACT_ID, &kNS_PAYMENT_ADDRESS_CID },
   { NS_PAYMENT_REQUEST_SERVICE_CONTRACT_ID, &kNS_PAYMENT_REQUEST_SERVICE_CID },
   { nullptr }
 };
 
 static const mozilla::Module::CategoryEntry kPaymentRequestCategories[] = {
+  { "payment-request", "GeneralResponseData", NS_GENERAL_RESPONSE_DATA_CONTRACT_ID },
+  { "payment-request", "BasicCardResponseData", NS_BASICCARD_RESPONSE_DATA_CONTRACT_ID },
   { "payment-request", "PaymentActionRequest", NS_PAYMENT_ACTION_REQUEST_CONTRACT_ID },
   { "payment-request", "PaymentCreateActionRequest", NS_PAYMENT_CREATE_ACTION_REQUEST_CONTRACT_ID },
   { "payment-request", "PaymentCompleteActionRequest", NS_PAYMENT_COMPLETE_ACTION_REQUEST_CONTRACT_ID },
   { "payment-request", "PaymentUpdateActionRequest", NS_PAYMENT_UPDATE_ACTION_REQUEST_CONTRACT_ID },
   { "payment-request", "PaymentCanMakeActionResponse", NS_PAYMENT_CANMAKE_ACTION_RESPONSE_CONTRACT_ID },
   { "payment-request", "PaymentAbortActionResponse", NS_PAYMENT_ABORT_ACTION_RESPONSE_CONTRACT_ID },
   { "payment-request", "PaymentShowActionResponse", NS_PAYMENT_SHOW_ACTION_RESPONSE_CONTRACT_ID },
   { "payment-request", "PaymentCompleteActionResponse", NS_PAYMENT_COMPLETE_ACTION_RESPONSE_CONTRACT_ID },
diff --git a/dom/payments/PaymentRequestService.cpp b/dom/payments/PaymentRequestService.cpp
--- a/dom/payments/PaymentRequestService.cpp
+++ b/dom/payments/PaymentRequestService.cpp
@@ -2,16 +2,17 @@
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/ClearOnShutdown.h"
 #include "PaymentRequestData.h"
 #include "PaymentRequestService.h"
+#include "BasicCardPayment.h"
 
 namespace mozilla {
 namespace dom {
 
 StaticRefPtr<PaymentRequestService> gPaymentService;
 
 namespace {
 
@@ -295,41 +296,57 @@ PaymentRequestService::RequestPayment(ns
         new payments::PaymentRequest(tabId, requestId, methodData, details, options);
 
       if (!mRequestQueue.AppendElement(payment, mozilla::fallible)) {
         return NS_ERROR_OUT_OF_MEMORY;
       }
       break;
     }
     /*
-     *  TODO: 1. Check basic card support once the Basic Card Payment spec is
-     *           implemented.
-     *           https://www.w3.org/TR/payment-method-basic-card/
-     *        2. Check third party payment app support by traversing all
+     *  TODO: 1. Check third party payment app support by traversing all
      *           registered third party payment apps.
      */
     case nsIPaymentActionRequest::CANMAKE_ACTION: {
-      rv = CallTestingUIAction(requestId, type);
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        return NS_ERROR_FAILURE;
+      if (IsBasicCardPayment(requestId)) {
+        nsCOMPtr<nsIPaymentCanMakeActionResponse> canMakeResponse =
+          do_CreateInstance(NS_PAYMENT_CANMAKE_ACTION_RESPONSE_CONTRACT_ID);
+        MOZ_ASSERT(canMakeResponse);
+        rv = canMakeResponse->Init(requestId, true);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          return rv;
+        }
+        nsCOMPtr<nsIPaymentActionResponse> response = do_QueryInterface(canMakeResponse);
+        MOZ_ASSERT(response);
+        rv = RespondPayment(response);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          return rv;
+        }
+      } else {
+        rv = CallTestingUIAction(requestId, type);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          return NS_ERROR_FAILURE;
+        }
       }
       break;
     }
     /*
      *  TODO: Launch/inform payment UI here once the UI module is implemented.
      */
     case nsIPaymentActionRequest::SHOW_ACTION: {
       if (mShowingRequest) {
+        nsCOMPtr<nsIPaymentResponseData> responseData =
+          do_CreateInstance(NS_GENERAL_RESPONSE_DATA_CONTRACT_ID);
+        MOZ_ASSERT(responseData);
         nsCOMPtr<nsIPaymentShowActionResponse> showResponse =
           do_CreateInstance(NS_PAYMENT_SHOW_ACTION_RESPONSE_CONTRACT_ID);
         MOZ_ASSERT(showResponse);
         rv = showResponse->Init(requestId,
                                 nsIPaymentActionResponse::PAYMENT_REJECTED,
                                 EmptyString(),
-                                EmptyString(),
+                                responseData,
                                 EmptyString(),
                                 EmptyString(),
                                 EmptyString());
         nsCOMPtr<nsIPaymentActionResponse> response = do_QueryInterface(showResponse);
         MOZ_ASSERT(response);
         rv = RespondPayment(response);
         if (NS_WARN_IF(NS_FAILED(rv))) {
           return rv;
@@ -514,10 +531,37 @@ PaymentRequestService::RemoveActionCallb
   nsCOMPtr<nsIPaymentActionCallback> callback;
   if (!mCallbackHashtable.Get(aRequestId, getter_AddRefs(callback))) {
     return NS_ERROR_FAILURE;
   }
   mCallbackHashtable.Remove(aRequestId);
   return NS_OK;
 }
 
+bool
+PaymentRequestService::IsBasicCardPayment(const nsAString& aRequestId)
+{
+  nsCOMPtr<nsIPaymentRequest> payment;
+  nsresult rv = GetPaymentRequestById(aRequestId, getter_AddRefs(payment));
+  NS_ENSURE_SUCCESS(rv, false);
+  nsCOMPtr<nsIArray> methods;
+  rv = payment->GetPaymentMethods(getter_AddRefs(methods));
+  NS_ENSURE_SUCCESS(rv, false);
+  uint32_t length;
+  rv = methods->GetLength(&length);
+  NS_ENSURE_SUCCESS(rv, false);
+  RefPtr<BasicCardService> service = BasicCardService::GetService();
+  MOZ_ASSERT(service);
+  for (uint32_t index = 0; index < length; ++index) {
+    nsCOMPtr<nsIPaymentMethodData> method = do_QueryElementAt(methods, index);
+    MOZ_ASSERT(method);
+    nsAutoString supportedMethods;
+    rv = method->GetSupportedMethods(supportedMethods);
+    NS_ENSURE_SUCCESS(rv, false);
+    if (service->IsBasicCardPayment(supportedMethods)) {
+      return true;
+    }
+  }
+  return false;
+}
+
 } // end of namespace dom
 } // end of namespace mozilla
diff --git a/dom/payments/PaymentRequestService.h b/dom/payments/PaymentRequestService.h
--- a/dom/payments/PaymentRequestService.h
+++ b/dom/payments/PaymentRequestService.h
@@ -41,16 +41,19 @@ private:
                     nsIPaymentActionCallback* aCallback);
   nsresult
   RemoveActionCallback(const nsAString& aRequestId);
 
   // this method is only used for testing
   nsresult
   CallTestingUIAction(const nsAString& aRequestId, uint32_t aActionType);
 
+  bool
+  IsBasicCardPayment(const nsAString& aRequestId);
+
   FallibleTArray<nsCOMPtr<nsIPaymentRequest>> mRequestQueue;
 
   nsInterfaceHashtable<nsStringHashKey, nsIPaymentActionCallback> mCallbackHashtable;
 
   nsCOMPtr<nsIPaymentUIService> mTestingUIService;
 
   nsCOMPtr<nsIPaymentRequest> mShowingRequest;
 };
diff --git a/dom/payments/PaymentRequestUtils.cpp b/dom/payments/PaymentRequestUtils.cpp
--- a/dom/payments/PaymentRequestUtils.cpp
+++ b/dom/payments/PaymentRequestUtils.cpp
@@ -9,27 +9,43 @@
 #include "nsIMutableArray.h"
 #include "nsISupportsPrimitives.h"
 #include "nsIJSON.h"
 
 namespace mozilla {
 namespace dom {
 
 nsresult
-SerializeFromJSObject(JSContext* aCx, JS::HandleObject aObject, nsAString& aSerializedObject) {
+SerializeFromJSObject(JSContext* aCx, JS::HandleObject aObject, nsAString& aSerializedObject)
+{
+  MOZ_ASSERT(aCx);
   nsCOMPtr<nsIJSON> serializer = do_CreateInstance("@mozilla.org/dom/json;1");
   if (NS_WARN_IF(!serializer)) {
     return NS_ERROR_FAILURE;
   }
   JS::RootedValue value(aCx, JS::ObjectValue(*aObject));
   return serializer->EncodeFromJSVal(value.address(), aCx, aSerializedObject);
 }
 
 nsresult
-DeserializeToJSObject(const nsAString& aSerializedObject, JSContext* aCx, JS::MutableHandleObject aObject) {
+SerializeFromJSVal(JSContext* aCx, JS::HandleValue aValue, nsAString& aSerializedValue)
+{
+  MOZ_ASSERT(aCx);
+  nsCOMPtr<nsIJSON> serializer = do_CreateInstance("@mozilla.org/dom/json;1");
+  if (NS_WARN_IF(!serializer)) {
+    return NS_ERROR_FAILURE;
+  }
+  JS::RootedValue value(aCx, aValue.get());
+  return serializer->EncodeFromJSVal(value.address(), aCx, aSerializedValue);
+}
+
+nsresult
+DeserializeToJSObject(const nsAString& aSerializedObject, JSContext* aCx, JS::MutableHandleObject aObject)
+{
+  MOZ_ASSERT(aCx);
   nsCOMPtr<nsIJSON> deserializer = do_CreateInstance("@mozilla.org/dom/json;1");
   if (NS_WARN_IF(!deserializer)) {
     return NS_ERROR_FAILURE;
   }
   JS::RootedValue value(aCx);
   JS::MutableHandleValue handleVal(&value);
   nsresult rv = deserializer->DecodeToJSVal(aSerializedObject, aCx, handleVal);
   if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -38,10 +54,25 @@ DeserializeToJSObject(const nsAString& a
   if (value.isObject()) {
     aObject.set(&value.toObject());
   } else {
     aObject.set(nullptr);
   }
   return NS_OK;
 }
 
+nsresult
+DeserializeToJSValue(const nsAString& aSerializedObject, JSContext* aCx, JS::MutableHandleValue aValue)
+{
+  MOZ_ASSERT(aCx);
+  nsCOMPtr<nsIJSON> deserializer = do_CreateInstance("@mozilla.org/dom/json;1");
+  if (NS_WARN_IF(!deserializer)) {
+    return NS_ERROR_FAILURE;
+  }
+  nsresult rv = deserializer->DecodeToJSVal(aSerializedObject, aCx, aValue);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+  return NS_OK;
+}
+
 } // end of namespace dom
 } // end of namespace mozilla
diff --git a/dom/payments/PaymentRequestUtils.h b/dom/payments/PaymentRequestUtils.h
--- a/dom/payments/PaymentRequestUtils.h
+++ b/dom/payments/PaymentRequestUtils.h
@@ -14,16 +14,26 @@ namespace mozilla {
 namespace dom {
 
 nsresult
 SerializeFromJSObject(JSContext* aCx,
                       JS::HandleObject aObject,
                       nsAString& aSerializedObject);
 
 nsresult
+SerializeFromJSVal(JSContext* aCx,
+                   JS::HandleValue aValue,
+                   nsAString& aSerializedValue);
+
+nsresult
 DeserializeToJSObject(const nsAString& aSerializedObject,
                       JSContext* aCx,
                       JS::MutableHandleObject aObject);
 
+nsresult
+DeserializeToJSValue(const nsAString& aSerializedObject,
+                     JSContext* aCx,
+                     JS::MutableHandleValue aValue);
+
 } // end of namespace dom
 } // end of namespace mozilla
 
 #endif
diff --git a/dom/payments/PaymentResponse.cpp b/dom/payments/PaymentResponse.cpp
--- a/dom/payments/PaymentResponse.cpp
+++ b/dom/payments/PaymentResponse.cpp
@@ -1,15 +1,18 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/PaymentResponse.h"
+#include "mozilla/dom/BasicCardPaymentBinding.h"
+#include "BasicCardPayment.h"
+#include "PaymentAddress.h"
 #include "PaymentRequestUtils.h"
 
 namespace mozilla {
 namespace dom {
 
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(PaymentResponse, mOwner,
                                       mShippingAddress, mPromise)
 
@@ -68,17 +71,35 @@ void
 PaymentResponse::GetMethodName(nsString& aRetVal) const
 {
   aRetVal = mMethodName;
 }
 
 void
 PaymentResponse::GetDetails(JSContext* aCx, JS::MutableHandle<JSObject*> aRetVal) const
 {
-  DeserializeToJSObject(mDetails, aCx, aRetVal);
+  RefPtr<BasicCardService> service = BasicCardService::GetService();
+  MOZ_ASSERT(service);
+  if (!service->IsBasicCardPayment(mMethodName)) {
+    DeserializeToJSObject(mDetails, aCx, aRetVal);
+  } else {
+    BasicCardResponse response;
+    nsresult rv = service->DecodeBasicCardData(mDetails, mOwner, response);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return;
+    }
+
+    MOZ_ASSERT(aCx);
+    JS::RootedValue value(aCx);
+    JS::MutableHandleValue handleValue(&value);
+    if (NS_WARN_IF(!response.ToObjectInternal(aCx, handleValue))) {
+      return;
+    }
+    aRetVal.set(&handleValue.toObject());
+  }
 }
 
 void
 PaymentResponse::GetShippingOption(nsString& aRetVal) const
 {
   aRetVal = mShippingOption;
 }
 
diff --git a/dom/payments/moz.build b/dom/payments/moz.build
--- a/dom/payments/moz.build
+++ b/dom/payments/moz.build
@@ -17,16 +17,17 @@ EXPORTS.mozilla.dom += [
     'PaymentAddress.h',
     'PaymentRequest.h',
     'PaymentRequestManager.h',
     'PaymentRequestUpdateEvent.h',
     'PaymentResponse.h',
 ]
 
 UNIFIED_SOURCES += [
+    'BasicCardPayment.cpp',
     'PaymentActionRequest.cpp',
     'PaymentActionResponse.cpp',
     'PaymentAddress.cpp',
     'PaymentRequest.cpp',
     'PaymentRequestData.cpp',
     'PaymentRequestManager.cpp',
     'PaymentRequestModule.cpp',
     'PaymentRequestService.cpp',
diff --git a/dom/payments/test/BasiccardChromeScript.js b/dom/payments/test/BasiccardChromeScript.js
new file mode 100644
--- /dev/null
+++ b/dom/payments/test/BasiccardChromeScript.js
@@ -0,0 +1,213 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+"use strict";
+
+const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
+
+const { XPCOMUtils } = Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+const paymentSrv = Cc["@mozilla.org/dom/payments/payment-request-service;1"].getService(Ci.nsIPaymentRequestService);
+
+function emitTestFail(message) {
+  sendAsyncMessage("test-fail", message);
+}
+
+const billingAddress = Cc["@mozilla.org/dom/payments/payment-address;1"].
+                           createInstance(Ci.nsIPaymentAddress);
+const addressLine = Cc["@mozilla.org/array;1"].createInstance(Ci.nsIMutableArray);
+const address = Cc["@mozilla.org/supports-string;1"].createInstance(Ci.nsISupportsString);
+address.data = "Easton Ave";
+addressLine.appendElement(address);
+billingAddress.init("USA",              // country
+                     addressLine,        // address line
+                     "CA",               // region
+                     "San Bruno",        // city
+                     "",                 // dependent locality
+                     "94066",            // postal code
+                     "123456",           // sorting code
+                     "en",               // language code
+                     "",                 // organization
+                     "Bill A. Pacheco",  // recipient
+                     "+14344413879"); // phone
+
+const basiccardResponseData = Cc["@mozilla.org/dom/payments/basiccard-response-data;1"].
+                                 createInstance(Ci.nsIBasicCardResponseData);
+
+const showResponse = Cc["@mozilla.org/dom/payments/payment-show-action-response;1"].
+                        createInstance(Ci.nsIPaymentShowActionResponse);
+
+function abortPaymentResponse(requestId) {
+  let abortResponse = Cc["@mozilla.org/dom/payments/payment-abort-action-response;1"].
+                         createInstance(Ci.nsIPaymentAbortActionResponse);
+  abortResponse.init(requestId, Ci.nsIPaymentActionResponse.ABORT_SUCCEEDED);
+  return abortResponse.QueryInterface(Ci.nsIPaymentActionResponse);
+}
+
+function completePaymentResponse(requestId) {
+  let completeResponse = Cc["@mozilla.org/dom/payments/payment-complete-action-response;1"].
+                            createInstance(Ci.nsIPaymentCompleteActionResponse);
+  completeResponse.init(requestId, Ci.nsIPaymentActionResponse.COMPLETE_SUCCEEDED);
+  return completeResponse;
+}
+
+const detailedResponseUI = {
+  canMakePayment: function(requestId) {
+    return null;
+  },
+  showPayment: function(requestId) {
+    try {
+      basiccardResponseData.initData("Bill A. Pacheco",  // cardholderName
+                                     "4916855166538720", // cardNumber
+                                     "01",               // expiryMonth
+                                     "2024",             // expiryYear
+                                     "180",              // cardSecurityCode
+                                     billingAddress);   // billingAddress
+    } catch (e) {
+      emitTestFail("Fail to initialize basic card response data.");
+    }
+    showResponse.init(requestId,
+                      Ci.nsIPaymentActionResponse.PAYMENT_ACCEPTED,
+                      "basic-card",         // payment method
+                      basiccardResponseData,// payment method data
+                      "Bill A. Pacheco",    // payer name
+                      "",                   // payer email
+                      "");                  // payer phone
+    return showResponse;
+  },
+  abortPayment: abortPaymentResponse,
+  completePayment: completePaymentResponse,
+  updatePayment: function(requestId) {
+    return null;
+  },
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIPaymentUIService]),
+};
+
+const simpleResponseUI = {
+  canMakePayment: function(requestId) {
+    return null;
+  },
+  showPayment: function(requestId) {
+    try {
+      basiccardResponseData.initData("",                 // cardholderName
+                                     "4916855166538720", // cardNumber
+                                     "",                 // expiryMonth
+                                     "",                 // expiryYear
+                                     "",                 // cardSecurityCode
+                                     null);              // billingAddress
+    } catch (e) {
+      emitTestFail("Fail to initialize basic card response data.");
+    }
+    showResponse.init(requestId,
+                      Ci.nsIPaymentActionResponse.PAYMENT_ACCEPTED,
+                      "basic-card",         // payment method
+                      basiccardResponseData,// payment method data
+                      "Bill A. Pacheco",    // payer name
+                      "",                   // payer email
+                      "");                  // payer phone
+    return showResponse;
+  },
+  abortPayment: abortPaymentResponse,
+  completePayment: completePaymentResponse,
+  updatePayment: function(requestId) {
+    return null;
+  },
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIPaymentUIService]),
+};
+
+addMessageListener("set-detailed-ui-service", function() {
+  paymentSrv.setTestingUIService(detailedResponseUI.QueryInterface(Ci.nsIPaymentUIService));
+});
+
+addMessageListener("set-simple-ui-service", function() {
+  paymentSrv.setTestingUIService(simpleResponseUI.QueryInterface(Ci.nsIPaymentUIService));
+});
+
+addMessageListener("error-response-test", function() {
+  // test empty cardNumber
+  try {
+    basiccardResponseData.initData("", "", "", "", "", null);
+    emitTestFail("BasicCardResponse should not be initialized with empty cardNumber.");
+  } catch (e) {
+    if (e.name != "NS_ERROR_FAILURE") {
+      emitTestFail("Empty cardNumber expected 'NS_ERROR_FAILURE', but got " + e.name + ".");
+    }
+  }
+
+  // test invalid expiryMonth 123
+  try {
+    basiccardResponseData.initData("", "4916855166538720", "123", "", "", null);
+    emitTestFail("BasicCardResponse should not be initialized with invalid expiryMonth '123'.");
+  } catch (e) {
+    if (e.name != "NS_ERROR_FAILURE") {
+      emitTestFail("expiryMonth 123 expected 'NS_ERROR_FAILURE', but got " + e.name + ".");
+    }
+  }
+  // test invalid expiryMonth 99
+  try {
+    basiccardResponseData.initData("", "4916855166538720", "99", "", "", null);
+    emitTestFail("BasicCardResponse should not be initialized with invalid expiryMonth '99'.");
+  } catch (e) {
+    if (e.name != "NS_ERROR_FAILURE") {
+      emitTestFail("expiryMonth 99 xpected 'NS_ERROR_FAILURE', but got " + e.name + ".");
+    }
+  }
+  // test invalid expiryMonth ab
+  try {
+    basiccardResponseData.initData("", "4916855166538720", "ab", "", "", null);
+    emitTestFail("BasicCardResponse should not be initialized with invalid expiryMonth 'ab'.");
+  } catch (e) {
+    if (e.name != "NS_ERROR_FAILURE") {
+      emitTestFail("expiryMonth ab expected 'NS_ERROR_FAILURE', but got " + e.name + ".");
+    }
+  }
+  // test invalid expiryYear abcd
+  try {
+    basiccardResponseData.initData("", "4916855166538720", "", "abcd", "", null);
+    emitTestFail("BasicCardResponse should not be initialized with invalid expiryYear 'abcd'.");
+  } catch (e) {
+    if (e.name != "NS_ERROR_FAILURE") {
+      emitTestFail("expiryYear abcd expected 'NS_ERROR_FAILURE', but got " + e.name + ".");
+    }
+  }
+  // test invalid expiryYear 11111
+  try {
+    basiccardResponseData.initData("", "4916855166538720", "", "11111", "", null);
+    emitTestFail("BasicCardResponse should not be initialized with invalid expiryYear '11111'.");
+  } catch (e) {
+    if (e.name != "NS_ERROR_FAILURE") {
+      emitTestFail("expiryYear 11111 expected 'NS_ERROR_FAILURE', but got " + e.name + ".");
+    }
+  }
+
+
+  const responseData = Cc["@mozilla.org/dom/payments/general-response-data;1"].
+                          createInstance(Ci.nsIGeneralResponseData);
+  try {
+    responseData.initData({});
+  } catch (e) {
+    emitTestFail("Fail to initialize response data with empty object.");
+  }
+
+  try {
+    showResponse.init("testid",
+                      Ci.nsIPaymentActionResponse.PAYMENT_ACCEPTED,
+                      "basic-card",         // payment method
+                      responseData,         // payment method data
+                      "Bill A. Pacheco",    // payer name
+                      "",                   // payer email
+                      "");                  // payer phone
+    emitTestFail("nsIPaymentShowActionResponse should not be initialized with basic-card method and nsIGeneralResponseData.");
+  } catch (e) {
+    if (e.name != "NS_ERROR_FAILURE") {
+      emitTestFail("ShowResponse init expected 'NS_ERROR_FAILURE', but got " + e.name + ".");
+    }
+  }
+  sendAsyncMessage("error-response-complete");
+});
+
+addMessageListener("teardown", function() {
+  paymentSrv.cleanup();
+  paymentSrv.setTestingUIService(null);
+  sendAsyncMessage("teardown-complete");
+});
diff --git a/dom/payments/test/ConstructorChromeScript.js b/dom/payments/test/ConstructorChromeScript.js
--- a/dom/payments/test/ConstructorChromeScript.js
+++ b/dom/payments/test/ConstructorChromeScript.js
@@ -21,16 +21,19 @@ function checkSimplestRequest(payRequest
   const methodData = payRequest.paymentMethods.queryElementAt(0, Ci.nsIPaymentMethodData);
   if (!methodData) {
     emitTestFail("Fail to get payment methodData.");
   }
   const supportedMethod = methodData.supportedMethods;
   if (supportedMethod != "basic-card") {
     emitTestFail("supported method should be 'basic-card'.");
   }
+  if (methodData.data) {
+    emitTestFail("methodData.data should not exist.");
+  }
 
   // checking the passed PaymentDetails parameter
   const details = payRequest.paymentDetails;
   if (details.totalItem.label != "Total") {
     emitTestFail("total item's label should be 'Total'.");
   }
   if (details.totalItem.amount.currency != "USD") {
     emitTestFail("total item's currency should be 'USD'.");
@@ -77,18 +80,44 @@ function checkComplexRequest(payRequest)
   if (!methodData) {
     emitTestFail("Fail to get payment methodData.");
   }
   let supportedMethod = methodData.supportedMethods;
   if (supportedMethod != "basic-card") {
     emitTestFail("supported method should be 'basic-card'.");
   }
   const data = methodData.data;
-  if (data != "{\"supportedNetworks\":[\"unionpay\",\"visa\",\"mastercard\",\"amex\",\"discover\",\"diners\",\"jcb\",\"mir\"],\"supportedTypes\":[\"prepaid\",\"debit\",\"credit\"]}") {
-    emitTestFail("method data should be '{\"supportedNetworks\":[\"unionpay\",\"visa\",\"mastercard\",\"amex\",\"discover\",\"diners\",\"jcb\",\"mir\"],\"supportedTypes\":[\"prepaid\",\"debit\",\"credit\"]}', but got '" + data + "'.");
+  const supportedNetworks = data.supportedNetworks;
+  const expectedSupportedNetworks = ["unionpay", "visa", "mastercard", "amex",
+                                     "discover", "diners", "jcb", "mir"];
+  if (supportedNetworks.length !=  expectedSupportedNetworks.length) {
+    emitTestFail("supportedNetworks.length should be " +
+                 expectedSupportedNetworks.length +
+                 ", but got " + supportedNetworks.length + ".");
+  }
+  for (let idx = 0; idx < supportedNetworks.length; idx++) {
+    if (supportedNetworks[idx] != expectedSupportedNetworks[idx]) {
+      emitTestFail("supportedNetworks[" + idx + "] should be '" +
+                   expectedSupportedNetworks[idx] + "', but got '" +
+                   supportedNetworks[idx] + "'.");
+    }
+  }
+  const supportedTypes = data.supportedTypes;
+  const expectedSupportedTypes = ["prepaid", "debit", "credit"];
+  if (supportedTypes.length != expectedSupportedTypes.length) {
+    emitTestFail("supportedTypes.length should be '" +
+                 expectedSupportedTypes.length + "', but got '" +
+                 supportedTypes.length + "'.");
+  }
+  for (let idx = 0; idx < supportedTypes.length; idx++) {
+    if (supportedTypes[idx] != expectedSupportedTypes[idx]) {
+      emitTestFail("supportedTypes[" + idx + "] should be '" +
+                   expectedSupportedTypes[idx] + "', but got '" +
+                   supportedTypes[idx] + "'.");
+    }
   }
   // checking the passed PaymentDetails parameter
   const details = payRequest.paymentDetails;
   if (details.id != "payment details" ) {
     emitTestFail("details.id should be 'payment details'.");
   }
   if (details.totalItem.label != "Total") {
     emitTestFail("total item's label should be 'Total'.");
@@ -159,18 +188,19 @@ function checkComplexRequest(payRequest)
     emitTestFail("additional item's label should be 'basic-card discount'.");
   }
   if (additionalItem.amount.currency != "USD") {
     emitTestFail("additional item's currency should be 'USD'.");
   }
   if (additionalItem.amount.value != "-10.00") {
     emitTestFail("additional item's value should be '-10.00'.");
   }
-  if (modifier.data != "{\"discountProgramParticipantId\":\"86328764873265\"}") {
-    emitTestFail("modifier's data should be '{\"discountProgramParticipantId\":\"86328764873265\"}'.");
+  if (modifier.data.discountProgramParticipantId != "86328764873265") {
+    emitTestFail("modifier's data should be '86328764873265', but got '" +
+                 modifier.data.discountProgramParticipantId + "'.");
   }
 
   const shippingOptions = details.shippingOptions;
   if (!shippingOptions) {
     emitTestFail("details.shippingOptions should not be undefined.");
   }
   if (shippingOptions.length != 2) {
     emitTestFail("shippingOptions' length should be 2.");
@@ -222,16 +252,80 @@ function checkComplexRequest(payRequest)
   if (!paymentOptions.requestShipping) {
     emitTestFail("requestShipping option should be true.");
   }
   if (paymentOptions.shippingType != "shipping") {
     emitTestFail("shippingType option should be 'shipping'.")
   }
 }
 
+function checkNonBasicCardRequest(payRequest) {
+  if (payRequest.paymentMethods.length != 1) {
+    emitTestFail("paymentMethods' length should be 1.");
+  }
+
+  const methodData = payRequest.paymentMethods.queryElementAt(0, Ci.nsIPaymentMethodData);
+  if (!methodData) {
+    emitTestFail("Fail to get payment methodData.");
+  }
+  const supportedMethod = methodData.supportedMethods;
+  if (supportedMethod != "testing-payment-method") {
+    emitTestFail("supported method should be 'testing-payment-method'.");
+  }
+
+  const paymentId = methodData.data.paymentId;
+  if (paymentId != "P3892940") {
+    emitTestFail("methodData.data.paymentId should be 'P3892940', but got " + paymentId + ".");
+  }
+  const paymentType = methodData.data.paymentType;
+  if (paymentType != "prepaid") {
+    emitTestFail("methodData.data.paymentType should be 'prepaid', but got " + paymentType + ".");
+  }
+
+  // checking the passed PaymentDetails parameter
+  const details = payRequest.paymentDetails;
+  if (details.totalItem.label != "Total") {
+    emitTestFail("total item's label should be 'Total'.");
+  }
+  if (details.totalItem.amount.currency != "USD") {
+    emitTestFail("total item's currency should be 'USD'.");
+  }
+  if (details.totalItem.amount.value != "1.00") {
+    emitTestFail("total item's value should be '1.00'.");
+  }
+
+  if (details.displayItems) {
+    emitTestFail("details.displayItems should be undefined.");
+  }
+  if (details.modifiers) {
+    emitTestFail("details.displayItems should be undefined.");
+  }
+  if (details.shippingOptions) {
+    emitTestFail("details.shippingOptions should be undefined.");
+  }
+
+  // checking the default generated PaymentOptions parameter
+  const paymentOptions = payRequest.paymentOptions;
+  if (paymentOptions.requestPayerName) {
+    emitTestFail("requestPayerName option should be false.");
+  }
+  if (paymentOptions.requestPayerEmail) {
+    emitTestFail("requestPayerEmail option should be false.");
+  }
+  if (paymentOptions.requestPayerPhone) {
+    emitTestFail("requestPayerPhone option should be false.");
+  }
+  if (paymentOptions.requestShipping) {
+    emitTestFail("requestShipping option should be false.");
+  }
+  if (paymentOptions.shippingType != "shipping") {
+    emitTestFail("shippingType option should be 'shipping'.")
+  }
+}
+
 function checkDuplicateShippingOptionsRequest(payRequest) {
   if (payRequest.paymentMethods.length != 1) {
     emitTestFail("paymentMethods' length should be 1.");
   }
 
   const methodData = payRequest.paymentMethods.queryElementAt(0, Ci.nsIPaymentMethodData);
   if (!methodData) {
     emitTestFail("Fail to get payment methodData.");
@@ -317,16 +411,33 @@ function checkComplexRequestHandler() {
       break;
     }
     checkComplexRequest(payRequest);
   }
   paymentSrv.cleanup();
   sendAsyncMessage("check-complete");
 }
 
+function checkNonBasicCardRequestHandler() {
+  const paymentEnum = paymentSrv.enumerate();
+  if (!paymentEnum.hasMoreElements()) {
+    emitTestFail("PaymentRequestService should have at least one payment request.");
+  }
+  while (paymentEnum.hasMoreElements()) {
+    let payRequest = paymentEnum.getNext().QueryInterface(Ci.nsIPaymentRequest);
+    if (!payRequest) {
+      emitTestFail("Fail to get existing payment request.");
+      break;
+    }
+    checkNonBasicCardRequest(payRequest);
+  }
+  paymentSrv.cleanup();
+  sendAsyncMessage("check-complete");
+}
+
 function checkDuplicateShippingOptionsRequestHandler() {
   const paymentEnum = paymentSrv.enumerate();
   if (!paymentEnum.hasMoreElements()) {
     emitTestFail("PaymentRequestService should have at least one payment request.");
   }
   while (paymentEnum.hasMoreElements()) {
     let payRequest = paymentEnum.getNext().QueryInterface(Ci.nsIPaymentRequest);
     if (!payRequest) {
@@ -361,13 +472,14 @@ function checkMultipleRequestsHandler ()
   paymentSrv.cleanup();
   sendAsyncMessage("check-complete");
 }
 
 addMessageListener("check-simplest-request", checkSimplestRequestHandler);
 addMessageListener("check-complex-request", checkComplexRequestHandler);
 addMessageListener("check-duplicate-shipping-options-request", checkDuplicateShippingOptionsRequestHandler);
 addMessageListener("check-multiple-requests", checkMultipleRequestsHandler);
+addMessageListener("check-nonbasiccard-request", checkNonBasicCardRequestHandler);
 
 addMessageListener("teardown", function() {
   paymentSrv.cleanup();
   sendAsyncMessage("teardown-complete");
 });
diff --git a/dom/payments/test/ShowPaymentChromeScript.js b/dom/payments/test/ShowPaymentChromeScript.js
--- a/dom/payments/test/ShowPaymentChromeScript.js
+++ b/dom/payments/test/ShowPaymentChromeScript.js
@@ -8,39 +8,40 @@ const { classes: Cc, interfaces: Ci, uti
 const { XPCOMUtils } = Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 const paymentSrv = Cc["@mozilla.org/dom/payments/payment-request-service;1"].getService(Ci.nsIPaymentRequestService);
 
 function emitTestFail(message) {
   sendAsyncMessage("test-fail", message);
 }
 
+const shippingAddress = Cc["@mozilla.org/dom/payments/payment-address;1"].
+                           createInstance(Ci.nsIPaymentAddress);
+const addressLine = Cc["@mozilla.org/array;1"].createInstance(Ci.nsIMutableArray);
+const address = Cc["@mozilla.org/supports-string;1"].createInstance(Ci.nsISupportsString);
+address.data = "Easton Ave";
+addressLine.appendElement(address);
+shippingAddress.init("USA",              // country
+                     addressLine,        // address line
+                     "CA",               // region
+                     "San Bruno",        // city
+                     "",                 // dependent locality
+                     "94066",            // postal code
+                     "123456",           // sorting code
+                     "en",               // language code
+                     "",                 // organization
+                     "Bill A. Pacheco",  // recipient
+                     "+1-434-441-3879"); // phone
+
 const NormalUIService = {
   shippingOptionChanged: false,
   canMakePayment: function(requestId) {
     return null;
   },
   showPayment: function(requestId) {
-    const shippingAddress = Cc["@mozilla.org/dom/payments/payment-address;1"].
-                            createInstance(Ci.nsIPaymentAddress);
-    const addressLine = Cc["@mozilla.org/array;1"].createInstance(Ci.nsIMutableArray);
-    const address = Cc["@mozilla.org/supports-string;1"].createInstance(Ci.nsISupportsString);
-    address.data = "Easton Ave";
-    addressLine.appendElement(address);
-    shippingAddress.init("USA",              // country
-                         addressLine,        // address line
-                         "CA",               // region
-                         "San Bruno",        // city
-                         "",                 // dependent locality
-                         "94066",            // postal code
-                         "123456",           // sorting code
-                         "en",               // language code
-                         "",                 // organization
-                         "Bill A. Pacheco",  // recipient
-                         "+1-434-441-3879"); // phone
     paymentSrv.changeShippingAddress(requestId, shippingAddress);
     return null;
   },
   abortPayment: function(requestId) {
     return null;
   },
   completePayment: function(requestId) {
     let completeResponse = Cc["@mozilla.org/dom/payments/payment-complete-action-response;1"].
@@ -62,46 +63,63 @@ const NormalUIService = {
       let shippingOption = shippingOptions.queryElementAt(0, Ci.nsIPaymentShippingOption);
       if (shippingOption.selected) {
         emitTestFail(shippingOption.label + " should not be selected.");
       }
       shippingOption = shippingOptions.queryElementAt(1, Ci.nsIPaymentShippingOption);
       if (!shippingOption.selected) {
         emitTestFail(shippingOption.label + " should be selected.");
       }
-      const paymentData = "{\"cardholderName\":\"Bill A. Pacheco\",\"cardNumber\":\"4024007191304152\",\"expiryMonth\":\"05\",\"expiryYear\":\"2019\",\"cardSecurityCode\":\"024\"}";
+
+      const showResponseData = Cc["@mozilla.org/dom/payments/general-response-data;1"].
+                                  createInstance(Ci.nsIGeneralResponseData);
+
+      try {
+        showResponseData.initData({ paymentToken: "6880281f-0df3-4b8e-916f-66575e2457c1",});
+      } catch (e) {
+        emitTestFail("Fail to initialize response data with { paymentToken: \"6880281f-0df3-4b8e-916f-66575e2457c1\",}");
+      }
+
       showResponse = Cc["@mozilla.org/dom/payments/payment-show-action-response;1"].
                      createInstance(Ci.nsIPaymentShowActionResponse);
       showResponse.init(requestId,
                         Ci.nsIPaymentActionResponse.PAYMENT_ACCEPTED,
-                        "basic-card",               // payment method
-                        paymentData,                // payment method data
+                        "testing-payment-method",   // payment method
+                        showResponseData,           // payment method data
                         "Bill A. Pacheco",          // payer name
                         "",                         // payer email
                         "");                        // payer phone
     }
     return showResponse;
   },
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIPaymentUIService]),
 };
 
 const RejectUIService = {
   canMakePayment: function(requestId) {
     return null;
   },
   showPayment: function(requestId) {
+    const responseData = Cc["@mozilla.org/dom/payments/general-response-data;1"].
+                            createInstance(Ci.nsIGeneralResponseData);
+
+    try {
+      responseData.initData({});
+    } catch (e) {
+      emitTestFail("Fail to initialize response data with empty object.");
+    }
     const showResponse = Cc["@mozilla.org/dom/payments/payment-show-action-response;1"].
-                         createInstance(Ci.nsIPaymentShowActionResponse);
+                            createInstance(Ci.nsIPaymentShowActionResponse);
     showResponse.init(requestId,
                       Ci.nsIPaymentActionResponse.PAYMENT_REJECTED,
-                      "",       // payment method
-                      "",       // payment method data
-                      "",       // payer name
-                      "",       // payer email
-                      "");      // payer phone
+                      "",                 // payment method
+                      responseData,       // payment method data
+                      "",                 // payer name
+                      "",                 // payer email
+                      "");                // payer phone
 
     return showResponse;
   },
   abortPayment: function(requestId) {
     return null;
   },
   completePayment: function(requestId) {
     return null;
@@ -129,40 +147,78 @@ const ErrorUIService = {
   updatePayment: function(requestId) {
     let payRequest = paymentSrv.getPaymentRequestById(requestId);
     if (!payRequest) {
       emitTestFail("Fail to get existing payment request.");
     }
     if (payRequest.paymentDetails.error != "Update with Error") {
       emitTestFail("details.error should be 'Update with Error', but got " + payRequest.paymentDetails.error + ".");
     }
+    const responseData = Cc["@mozilla.org/dom/payments/general-response-data;1"].
+                            createInstance(Ci.nsIGeneralResponseData);
+    try {
+      responseData.initData({});
+    } catch (e) {
+      emitTestFail("Fail to initialize response data with empty object.");
+    }
     const showResponse = Cc["@mozilla.org/dom/payments/payment-show-action-response;1"].
-                         createInstance(Ci.nsIPaymentShowActionResponse);
+                            createInstance(Ci.nsIPaymentShowActionResponse);
     showResponse.init(requestId,
                       Ci.nsIPaymentActionResponse.PAYMENT_REJECTED,
-                      "",       // payment method
-                      "",       // payment method data
-                      "",       // payer name
-                      "",       // payer email
-                      "");      // payer phone
+                      "",                 // payment method
+                      responseData,       // payment method data
+                      "",                 // payer name
+                      "",                 // payer email
+                      "");                // payer phone
+
     return showResponse;
   },
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIPaymentUIService]),
 
 };
 
+function testNullDetailsResponseHandler() {
+  const showResponseData = Cc["@mozilla.org/dom/payments/general-response-data;1"].
+                              createInstance(Ci.nsIGeneralResponseData);
+  try {
+    showResponseData.initData(null);
+    emitTestFail("nsIGeneralResponseData can not be initialized with null object.");
+  } catch (e) {
+    if (e.name != "NS_ERROR_FAILURE") {
+      emitTestFail("Expected 'NS_ERROR_FAILURE' when initializing nsIGeneralResponseData with null object, but got " + e.name + ".");
+    }
+  }
+  const showResponse = Cc["@mozilla.org/dom/payments/payment-show-action-response;1"].
+                          createInstance(Ci.nsIPaymentShowActionResponse);
+  try {
+    showResponse.init("test request id",
+                      Ci.nsIPaymentActionResponse.PAYMENT_ACCEPTED,
+                      "testing-payment-method",   // payment method
+                      showResponseData,           // payment method data
+                      "Bill A. Pacheco",          // payer name
+                      "",                         // payer email
+                      "");                        // payer phone
+  } catch (e) {
+    emitTestFail("Unexpected error " + e.name + " when initializing nsIPaymentShowActionResponse.");
+  }
+  sendAsyncMessage("test-null-details-response-complete");
+}
+
 addMessageListener("set-normal-ui-service", function() {
   paymentSrv.setTestingUIService(NormalUIService.QueryInterface(Ci.nsIPaymentUIService));
 });
 
 addMessageListener("set-reject-ui-service", function() {
   paymentSrv.setTestingUIService(RejectUIService.QueryInterface(Ci.nsIPaymentUIService));
 });
 
 addMessageListener("set-update-with-error-ui-service", function() {
   paymentSrv.setTestingUIService(ErrorUIService.QueryInterface(Ci.nsIPaymentUIService));
 })
 
+addMessageListener("test-null-details-response", testNullDetailsResponseHandler);
+
+
 addMessageListener("teardown", function() {
   paymentSrv.cleanup();
   paymentSrv.setTestingUIService(null);
   sendAsyncMessage('teardown-complete');
 });
diff --git a/dom/payments/test/head.js b/dom/payments/test/head.js
--- a/dom/payments/test/head.js
+++ b/dom/payments/test/head.js
@@ -3,17 +3,17 @@ const kTestRoot = getRootDirectory(gTest
 
 function checkSimplePayment(aSimplePayment) {
   // checking the passed PaymentMethods parameter
   is(aSimplePayment.paymentMethods.length, 1, "paymentMethods' length should be 1.");
 
   const methodData = aSimplePayment.paymentMethods.queryElementAt(0, Ci.nsIPaymentMethodData);
   ok(methodData, "Fail to get payment methodData.");
   is(methodData.supportedMethods, "MyPay", "supported method should be 'MyPay'.");
-  is(methodData.data, "", "method data should be empty");
+  ok(!methodData.data, "methodData.data should not exist.");
 
   // checking the passed PaymentDetails parameter
   const details = aSimplePayment.paymentDetails;
   is(details.id, "simple details", "details.id should be 'simple details'.");
   is(details.totalItem.label, "Donation", "total item's label should be 'Donation'.");
   is(details.totalItem.amount.currency, "USD", "total item's currency should be 'USD'.");
   is(details.totalItem.amount.value, "55.00", "total item's value should be '55.00'.");
 
@@ -32,17 +32,17 @@ function checkSimplePayment(aSimplePayme
 
 function checkComplexPayment(aPayment) {
   // checking the passed PaymentMethods parameter
   is(aPayment.paymentMethods.length, 1, "paymentMethods' length should be 1.");
 
   const methodData = aPayment.paymentMethods.queryElementAt(0, Ci.nsIPaymentMethodData);
   ok(methodData, "Fail to get payment methodData.");
   is(methodData.supportedMethods, "MyPay", "supported method should be 'MyPay'.");
-  is(methodData.data, "", "method data should be empty");
+  ok(!methodData.data, "methodData.data should not exist.");
 
   // checking the passed PaymentDetails parameter
   const details = aPayment.paymentDetails;
   is(details.id, "complex details", "details.id should be 'complex details'.");
   is(details.totalItem.label, "Donation", "total item's label should be 'Donation'.");
   is(details.totalItem.amount.currency, "USD", "total item's currency should be 'USD'.");
   is(details.totalItem.amount.value, "55.00", "total item's value should be '55.00'.");
 
@@ -67,18 +67,19 @@ function checkComplexPayment(aPayment) {
   is(modifier.total.amount.value, "45.00", "modifier's total value should be '45.00'.");
 
   const additionalItems = modifier.additionalDisplayItems;
   is(additionalItems.length, "1", "additionalDisplayItems' length should be 1.");
   const additionalItem = additionalItems.queryElementAt(0, Ci.nsIPaymentItem);
   is(additionalItem.label, "MyPay discount", "additional item's label should be 'MyPay discount'.");
   is(additionalItem.amount.currency, "USD", "additional item's currency should be 'USD'.");
   is(additionalItem.amount.value, "-10.00", "additional item's value should be '-10.00'.");
-  is(modifier.data, "{\"discountProgramParticipantId\":\"86328764873265\"}",
-     "modifier's data should be '{\"discountProgramParticipantId\":\"86328764873265\"}'.");
+  ok(modifier.data, "moidifer.data should exist.");
+  is(modifier.data.discountProgramParticipantId, "86328764873265",
+     "modifier.data.discountProgramParticipantId should be '86328764873265'.");
 
   const shippingOptions = details.shippingOptions;
   is(shippingOptions.length, 2, "shippingOptions' length should be 2.");
 
   let shippingOption = shippingOptions.queryElementAt(0, Ci.nsIPaymentShippingOption);
   is(shippingOption.id, "NormalShipping", "1st shippingOption's id should be 'NoramlShpping'.");
   is(shippingOption.label, "NormalShipping", "1st shippingOption's lable should be 'NormalShipping'.");
   is(shippingOption.amount.currency, "USD", "1st shippingOption's amount currency should be 'USD'.");
@@ -102,18 +103,18 @@ function checkComplexPayment(aPayment) {
 }
 
 function checkDupShippingOptionsPayment(aPayment) {
   // checking the passed PaymentMethods parameter
   is(aPayment.paymentMethods.length, 1, "paymentMethods' length should be 1.");
 
   const methodData = aPayment.paymentMethods.queryElementAt(0, Ci.nsIPaymentMethodData);
   ok(methodData, "Fail to get payment methodData.");
-  is(methodData.supportedMethods, "MyPay", "modifier's supported method name should be 'MyPay'.");
-  is(methodData.data, "", "method data should be empty");
+  is(methodData.supportedMethods, "MyPay", "methodData.supportedMethod name should be 'MyPay'.");
+  ok(!methodData.data, "methodData.data should not exist.");
 
   // checking the passed PaymentDetails parameter
   const details = aPayment.paymentDetails;
   is(details.id, "duplicate shipping options details", "details.id should be 'duplicate shipping options details'.");
   is(details.totalItem.label, "Donation", "total item's label should be 'Donation'.");
   is(details.totalItem.amount.currency, "USD", "total item's currency should be 'USD'.");
   is(details.totalItem.amount.value, "55.00", "total item's value should be '55.00'.");
 
diff --git a/dom/payments/test/mochitest.ini b/dom/payments/test/mochitest.ini
--- a/dom/payments/test/mochitest.ini
+++ b/dom/payments/test/mochitest.ini
@@ -1,16 +1,18 @@
 [DEFAULT]
 # skip-if !e10s will be removed once non-e10s is supported
 skip-if = !e10s
 scheme = https
 support-files =
   simple_payment_request.html
+  BasiccardChromeScript.js
   CanMakePaymentChromeScript.js
   ConstructorChromeScript.js
   ShowPaymentChromeScript.js
 
 [test_abortPayment.html]
+[test_basiccard.html]
 [test_canMakePayment.html]
 [test_constructor.html]
 [test_showPayment.html]
 [test_validate_decimal_value.html]
 [test_payment-request-in-iframe.html]
diff --git a/dom/payments/test/test_basiccard.html b/dom/payments/test/test_basiccard.html
new file mode 100644
--- /dev/null
+++ b/dom/payments/test/test_basiccard.html
@@ -0,0 +1,298 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1375345
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 1375345</title>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="application/javascript">
+
+  "use strict";
+  SimpleTest.waitForExplicitFinish();
+
+  var gUrl = SimpleTest.getTestFileURL('BasiccardChromeScript.js');
+  var gScript = SpecialPowers.loadChromeScript(gUrl);
+
+  function testFailHandler(message) {
+    ok(false, message);
+  }
+  gScript.addMessageListener("test-fail", testFailHandler);
+
+  const errorTypesMethods = [{
+    supportedMethods: "basic-card",
+    data: {
+      supportedTypes: ["myType"],
+    },
+  }];
+
+  const errorNetworksMethods = [{
+    supportedMethods: "basic-card",
+    data: {
+      supportedNetworks: ["myNetwork"],
+    },
+  }];
+
+  const nullDataMethods = [{
+    supportedMethods: "basic-card",
+  }];
+
+  const emptyDataMethods = [{
+    supportedMethods: "basic-card",
+    data: {},
+  }];
+
+  const unconvertableDataMethods = [{
+    supportedMethods: "basic-card",
+    data: "unconvertable data",
+  }];
+
+  const defaultMethods = [{
+    supportedMethods: "basic-card",
+    data: {
+      supportedNetworks: ["unionpay", "visa", "mastercard", "amex", "discover",
+                          "diners", "jcb", "mir",
+      ],
+      supportedTypes: ["prepaid", "debit", "credit"],
+    },
+  }];
+  const defaultDetails = {
+    id: "test payment",
+    total: {
+      label: "Total",
+      amount: {
+        currency: "USD",
+        value: "1.00"
+      }
+    },
+    shippingOptions: [
+      {
+        id: "NormalShipping",
+        label: "NormalShipping",
+        amount: {
+          currency: "USD",
+          value: "10.00"
+        },
+        selected: true,
+      },
+      {
+        id: "FastShipping",
+        label: "FastShipping",
+        amount: {
+          currency: "USD",
+          value: "30.00"
+        },
+        selected: false,
+      },
+    ],
+  };
+
+  const defaultOptions = {
+    requestPayerName: true,
+    requestPayerEmail: false,
+    reqeustPayerPhone: false,
+    requestShipping: true,
+    shippingType: "shipping"
+  };
+
+  function testBasicCardRequestWithErrorTypes() {
+    return new Promise((resolve, reject) => {
+      try {
+        const payRequest = new PaymentRequest(errorTypesMethods, defaultDetails, defaultOptions);
+        ok(false, "Expected 'TypeError', but got success construction.");
+        resolve();
+      } catch (e) {
+        is(e.name, "TypeError", "Expected TypeError, but got " + e.name);
+        resolve();
+      }
+    });
+  }
+
+  function testBasicCardRequestWithErrorNetworks() {
+    return new Promise((resolve, reject) => {
+      try {
+        const payRequest = new PaymentRequest(errorNetworksMethods, defaultDetails, defaultOptions);
+        ok(false, "Expected 'TypeError', but got success construction.");
+        resolve();
+      } catch (e) {
+        is(e.name, "TypeError", "Expected TypeError, but got " + e.name);
+        resolve();
+      }
+    });
+  }
+
+  function testBasicCardRequestWithUnconvertableData() {
+    return new Promise((resolve, reject) => {
+      try {
+        const payRequest = new PaymentRequest(unconvertableDataMethods, defaultDetails, defaultOptions);
+        ok(false, "Expected 'TypeError', but got success construction.");
+        resolve();
+      } catch (e) {
+        is(e.name, "TypeError", "Expected TypeError, but got " + e.name);
+        resolve();
+      }
+    });
+  }
+
+  function testBasicCardRequestWithNullData() {
+    return new Promise((resolve, reject) => {
+      try {
+        const payRequest = new PaymentRequest(nullDataMethods, defaultDetails, defaultOptions);
+        ok(payRequest, "PaymentRequest should be constructed with null data BasicCardRequest.");
+        resolve();
+      } catch (e) {
+        ok(false, "Unexpected error: " + e.name);
+        resolve();
+      }
+    });
+  }
+
+  function testBasicCardRequestWithEmptyData() {
+    return new Promise((resolve, reject) => {
+      try {
+        const payRequest = new PaymentRequest(emptyDataMethods, defaultDetails, defaultOptions);
+        ok(payRequest, "PaymentRequest should be constructed with empty data BasicCardRequest.");
+        resolve();
+      } catch (e) {
+        ok(false, "Unexpected error: " + e.name);
+        resolve();
+      }
+    });
+  }
+
+  function testCanMakePaymentWithBasicCardRequest() {
+    return new Promise((resolve, reject) => {
+      const payRequest = new PaymentRequest(defaultMethods, defaultDetails, defaultOptions);
+      payRequest.canMakePayment().then( result => {
+        ok(result, "Should be resolved with true, but got false.");
+        resolve();
+      }).catch (e => {
+        ok(false, "Unexpected error: " + e.name);
+        resolve();
+      });
+    });
+  }
+
+  function testBasicCardSimpleResponse() {
+    gScript.sendAsyncMessage("set-simple-ui-service");
+    return new Promise((resolve, reject) => {
+      const payRequest = new PaymentRequest(defaultMethods, defaultDetails, defaultOptions);
+      payRequest.show().then(response => {
+        ok(response.details, "basiccard response should exists.");
+        ok(!response.details.cardholderName, "response.details.cardholderName should not exist.");
+        is(response.details.cardNumber, "4916855166538720", "response.details.cardNumber should be '4916855166538720'.");
+        ok(!response.details.expiryMonth, "response.details.expiryMonth should not exist.");
+        ok(!response.details.expiryYear, "response.details.expiryYear should be '2024'.");
+        ok(!response.details.cardSecurityCode, "response.details.cardSecurityCode should not exist.");
+        ok(!response.details.billingAddress, "response.details.billingAddress should not exist.");
+        response.complete("success").then(() =>{
+          resolve();
+        }).catch(e => {
+          ok(false, "Unexpected error: " + e.name);
+          resolve();
+        });
+      }).catch( e => {
+        ok(false, "Unexpected error: " + e.name);
+        resolve();
+      });
+    });
+  }
+
+  function testBasicCardDetailedResponse() {
+    gScript.sendAsyncMessage("set-detailed-ui-service");
+    return new Promise((resolve, reject) => {
+      const payRequest = new PaymentRequest(defaultMethods, defaultDetails, defaultOptions);
+      payRequest.show().then(response => {
+        ok(response.details, "basiccard response should exists.");
+        is(response.details.cardholderName, "Bill A. Pacheco", "response.details.cardholderName should be 'Bill A. Pacheco'.");
+        is(response.details.cardNumber, "4916855166538720", "response.details.cardNumber should be '4916855166538720'.");
+        is(response.details.expiryMonth, "01", "response.details.expiryMonth should be '01'.");
+        is(response.details.expiryYear, "2024", "response.details.expiryYear should be '2024'.");
+        is(response.details.cardSecurityCode, "180", "response.details.cardSecurityCode should be '180'.");
+        const billingAddress = response.details.billingAddress;
+        is(billingAddress.country, "USA", "country should be 'USA'.");
+        is(billingAddress.addressLine.length, 1, "addressLine.length should be 1.");
+        is(billingAddress.addressLine[0], "Easton Ave", "addressLine[0] should be 'Easton Ave'.");
+        is(billingAddress.region, "CA", "region should be 'CA'.");
+        is(billingAddress.city, "San Bruno", "city should be 'San Bruno'.");
+        is(billingAddress.dependentLocality, "", "dependentLocality should be empty.");
+        is(billingAddress.postalCode, "94066", "postalCode should be '94066'.");
+        is(billingAddress.sortingCode, "123456", "sortingCode should be '123456'.");
+        is(billingAddress.languageCode, "en", "languageCode should be 'en'.");
+        is(billingAddress.organization, "", "organization should be empty." );
+        is(billingAddress.recipient, "Bill A. Pacheco", "recipient should be 'Bill A. Pacheco'.");
+        is(billingAddress.phone, "+14344413879", "phone should be '+14344413879'.");
+        response.complete("success").then(() =>{
+          resolve();
+        }).catch(e => {
+          ok(false, "Unexpected error: " + e.name);
+          resolve();
+        });
+      }).catch( e => {
+        ok(false, "Unexpected error: " + e.name);
+        resolve();
+      });
+    });
+  }
+
+  function testBasicCardErrorResponse() {
+    return new Promise((resolve, reject) => {
+      gScript.addMessageListener("error-response-complete",
+                                 function errorResponseCompleteHandler() {
+        gScript.removeMessageListener("error-response-complete",
+                                      errorResponseCompleteHandler);
+        resolve();
+      });
+      gScript.sendAsyncMessage("error-response-test");
+    });
+  }
+
+  function teardown() {
+    gScript.addMessageListener("teardown-complete", function teardownCompleteHandler() {
+      gScript.removeMessageListener("teardown-complete", teardownCompleteHandler);
+      gScript.removeMessageListener("test-fail", testFailHandler)
+      gScript.destroy();
+      SimpleTest.finish();
+    });
+    gScript.sendAsyncMessage("teardown");
+  }
+
+  function runTests() {
+    testBasicCardRequestWithErrorTypes()
+    .then(testBasicCardRequestWithErrorNetworks)
+    .then(testBasicCardRequestWithUnconvertableData)
+    .then(testBasicCardRequestWithNullData)
+    .then(testBasicCardRequestWithEmptyData)
+    .then(testCanMakePaymentWithBasicCardRequest)
+    .then(testBasicCardSimpleResponse)
+    .then(testBasicCardDetailedResponse)
+    .then(testBasicCardErrorResponse)
+    .then(teardown)
+    .catch( e => {
+      ok(false, "Unexpected error: " + e.name);
+      SimpleTest.finish();
+    });
+  }
+
+  window.addEventListener('load', function() {
+    SpecialPowers.pushPrefEnv({
+      'set': [
+        ['dom.payments.request.enabled', true],
+      ]
+    }, runTests);
+  });
+
+  </script>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1375345">Mozilla Bug 1375345</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+</pre>
+</body>
+</html>
diff --git a/dom/payments/test/test_constructor.html b/dom/payments/test/test_constructor.html
--- a/dom/payments/test/test_constructor.html
+++ b/dom/payments/test/test_constructor.html
@@ -39,16 +39,24 @@ https://bugzilla.mozilla.org/show_bug.cg
     data: {
       supportedNetworks: ['unionpay', 'visa', 'mastercard', 'amex', 'discover',
                           'diners', 'jcb', 'mir',
       ],
       supportedTypes: ['prepaid', 'debit', 'credit'],
     },
   }];
 
+  const nonBasicCardMethods = [{
+    supportedMethods: "testing-payment-method",
+    data: {
+      paymentId: "P3892940",
+      paymentType: "prepaid",
+    },
+  }];
+
   const complexDetails = {
     id: "payment details",
     total: {
       label: "Total",
       amount: {
         currency: "USD",
         value: "100.00"
       }
@@ -172,16 +180,28 @@ https://bugzilla.mozilla.org/show_bug.cg
       gScript.addMessageListener("check-complete", function checkCompleteHandler() {
         gScript.removeMessageListener("check-complete", checkCompleteHandler);
         resolve();
       });
       gScript.sendAsyncMessage("check-complex-request");
     });
   }
 
+  function testWithNonBasicCardMethods() {
+    return new Promise((resolve, reject) => {
+      const payRequest = new PaymentRequest(nonBasicCardMethods, simplestDetails);
+      ok(payRequest, "PaymentRequest should be created");
+      gScript.addMessageListener("check-complete", function checkCompleteHandler() {
+        gScript.removeMessageListener("check-complete", checkCompleteHandler);
+        resolve();
+      });
+      gScript.sendAsyncMessage("check-nonbasiccard-request");
+    });
+  }
+
   function testWithDuplicateShippingOptionsParameters() {
     return new Promise((resolve, reject) => {
       const payRequest = new PaymentRequest(simplestMethods, duplicateShippingOptionsDetails);
       ok(payRequest, "PaymentRequest should be created");
       gScript.addMessageListener("check-complete", function checkCompleteHandler() {
         gScript.removeMessageListener("check-complete", checkCompleteHandler);
         resolve();
       });
@@ -213,16 +233,17 @@ https://bugzilla.mozilla.org/show_bug.cg
       SimpleTest.finish();
     });
     gScript.sendAsyncMessage("teardown");
   }
 
   function runTests() {
     testWithSimplestParameters()
     .then(testWithComplexParameters)
+    .then(testWithNonBasicCardMethods)
     .then(testWithDuplicateShippingOptionsParameters)
     .then(testMultipleRequests)
     .then(teardown)
     .catch( e => {
       ok(false, "Unexpected error: " + e.name);
       SimpleTest.finish();
     });
   }
diff --git a/dom/payments/test/test_showPayment.html b/dom/payments/test/test_showPayment.html
--- a/dom/payments/test/test_showPayment.html
+++ b/dom/payments/test/test_showPayment.html
@@ -24,16 +24,18 @@ https://bugzilla.mozilla.org/show_bug.cg
   const defaultMethods = [{
     supportedMethods: "basic-card",
     data: { 
       supportedNetworks: ['unionpay', 'visa', 'mastercard', 'amex', 'discover',
                           'diners', 'jcb', 'mir',
       ],
       supportedTypes: ['prepaid', 'debit', 'credit'],
     },
+  }, {
+    supportedMethods: "testing-payment-method",
   }];
   const defaultDetails = {
     id: "test payment",
     total: {
       label: "Total",
       amount: {
         currency: "USD",
         value: "1.00"
@@ -155,22 +157,18 @@ https://bugzilla.mozilla.org/show_bug.cg
       payRequest.addEventListener("shippingaddresschange", event => {
         event.updateWith(updateWithShippingAddress());
       });
       payRequest.addEventListener("shippingoptionchange", event => {
         event.updateWith(updateWithShippingOption());
       });
       payRequest.show().then(response => {
         is(response.requestId, "test payment", "response.requestId should be 'test payment'.");
-        is(response.methodName, "basic-card", "response.methodName should be 'basic-card'.");
-        is(response.details.cardholderName, "Bill A. Pacheco", "response.details.cardholderName should be 'Bill A. Pacheco'.");
-        is(response.details.cardNumber, "4024007191304152", "response.details.cardNumber should be '4024007191304152'.");
-        is(response.details.expiryMonth, "05", "response.details.expiryMonth should be '05'.");
-        is(response.details.expiryYear, "2019", "response.details.expiryYear should be '2019'.");
-        is(response.details.cardSecurityCode, "024", "response.details.cardSecurityCode should be '024'.");
+        is(response.methodName, "testing-payment-method", "response.methodName should be 'testing-payment-method'.");
+        is(response.details.paymentToken, "6880281f-0df3-4b8e-916f-66575e2457c1", "response.details.paymentToken should be '6880281f-0df3-4b8e-916f-66575e2457c1'.");
         is(response.shippingAddress.country, "USA", "response.shippingAddress.country should be 'USA'.");
         is(response.shippingAddress.addressLine.length, 1, "response.shippingAddress.addressLine.length should be 1.");
         is(response.shippingAddress.addressLine[0], "Easton Ave", "response.shippingAddress.addressLine[0] should be 'Easton Ave'.");
         is(response.shippingAddress.region, "CA", "response.shippingAddress.region should be 'CA'.");
         is(response.shippingAddress.city, "San Bruno", "response.shippingAddress.city should be 'San Bruno'.");
         is(response.shippingAddress.dependentLocality, "", "response.shippingAddress.dependentLocality should be empty.");
         is(response.shippingAddress.postalCode, "94066", "response.shippingAddress.postalCode should be '94066'.");
         is(response.shippingAddress.sortingCode, "123456", "response.shippingAddress.sortingCode should be '123456'.");
@@ -229,30 +227,43 @@ https://bugzilla.mozilla.org/show_bug.cg
         resolve();
       }).catch(e => {
         ok(false, "Unexpected error: " + e.name);
         resolve();
       });
     });
   }
 
+  function testNullDetailsResponse() {
+    return new Promise((resolve, reject) => {
+      gScript.addMessageListener("test-null-details-response-complete",
+                                 function nullDetailsResponseCompleteHandler() {
+        gScript.removeMessageListener("test-null-details-response-complete",
+                                      nullDetailsResponseCompleteHandler);
+        resolve();
+      });
+      gScript.sendAsyncMessage("test-null-details-response");
+    });
+  }
+
   function teardown() {
     gScript.addMessageListener("teardown-complete", function teardownCompleteHandler() {
       gScript.removeMessageListener("teardown-complete", teardownCompleteHandler);
       gScript.removeMessageListener("test-fail", testFailHandler)
       gScript.destroy();
       SimpleTest.finish();
     });
     gScript.sendAsyncMessage("teardown");
   }
 
   function runTests() {
     testRejectShow()
     .then(testShow)
     .then(testUpdateWithError)
+    .then(testNullDetailsResponse)
     .then(teardown)
     .catch( e => {
       ok(false, "Unexpected error: " + e.name);
       SimpleTest.finish();
     });
   }
 
   window.addEventListener('load', function() {
diff --git a/dom/payments/test/test_validate_decimal_value.html b/dom/payments/test/test_validate_decimal_value.html
--- a/dom/payments/test/test_validate_decimal_value.html
+++ b/dom/payments/test/test_validate_decimal_value.html
@@ -50,17 +50,17 @@ https://bugzilla.mozilla.org/show_bug.cg
 
   function testInvalidTotalAmounts() {
     return new Promise((resolve, reject) => {
       for (const amount of invalidTotalAmounts) {
         try {
           new PaymentRequest(
             [
               {
-                supportedMethods: ["basic-card"],
+                supportedMethods: "basic-card",
               },
             ],
             {
               total: {
                 label: "",
                 amount: {
                   currency: "USD",
                   value: amount,
@@ -83,17 +83,17 @@ https://bugzilla.mozilla.org/show_bug.cg
 
   function testInvalidAmounts() {
      return new Promise((resolve, reject) => {
       for (const amount of invalidAmounts) {
         try {
           new PaymentRequest(
             [
               {
-                supportedMethods: ["basic-card"],
+                supportedMethods: "basic-card",
               },
             ],
             {
               total: {
                 label: "",
                 amount: {
                   currency: "USD",
                   value: "1.00",
diff --git a/dom/plugins/base/nsNPAPIPluginStreamListener.cpp b/dom/plugins/base/nsNPAPIPluginStreamListener.cpp
--- a/dom/plugins/base/nsNPAPIPluginStreamListener.cpp
+++ b/dom/plugins/base/nsNPAPIPluginStreamListener.cpp
@@ -31,17 +31,17 @@ nsNPAPIStreamWrapper::~nsNPAPIStreamWrap
 {
   if (mOutputStream) {
     mOutputStream->Close();
   }
 }
 
 // nsNPAPIPluginStreamListener Methods
 NS_IMPL_ISUPPORTS(nsNPAPIPluginStreamListener,
-                  nsITimerCallback, nsIHTTPHeaderListener)
+                  nsITimerCallback, nsIHTTPHeaderListener, nsINamed)
 
 nsNPAPIPluginStreamListener::nsNPAPIPluginStreamListener(nsNPAPIPluginInstance* inst,
                                                          void* notifyData,
                                                          const char* aURL)
   : mStreamBuffer(nullptr)
   , mNotifyURL(aURL ? PL_strdup(aURL) : nullptr)
   , mInst(inst)
   , mStreamBufferSize(0)
@@ -769,16 +769,23 @@ nsNPAPIPluginStreamListener::Notify(nsIT
         StopDataPump();
       }
 
   MaybeRunStopBinding();
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsNPAPIPluginStreamListener::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsNPAPIPluginStreamListener");
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsNPAPIPluginStreamListener::StatusLine(const char* line)
 {
   mResponseHeaders.Append(line);
   mResponseHeaders.Append('\n');
   return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/dom/plugins/base/nsNPAPIPluginStreamListener.h b/dom/plugins/base/nsNPAPIPluginStreamListener.h
--- a/dom/plugins/base/nsNPAPIPluginStreamListener.h
+++ b/dom/plugins/base/nsNPAPIPluginStreamListener.h
@@ -3,16 +3,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsNPAPIPluginStreamListener_h_
 #define nsNPAPIPluginStreamListener_h_
 
 #include "nscore.h"
 #include "nsIHTTPHeaderListener.h"
+#include "nsINamed.h"
 #include "nsIRequest.h"
 #include "nsITimer.h"
 #include "nsCOMArray.h"
 #include "nsIOutputStream.h"
 #include "nsIPluginInstanceOwner.h"
 #include "nsString.h"
 #include "nsIAsyncVerifyRedirectCallback.h"
 #include "mozilla/PluginLibrary.h"
@@ -36,25 +37,27 @@ public:
 
   NPStream                              mNPStream;
 protected:
   nsCOMPtr<nsIOutputStream>             mOutputStream; // only valid if not browser initiated
   nsNPAPIPluginStreamListener*          mStreamListener; // only valid if browser initiated
 };
 
 class nsNPAPIPluginStreamListener : public nsITimerCallback,
-                                    public nsIHTTPHeaderListener
+                                    public nsIHTTPHeaderListener,
+                                    public nsINamed
 {
 private:
   typedef mozilla::PluginLibrary PluginLibrary;
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSIHTTPHEADERLISTENER
+  NS_DECL_NSINAMED
 
   nsNPAPIPluginStreamListener(nsNPAPIPluginInstance* inst, void* notifyData,
                               const char* aURL);
 
   nsresult OnStartBinding(nsPluginStreamListenerPeer* streamPeer);
   nsresult OnDataAvailable(nsPluginStreamListenerPeer* streamPeer,
                            nsIInputStream* input,
                            uint32_t length);
diff --git a/dom/plugins/base/nsPluginHost.cpp b/dom/plugins/base/nsPluginHost.cpp
--- a/dom/plugins/base/nsPluginHost.cpp
+++ b/dom/plugins/base/nsPluginHost.cpp
@@ -315,17 +315,18 @@ nsPluginHost::~nsPluginHost()
   UnloadPlugins();
   sInst = nullptr;
 }
 
 NS_IMPL_ISUPPORTS(nsPluginHost,
                   nsIPluginHost,
                   nsIObserver,
                   nsITimerCallback,
-                  nsISupportsWeakReference)
+                  nsISupportsWeakReference,
+                  nsINamed)
 
 already_AddRefed<nsPluginHost>
 nsPluginHost::GetInst()
 {
   if (!sInst) {
     sInst = new nsPluginHost();
     if (!sInst)
       return nullptr;
@@ -3729,16 +3730,23 @@ NS_IMETHODIMP nsPluginHost::Notify(nsITi
       return NS_OK;
     }
     pluginTag = pluginTag->mNext;
   }
 
   return NS_ERROR_FAILURE;
 }
 
+NS_IMETHODIMP
+nsPluginHost::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsPluginHost");
+  return NS_OK;
+}
+
 #ifdef XP_WIN
 // Re-enable any top level browser windows that were disabled by modal dialogs
 // displayed by the crashed plugin.
 static void
 CheckForDisabledWindows()
 {
   nsCOMPtr<nsIWindowMediator> wm(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
   if (!wm)
diff --git a/dom/plugins/base/nsPluginHost.h b/dom/plugins/base/nsPluginHost.h
--- a/dom/plugins/base/nsPluginHost.h
+++ b/dom/plugins/base/nsPluginHost.h
@@ -15,16 +15,17 @@
 #include "nsIPluginTag.h"
 #include "nsPluginsDir.h"
 #include "nsPluginDirServiceProvider.h"
 #include "nsWeakPtr.h"
 #include "nsIPrompt.h"
 #include "nsWeakReference.h"
 #include "MainThreadUtils.h"
 #include "nsTArray.h"
+#include "nsINamed.h"
 #include "nsTObserverArray.h"
 #include "nsITimer.h"
 #include "nsPluginTags.h"
 #include "nsIEffectiveTLDService.h"
 #include "nsIIDNService.h"
 #include "nsCRT.h"
 
 #ifdef XP_WIN
@@ -70,31 +71,33 @@ public:
 
   RefPtr<nsInvalidPluginTag> mPrev;
   RefPtr<nsInvalidPluginTag> mNext;
 };
 
 class nsPluginHost final : public nsIPluginHost,
                            public nsIObserver,
                            public nsITimerCallback,
-                           public nsSupportsWeakReference
+                           public nsSupportsWeakReference,
+                           public nsINamed
 {
   friend class nsPluginTag;
   friend class nsFakePluginTag;
   virtual ~nsPluginHost();
 
 public:
   nsPluginHost();
 
   static already_AddRefed<nsPluginHost> GetInst();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIPLUGINHOST
   NS_DECL_NSIOBSERVER
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   nsresult LoadPlugins();
   nsresult UnloadPlugins();
 
   nsresult SetUpPluginInstance(const nsACString &aMimeType,
                                nsIURI *aURL,
                                nsPluginInstanceOwner *aOwner);
 
diff --git a/dom/presentation/PresentationSessionInfo.cpp b/dom/presentation/PresentationSessionInfo.cpp
--- a/dom/presentation/PresentationSessionInfo.cpp
+++ b/dom/presentation/PresentationSessionInfo.cpp
@@ -1150,17 +1150,18 @@ PresentationControllingInfo::NotifyData(
  *    receives the answer.)
  * 5. |NotifyTransportReady| of |nsIPresentationSessionTransportCallback| is
  *    called. The presentation session is ready to use, so notify the listener
  *    of CONNECTED state.
  */
 
 NS_IMPL_ISUPPORTS_INHERITED(PresentationPresentingInfo,
                             PresentationSessionInfo,
-                            nsITimerCallback)
+                            nsITimerCallback,
+                            nsINamed)
 
 nsresult
 PresentationPresentingInfo::Init(nsIPresentationControlChannel* aControlChannel)
 {
   PresentationSessionInfo::Init(aControlChannel);
 
   // Add a timer to prevent waiting indefinitely in case the receiver page fails
   // to become ready.
@@ -1537,16 +1538,24 @@ PresentationPresentingInfo::Notify(nsITi
 {
   MOZ_ASSERT(NS_IsMainThread());
   NS_WARNING("The receiver page fails to become ready before timeout.");
 
   mTimer = nullptr;
   return ReplyError(NS_ERROR_DOM_TIMEOUT_ERR);
 }
 
+// nsITimerCallback
+NS_IMETHODIMP
+PresentationPresentingInfo::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("PresentationPresentingInfo");
+  return NS_OK;
+}
+
 // PromiseNativeHandler
 void
 PresentationPresentingInfo::ResolvedCallback(JSContext* aCx,
                                              JS::Handle<JS::Value> aValue)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_WARN_IF(!aValue.isObject())) {
diff --git a/dom/presentation/PresentationSessionInfo.h b/dom/presentation/PresentationSessionInfo.h
--- a/dom/presentation/PresentationSessionInfo.h
+++ b/dom/presentation/PresentationSessionInfo.h
@@ -9,16 +9,17 @@
 
 #include "base/process.h"
 #include "mozilla/dom/nsIContentParent.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/RefPtr.h"
 #include "nsCOMPtr.h"
+#include "nsINamed.h"
 #include "nsINetworkInfoService.h"
 #include "nsIPresentationControlChannel.h"
 #include "nsIPresentationDevice.h"
 #include "nsIPresentationListener.h"
 #include "nsIPresentationService.h"
 #include "nsIPresentationSessionTransport.h"
 #include "nsIPresentationSessionTransportBuilder.h"
 #include "nsIServerSocket.h"
@@ -228,21 +229,23 @@ private:
   bool mIsReconnecting = false;
   bool mDoReconnectAfterClose = false;
 };
 
 // Session info with presenting browsing context (receiver side) behaviors.
 class PresentationPresentingInfo final : public PresentationSessionInfo
                                        , public PromiseNativeHandler
                                        , public nsITimerCallback
+                                       , public nsINamed
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIPRESENTATIONCONTROLCHANNELLISTENER
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   PresentationPresentingInfo(const nsAString& aUrl,
                              const nsAString& aSessionId,
                              nsIPresentationDevice* aDevice)
     : PresentationSessionInfo(aUrl,
                               aSessionId,
                               nsIPresentationService::ROLE_RECEIVER)
   {
diff --git a/dom/promise/PromiseDebugging.cpp b/dom/promise/PromiseDebugging.cpp
--- a/dom/promise/PromiseDebugging.cpp
+++ b/dom/promise/PromiseDebugging.cpp
@@ -37,17 +37,17 @@ public:
 
   static void DispatchNeeded() {
     if (sDispatched.get()) {
       // An instance of `FlushRejections` has already been dispatched
       // and not run yet. No need to dispatch another one.
       return;
     }
     sDispatched.set(true);
-    SystemGroup::Dispatch("FlushRejections", TaskCategory::Other,
+    SystemGroup::Dispatch(TaskCategory::Other,
                           do_AddRef(new FlushRejections()));
   }
 
   static void FlushSync() {
     sDispatched.set(false);
 
     // Call the callbacks if necessary.
     // Note that these callbacks may in turn cause Promise to turn
diff --git a/dom/script/ScriptLoader.cpp b/dom/script/ScriptLoader.cpp
--- a/dom/script/ScriptLoader.cpp
+++ b/dom/script/ScriptLoader.cpp
@@ -1497,18 +1497,17 @@ public:
   void SetToken(void* aToken) {
     MOZ_ASSERT(aToken && !mToken);
     mToken = aToken;
   }
 
   static void Dispatch(already_AddRefed<NotifyOffThreadScriptLoadCompletedRunnable>&& aSelf) {
     RefPtr<NotifyOffThreadScriptLoadCompletedRunnable> self = aSelf;
     RefPtr<DocGroup> docGroup = self->mDocGroup;
-    docGroup->Dispatch("NotifyOffThreadScriptLoadCompletedRunnable",
-                       TaskCategory::Other, self.forget());
+    docGroup->Dispatch(TaskCategory::Other, self.forget());
   }
 
   NS_DECL_NSIRUNNABLE
 };
 
 } /* anonymous namespace */
 
 nsresult
@@ -2416,17 +2415,17 @@ void
 ScriptLoader::ProcessPendingRequestsAsync()
 {
   if (HasPendingRequests()) {
     nsCOMPtr<nsIRunnable> task =
       NewRunnableMethod("dom::ScriptLoader::ProcessPendingRequests",
                         this,
                         &ScriptLoader::ProcessPendingRequests);
     if (mDocument) {
-      mDocument->Dispatch("ScriptLoader", TaskCategory::Other, task.forget());
+      mDocument->Dispatch(TaskCategory::Other, task.forget());
     } else {
       NS_DispatchToCurrentThread(task.forget());
     }
   }
 }
 
 void
 ScriptLoader::ProcessPendingRequests()
diff --git a/dom/security/nsCSPContext.cpp b/dom/security/nsCSPContext.cpp
--- a/dom/security/nsCSPContext.cpp
+++ b/dom/security/nsCSPContext.cpp
@@ -1209,19 +1209,16 @@ nsCSPContext::AsyncReportViolation(nsISu
                                 aObserverSubject,
                                 aSourceFile,
                                 aScriptSample,
                                 aLineNum,
                                 this);
 
   if (XRE_IsContentProcess()) {
     if (mEventTarget) {
-      if (nsCOMPtr<nsINamed> named = do_QueryInterface(task)) {
-        named->SetName("CSPReportSenderRunnable");
-      }
       mEventTarget->Dispatch(task.forget(), NS_DISPATCH_NORMAL);
       return NS_OK;
     }
   }
 
   NS_DispatchToMainThread(task.forget());
   return NS_OK;
 }
diff --git a/dom/smil/nsSMILTimedElement.cpp b/dom/smil/nsSMILTimedElement.cpp
--- a/dom/smil/nsSMILTimedElement.cpp
+++ b/dom/smil/nsSMILTimedElement.cpp
@@ -2374,17 +2374,17 @@ nsSMILTimedElement::NotifyChangedInterva
 void
 nsSMILTimedElement::FireTimeEventAsync(EventMessage aMsg, int32_t aDetail)
 {
   if (!mAnimationElement)
     return;
 
   nsCOMPtr<nsIRunnable> event =
     new AsyncTimeEventRunner(mAnimationElement, aMsg, aDetail);
-  mAnimationElement->OwnerDoc()->Dispatch("AsyncTimeEventRunner", TaskCategory::Other,
+  mAnimationElement->OwnerDoc()->Dispatch(TaskCategory::Other,
                                           event.forget());
 }
 
 const nsSMILInstanceTime*
 nsSMILTimedElement::GetEffectiveBeginInstance() const
 {
   switch (mElementState)
   {
diff --git a/dom/storage/SessionStorageManager.cpp b/dom/storage/SessionStorageManager.cpp
--- a/dom/storage/SessionStorageManager.cpp
+++ b/dom/storage/SessionStorageManager.cpp
@@ -162,17 +162,17 @@ SessionStorageManager::CheckStorage(nsIP
 
   if (!aPrincipal) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   nsAutoCString originKey;
   nsAutoCString originAttributes;
   nsresult rv = GenerateOriginKey(aPrincipal, originAttributes, originKey);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  if (NS_FAILED(rv)) {
     return rv;
   }
 
   *aRetval = false;
 
   OriginKeyHashTable* table;
   if (!mOATable.Get(originAttributes, &table)) {
     return NS_OK;
diff --git a/dom/storage/Storage.cpp b/dom/storage/Storage.cpp
--- a/dom/storage/Storage.cpp
+++ b/dom/storage/Storage.cpp
@@ -130,15 +130,14 @@ Storage::NotifyChange(Storage* aStorage,
   // StorageNotifierService.
 
   RefPtr<StorageNotifierRunnable> r =
     new StorageNotifierRunnable(event, aStorageType, aIsPrivate);
 
   if (aImmediateDispatch) {
     Unused << r->Run();
   } else {
-    SystemGroup::Dispatch("Storage::NotifyChange", TaskCategory::Other,
-                          r.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, r.forget());
   }
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/storage/StorageNotifierService.cpp b/dom/storage/StorageNotifierService.cpp
--- a/dom/storage/StorageNotifierService.cpp
+++ b/dom/storage/StorageNotifierService.cpp
@@ -62,20 +62,38 @@ StorageNotifierService::Broadcast(Storag
   RefPtr<StorageEvent> event = aEvent;
 
   nsTObserverArray<RefPtr<StorageNotificationObserver>>::ForwardIterator
     iter(service->mObservers);
 
   while (iter.HasMore()) {
     RefPtr<StorageNotificationObserver> observer = iter.GetNext();
 
+    // Enforce that the source storage area's private browsing state matches
+    // this window's state.  These flag checks and their maintenance independent
+    // from the principal's OriginAttributes matter because chrome docshells
+    // that are part of private browsing windows can be private browsing without
+    // having their OriginAttributes set (because they have the system
+    // principal).
+    if (aPrivateBrowsing != observer->IsPrivateBrowsing()) {
+      continue;
+    }
+
+    // No reasons to continue if the principal of the event doesn't match with
+    // the window's one.
+    if (!StorageUtils::PrincipalsEqual(aEvent->GetPrincipal(),
+                                       observer->GetPrincipal())) {
+      continue;
+    }
+
     RefPtr<Runnable> r = NS_NewRunnableFunction(
       "StorageNotifierService::Broadcast",
       [observer, event, aStorageType, aPrivateBrowsing] () {
-        observer->ObserveStorageNotification(event, aStorageType, aPrivateBrowsing);
+        observer->ObserveStorageNotification(event, aStorageType,
+                                             aPrivateBrowsing);
       });
 
     if (aImmediateDispatch) {
       r->Run();
     } else {
       nsCOMPtr<nsIEventTarget> et = observer->GetEventTarget();
       if (et) {
         et->Dispatch(r.forget());
diff --git a/dom/storage/StorageNotifierService.h b/dom/storage/StorageNotifierService.h
--- a/dom/storage/StorageNotifierService.h
+++ b/dom/storage/StorageNotifierService.h
@@ -19,16 +19,22 @@ class StorageNotificationObserver
 public:
   NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
 
   virtual void
   ObserveStorageNotification(StorageEvent* aEvent,
                              const char16_t* aStorageType,
                              bool aPrivateBrowsing) = 0;
 
+  virtual bool
+  IsPrivateBrowsing() const = 0;
+
+  virtual nsIPrincipal*
+  GetPrincipal() const = 0;
+
   virtual nsIEventTarget*
   GetEventTarget() const = 0;
 };
 
 class StorageNotifierService final
 {
 public:
   NS_INLINE_DECL_REFCOUNTING(StorageNotifierService)
diff --git a/dom/storage/moz.build b/dom/storage/moz.build
--- a/dom/storage/moz.build
+++ b/dom/storage/moz.build
@@ -9,16 +9,17 @@ with Files("**"):
 
 EXPORTS.mozilla.dom += [
     'LocalStorage.h',
     'LocalStorageManager.h',
     'SessionStorageManager.h',
     'Storage.h',
     'StorageIPC.h',
     'StorageNotifierService.h',
+    'StorageUtils.h',
 ]
 
 UNIFIED_SOURCES += [
     'LocalStorage.cpp',
     'LocalStorageCache.cpp',
     'LocalStorageManager.cpp',
     'SessionStorage.cpp',
     'SessionStorageCache.cpp',
diff --git a/dom/webidl/BasicCardPayment.webidl b/dom/webidl/BasicCardPayment.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/BasicCardPayment.webidl
@@ -0,0 +1,27 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * The origin of this WebIDL file is
+ *   https://www.w3.org/TR/payment-request/#paymentrequest-interface
+ */
+enum BasicCardType {
+  "credit",
+  "debit",
+  "prepaid"
+};
+
+dictionary BasicCardRequest {
+  sequence<DOMString> supportedNetworks;
+  sequence<BasicCardType> supportedTypes;
+};
+
+dictionary BasicCardResponse {
+           DOMString cardholderName;
+  required DOMString cardNumber;
+           DOMString expiryMonth;
+           DOMString expiryYear;
+           DOMString cardSecurityCode;
+           PaymentAddress? billingAddress;
+};
diff --git a/dom/webidl/Document.webidl b/dom/webidl/Document.webidl
--- a/dom/webidl/Document.webidl
+++ b/dom/webidl/Document.webidl
@@ -266,19 +266,21 @@ partial interface Document {
 //http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html#dfn-document-register
 partial interface Document {
     // this is deprecated from CustomElements v0
     [Throws, Func="CustomElementRegistry::IsCustomElementEnabled"]
     object registerElement(DOMString name, optional ElementRegistrationOptions options);
 };
 
 // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html#sec-document-interface
+// https://w3c.github.io/page-visibility/#extensions-to-the-document-interface
 partial interface Document {
   readonly attribute boolean hidden;
   readonly attribute VisibilityState visibilityState;
+           attribute EventHandler onvisibilitychange;
 };
 
 // http://dev.w3.org/csswg/cssom/#extensions-to-the-document-interface
 partial interface Document {
     [Constant]
     readonly attribute StyleSheetList styleSheets;
     attribute DOMString? selectedStyleSheetSet;
     readonly attribute DOMString? lastStyleSheetSet;
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -406,16 +406,17 @@ WEBIDL_FILES = [
     'AudioStreamTrack.webidl',
     'AudioTrack.webidl',
     'AudioTrackList.webidl',
     'AudioWorkletGlobalScope.webidl',
     'AutocompleteInfo.webidl',
     'BarProp.webidl',
     'BaseAudioContext.webidl',
     'BaseKeyframeTypes.webidl',
+    'BasicCardPayment.webidl',
     'BatteryManager.webidl',
     'BeforeUnloadEvent.webidl',
     'BiquadFilterNode.webidl',
     'Blob.webidl',
     'BoxObject.webidl',
     'BroadcastChannel.webidl',
     'BrowserElement.webidl',
     'BrowserElementDictionaries.webidl',
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -612,22 +612,16 @@ private:
 
   NS_IMETHOD
   GetName(nsACString& aName) override
   {
     aName.AssignASCII("ScriptLoaderRunnable");
     return NS_OK;
   }
 
-  NS_IMETHOD
-  SetName(const char* aName) override
-  {
-    return NS_ERROR_NOT_IMPLEMENTED;
-  }
-
   void
   LoadingFinished(uint32_t aIndex, nsresult aRv)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aIndex < mLoadInfos.Length());
     ScriptLoadInfo& loadInfo = mLoadInfos[aIndex];
 
     loadInfo.mLoadResult = aRv;
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -10,16 +10,17 @@
 #include "nsIConsoleService.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIDocument.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIStreamLoader.h"
 #include "nsIHttpChannel.h"
 #include "nsIHttpChannelInternal.h"
 #include "nsIHttpHeaderVisitor.h"
+#include "nsINamed.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIMutableArray.h"
 #include "nsIScriptError.h"
 #include "nsISimpleEnumerator.h"
 #include "nsITimer.h"
 #include "nsIUploadChannel2.h"
 #include "nsPIDOMWindow.h"
 #include "nsServiceManagerUtils.h"
@@ -4169,16 +4170,17 @@ ServiceWorkerManager::RemoveNavigationIn
     if (list->IsEmpty()) {
       list = nullptr;
       mNavigationInterceptions.Remove(aScope);
     }
   }
 }
 
 class UpdateTimerCallback final : public nsITimerCallback
+                                , public nsINamed
 {
   nsCOMPtr<nsIPrincipal> mPrincipal;
   const nsCString mScope;
 
   ~UpdateTimerCallback()
   {
   }
 
@@ -4202,20 +4204,27 @@ public:
       // shutting down, do nothing
       return NS_OK;
     }
 
     swm->UpdateTimerFired(mPrincipal, mScope);
     return NS_OK;
   }
 
+  NS_IMETHOD
+  GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("UpdateTimerCallback");
+    return NS_OK;
+  }
+
   NS_DECL_ISUPPORTS
 };
 
-NS_IMPL_ISUPPORTS(UpdateTimerCallback, nsITimerCallback)
+NS_IMPL_ISUPPORTS(UpdateTimerCallback, nsITimerCallback, nsINamed)
 
 bool
 ServiceWorkerManager::MayHaveActiveServiceWorkerInstance(ContentParent* aContent,
                                                          nsIPrincipal* aPrincipal)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aPrincipal);
 
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -6,16 +6,17 @@
 
 #include "ServiceWorkerPrivate.h"
 
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerWindowClient.h"
 #include "nsContentUtils.h"
 #include "nsIHttpChannelInternal.h"
 #include "nsIHttpHeaderVisitor.h"
+#include "nsINamed.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIPushErrorReporter.h"
 #include "nsISupportsImpl.h"
 #include "nsITimedChannel.h"
 #include "nsIUploadChannel2.h"
 #include "nsNetUtil.h"
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
@@ -1048,16 +1049,17 @@ ServiceWorkerPrivate::SendPushSubscripti
 
   return NS_OK;
 }
 
 namespace {
 
 class AllowWindowInteractionHandler final : public ExtendableEventCallback
                                           , public nsITimerCallback
+                                          , public nsINamed
                                           , public WorkerHolder
 {
   nsCOMPtr<nsITimer> mTimer;
 
   ~AllowWindowInteractionHandler()
   {
     // We must either fail to initialize or call ClearWindowAllowed.
     MOZ_DIAGNOSTIC_ASSERT(!mTimer);
@@ -1132,16 +1134,24 @@ class AllowWindowInteractionHandler fina
   NS_IMETHOD
   Notify(nsITimer* aTimer) override
   {
     MOZ_DIAGNOSTIC_ASSERT(mTimer == aTimer);
     ClearWindowAllowed(mWorkerPrivate);
     return NS_OK;
   }
 
+  // nsINamed virtual methods
+  NS_IMETHOD
+  GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("AllowWindowInteractionHandler");
+    return NS_OK;
+  }
+
   // WorkerHolder virtual methods
   bool
   Notify(Status aStatus) override
   {
     // We could try to hold the worker alive until the timer fires, but other
     // APIs are not likely to work in this partially shutdown state.  We might
     // as well let the worker thread exit.
     ClearWindowAllowed(mWorkerPrivate);
@@ -1159,17 +1169,17 @@ public:
   void
   FinishedWithResult(ExtendableEventResult /* aResult */) override
   {
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     ClearWindowAllowed(workerPrivate);
   }
 };
 
-NS_IMPL_ISUPPORTS(AllowWindowInteractionHandler, nsITimerCallback)
+NS_IMPL_ISUPPORTS(AllowWindowInteractionHandler, nsITimerCallback, nsINamed)
 
 class SendNotificationEventRunnable final : public ExtendableEventWorkerRunnable
 {
   const nsString mEventName;
   const nsString mID;
   const nsString mTitle;
   const nsString mDir;
   const nsString mLang;
@@ -2014,16 +2024,17 @@ ServiceWorkerPrivate::IsIdle() const
 {
   AssertIsOnMainThread();
   return mTokenCount == 0 || (mTokenCount == 1 && mIdleKeepAliveToken);
 }
 
 namespace {
 
 class ServiceWorkerPrivateTimerCallback final : public nsITimerCallback
+                                              , public nsINamed
 {
 public:
   typedef void (ServiceWorkerPrivate::*Method)(nsITimer*);
 
   ServiceWorkerPrivateTimerCallback(ServiceWorkerPrivate* aServiceWorkerPrivate,
                                     Method aMethod)
     : mServiceWorkerPrivate(aServiceWorkerPrivate)
     , mMethod(aMethod)
@@ -2033,26 +2044,33 @@ public:
   NS_IMETHOD
   Notify(nsITimer* aTimer) override
   {
     (mServiceWorkerPrivate->*mMethod)(aTimer);
     mServiceWorkerPrivate = nullptr;
     return NS_OK;
   }
 
+  NS_IMETHOD
+  GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("ServiceWorkerPrivateTimerCallback");
+    return NS_OK;
+  }
+
 private:
   ~ServiceWorkerPrivateTimerCallback() = default;
 
   RefPtr<ServiceWorkerPrivate> mServiceWorkerPrivate;
   Method mMethod;
 
   NS_DECL_THREADSAFE_ISUPPORTS
 };
 
-NS_IMPL_ISUPPORTS(ServiceWorkerPrivateTimerCallback, nsITimerCallback);
+NS_IMPL_ISUPPORTS(ServiceWorkerPrivateTimerCallback, nsITimerCallback, nsINamed);
 
 } // anonymous namespace
 
 void
 ServiceWorkerPrivate::NoteIdleWorkerCallback(nsITimer* aTimer)
 {
   AssertIsOnMainThread();
 
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -11,16 +11,17 @@
 #include "nsIContentSecurityPolicy.h"
 #include "nsIConsoleService.h"
 #include "nsIDOMDOMException.h"
 #include "nsIDOMEvent.h"
 #include "nsIDocument.h"
 #include "nsIDocShell.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIMemoryReporter.h"
+#include "nsINamed.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIPermissionManager.h"
 #include "nsIScriptError.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIScriptTimeoutHandler.h"
 #include "nsITabChild.h"
 #include "nsITextToSubURI.h"
@@ -1206,17 +1207,18 @@ private:
 
     ReportError(aCx, parent, fireAtScope, aWorkerPrivate, mReport,
                 innerWindowId);
     return true;
   }
 };
 
 class TimerRunnable final : public WorkerRunnable,
-                            public nsITimerCallback
+                            public nsITimerCallback,
+                            public nsINamed
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   explicit TimerRunnable(WorkerPrivate* aWorkerPrivate)
   : WorkerRunnable(aWorkerPrivate, WorkerThreadUnchangedBusyCount)
   { }
 
@@ -1242,19 +1244,27 @@ private:
     return aWorkerPrivate->RunExpiredTimeouts(aCx);
   }
 
   NS_IMETHOD
   Notify(nsITimer* aTimer) override
   {
     return Run();
   }
+
+  NS_IMETHOD
+  GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("TimerRunnable");
+    return NS_OK;
+  }
 };
 
-NS_IMPL_ISUPPORTS_INHERITED(TimerRunnable, WorkerRunnable, nsITimerCallback)
+NS_IMPL_ISUPPORTS_INHERITED(TimerRunnable, WorkerRunnable, nsITimerCallback,
+                            nsINamed)
 
 class DebuggerImmediateRunnable : public WorkerRunnable
 {
   RefPtr<dom::Function> mHandler;
 
 public:
   explicit DebuggerImmediateRunnable(WorkerPrivate* aWorkerPrivate,
                                      dom::Function& aHandler)
@@ -5196,21 +5206,17 @@ WorkerPrivate::DispatchToMainThread(nsIR
   nsCOMPtr<nsIRunnable> r = aRunnable;
   return DispatchToMainThread(r.forget(), aFlags);
 }
 
 nsresult
 WorkerPrivate::DispatchToMainThread(already_AddRefed<nsIRunnable> aRunnable,
                                     uint32_t aFlags)
 {
-  nsCOMPtr<nsIRunnable> runnable = aRunnable;
-  if (nsCOMPtr<nsINamed> named = do_QueryInterface(runnable)) {
-    named->SetName("WorkerRunnable");
-  }
-  return mMainThreadEventTarget->Dispatch(runnable.forget(), aFlags);
+  return mMainThreadEventTarget->Dispatch(Move(aRunnable), aFlags);
 }
 
 nsISerialEventTarget*
 WorkerPrivate::ControlEventTarget()
 {
   return mWorkerControlEventTarget;
 }
 
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -489,17 +489,17 @@ WorkerGlobalScope::CreateImageBitmap(JSC
                                aRv);
   } else {
     aRv.Throw(NS_ERROR_TYPE_ERR);
     return nullptr;
   }
 }
 
 nsresult
-WorkerGlobalScope::Dispatch(const char* aName, TaskCategory aCategory,
+WorkerGlobalScope::Dispatch(TaskCategory aCategory,
                             already_AddRefed<nsIRunnable>&& aRunnable)
 {
   return EventTargetFor(aCategory)->Dispatch(Move(aRunnable),
                                              NS_DISPATCH_NORMAL);
 }
 
 nsISerialEventTarget*
 WorkerGlobalScope::EventTargetFor(TaskCategory aCategory) const
@@ -1075,17 +1075,17 @@ WorkerDebuggerGlobalScope::Dump(JSContex
 {
   WorkerGlobalScope* scope = mWorkerPrivate->GetOrCreateGlobalScope(aCx);
   if (scope) {
     scope->Dump(aString);
   }
 }
 
 nsresult
-WorkerDebuggerGlobalScope::Dispatch(const char* aName, TaskCategory aCategory,
+WorkerDebuggerGlobalScope::Dispatch(TaskCategory aCategory,
                                     already_AddRefed<nsIRunnable>&& aRunnable)
 {
   return EventTargetFor(aCategory)->Dispatch(Move(aRunnable),
                                              NS_DISPATCH_NORMAL);
 }
 
 nsISerialEventTarget*
 WorkerDebuggerGlobalScope::EventTargetFor(TaskCategory aCategory) const
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -203,17 +203,17 @@ public:
   {
     MOZ_ASSERT(mWindowInteractionsAllowed > 0);
     mWindowInteractionsAllowed--;
   }
 
   // Override DispatchTrait API to target the worker thread.  Dispatch may
   // return failure if the worker thread is not alive.
   nsresult
-  Dispatch(const char* aName, TaskCategory aCategory,
+  Dispatch(TaskCategory aCategory,
            already_AddRefed<nsIRunnable>&& aRunnable) override;
 
   nsISerialEventTarget*
   EventTargetFor(TaskCategory aCategory) const override;
 
   AbstractThread*
   AbstractMainThreadFor(TaskCategory aCategory) override;
 };
@@ -416,17 +416,17 @@ public:
   }
 
   void
   Dump(JSContext* aCx, const Optional<nsAString>& aString) const;
 
   // Override DispatchTrait API to target the worker thread.  Dispatch may
   // return failure if the worker thread is not alive.
   nsresult
-  Dispatch(const char* aName, TaskCategory aCategory,
+  Dispatch(TaskCategory aCategory,
            already_AddRefed<nsIRunnable>&& aRunnable) override;
 
   nsISerialEventTarget*
   EventTargetFor(TaskCategory aCategory) const override;
 
   AbstractThread*
   AbstractMainThreadFor(TaskCategory aCategory) override;
 
diff --git a/dom/xhr/XMLHttpRequestMainThread.cpp b/dom/xhr/XMLHttpRequestMainThread.cpp
--- a/dom/xhr/XMLHttpRequestMainThread.cpp
+++ b/dom/xhr/XMLHttpRequestMainThread.cpp
@@ -3949,31 +3949,26 @@ XMLHttpRequestMainThread::BlobStoreCompl
 
 NS_IMETHODIMP
 XMLHttpRequestMainThread::GetName(nsACString& aName)
 {
   aName.AssignLiteral("XMLHttpRequest");
   return NS_OK;
 }
 
-NS_IMETHODIMP
-XMLHttpRequestMainThread::SetName(const char* aName)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
 // nsXMLHttpRequestXPCOMifier implementation
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXMLHttpRequestXPCOMifier)
   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
   NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
   NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
   NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
   NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
+  NS_INTERFACE_MAP_ENTRY(nsINamed)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStreamListener)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXMLHttpRequestXPCOMifier)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXMLHttpRequestXPCOMifier)
 
 // Can't NS_IMPL_CYCLE_COLLECTION( because mXHR has ambiguous
 // inheritance from nsISupports.
diff --git a/dom/xhr/XMLHttpRequestMainThread.h b/dom/xhr/XMLHttpRequestMainThread.h
--- a/dom/xhr/XMLHttpRequestMainThread.h
+++ b/dom/xhr/XMLHttpRequestMainThread.h
@@ -873,17 +873,18 @@ private:
 
 // A shim class designed to expose the non-DOM interfaces of
 // XMLHttpRequest via XPCOM stuff.
 class nsXMLHttpRequestXPCOMifier final : public nsIStreamListener,
                                          public nsIChannelEventSink,
                                          public nsIAsyncVerifyRedirectCallback,
                                          public nsIProgressEventSink,
                                          public nsIInterfaceRequestor,
-                                         public nsITimerCallback
+                                         public nsITimerCallback,
+                                         public nsINamed
 {
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsXMLHttpRequestXPCOMifier,
                                            nsIStreamListener)
 
   explicit nsXMLHttpRequestXPCOMifier(XMLHttpRequestMainThread* aXHR) :
     mXHR(aXHR)
   {
@@ -898,16 +899,17 @@ private:
 
 public:
   NS_FORWARD_NSISTREAMLISTENER(mXHR->)
   NS_FORWARD_NSIREQUESTOBSERVER(mXHR->)
   NS_FORWARD_NSICHANNELEVENTSINK(mXHR->)
   NS_FORWARD_NSIASYNCVERIFYREDIRECTCALLBACK(mXHR->)
   NS_FORWARD_NSIPROGRESSEVENTSINK(mXHR->)
   NS_FORWARD_NSITIMERCALLBACK(mXHR->)
+  NS_FORWARD_NSINAMED(mXHR->)
 
   NS_DECL_NSIINTERFACEREQUESTOR
 
 private:
   RefPtr<XMLHttpRequestMainThread> mXHR;
 };
 
 class nsXHRParseEndListener : public nsIDOMEventListener
diff --git a/dom/xml/nsXMLContentSink.cpp b/dom/xml/nsXMLContentSink.cpp
--- a/dom/xml/nsXMLContentSink.cpp
+++ b/dom/xml/nsXMLContentSink.cpp
@@ -1093,18 +1093,17 @@ nsXMLContentSink::HandleEndElement(const
     }
     mNotifyLevel = stackLen - 1;
   }
   DidAddContent();
 
   if (content->IsSVGElement(nsGkAtoms::svg)) {
     FlushTags();
     nsCOMPtr<nsIRunnable> event = new nsHtml5SVGLoadDispatcher(content);
-    if (NS_FAILED(content->OwnerDoc()->Dispatch("nsHtml5SVGLoadDispatcher",
-                                                TaskCategory::Other,
+    if (NS_FAILED(content->OwnerDoc()->Dispatch(TaskCategory::Other,
                                                 event.forget()))) {
       NS_WARNING("failed to dispatch svg load dispatcher");
     }
   }
 
   return aInterruptable && NS_SUCCEEDED(result) ? DidProcessATokenImpl() :
                                                   result;
 }
diff --git a/editor/composer/nsComposerCommandsUpdater.cpp b/editor/composer/nsComposerCommandsUpdater.cpp
--- a/editor/composer/nsComposerCommandsUpdater.cpp
+++ b/editor/composer/nsComposerCommandsUpdater.cpp
@@ -35,17 +35,18 @@ nsComposerCommandsUpdater::~nsComposerCo
 {
   // cancel any outstanding update timer
   if (mUpdateTimer) {
     mUpdateTimer->Cancel();
   }
 }
 
 NS_IMPL_ISUPPORTS(nsComposerCommandsUpdater, nsISelectionListener,
-                  nsIDocumentStateListener, nsITransactionListener, nsITimerCallback)
+                  nsIDocumentStateListener, nsITransactionListener,
+                  nsITimerCallback, nsINamed)
 
 #if 0
 #pragma mark -
 #endif
 
 NS_IMETHODIMP
 nsComposerCommandsUpdater::NotifyDocumentCreated()
 {
@@ -350,16 +351,23 @@ nsComposerCommandsUpdater::GetCommandUpd
 {
   nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocShell);
   NS_ENSURE_TRUE(docShell, nullptr);
   nsCOMPtr<nsICommandManager> manager = docShell->GetCommandManager();
   nsCOMPtr<nsPICommandUpdater> updater = do_QueryInterface(manager);
   return updater.forget();
 }
 
+NS_IMETHODIMP
+nsComposerCommandsUpdater::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsComposerCommandsUpdater");
+  return NS_OK;
+}
+
 #if 0
 #pragma mark -
 #endif
 
 nsresult
 nsComposerCommandsUpdater::Notify(nsITimer *timer)
 {
   NS_ASSERTION(timer == mUpdateTimer.get(), "Hey, this ain't my timer!");
diff --git a/editor/composer/nsComposerCommandsUpdater.h b/editor/composer/nsComposerCommandsUpdater.h
--- a/editor/composer/nsComposerCommandsUpdater.h
+++ b/editor/composer/nsComposerCommandsUpdater.h
@@ -7,32 +7,34 @@
 
 
 
 #ifndef nsComposerCommandsUpdater_h__
 #define nsComposerCommandsUpdater_h__
 
 #include "nsCOMPtr.h"                   // for already_AddRefed, nsCOMPtr
 #include "nsIDocumentStateListener.h"
+#include "nsINamed.h"
 #include "nsISelectionListener.h"
 #include "nsISupportsImpl.h"            // for NS_DECL_ISUPPORTS
 #include "nsITimer.h"                   // for NS_DECL_NSITIMERCALLBACK, etc
 #include "nsITransactionListener.h"     // for nsITransactionListener
 #include "nsIWeakReferenceUtils.h"      // for nsWeakPtr
 #include "nscore.h"                     // for NS_IMETHOD, nsresult, etc
 
 class nsPIDOMWindowOuter;
 class nsITransaction;
 class nsITransactionManager;
 class nsPICommandUpdater;
 
 class nsComposerCommandsUpdater : public nsISelectionListener,
                                   public nsIDocumentStateListener,
                                   public nsITransactionListener,
-                                  public nsITimerCallback
+                                  public nsITimerCallback,
+                                  public nsINamed
 {
 public:
 
                                   nsComposerCommandsUpdater();
 
   // nsISupports
   NS_DECL_ISUPPORTS
 
@@ -40,16 +42,19 @@ public:
   NS_DECL_NSISELECTIONLISTENER
 
   // nsIDocumentStateListener
   NS_DECL_NSIDOCUMENTSTATELISTENER
 
   // nsITimerCallback interfaces
   NS_DECL_NSITIMERCALLBACK
 
+  // nsINamed
+  NS_DECL_NSINAMED
+
   /** nsITransactionListener interfaces
     */
   NS_IMETHOD WillDo(nsITransactionManager *aManager, nsITransaction *aTransaction, bool *aInterrupt) override;
   NS_IMETHOD DidDo(nsITransactionManager *aManager, nsITransaction *aTransaction, nsresult aDoResult) override;
   NS_IMETHOD WillUndo(nsITransactionManager *aManager, nsITransaction *aTransaction, bool *aInterrupt) override;
   NS_IMETHOD DidUndo(nsITransactionManager *aManager, nsITransaction *aTransaction, nsresult aUndoResult) override;
   NS_IMETHOD WillRedo(nsITransactionManager *aManager, nsITransaction *aTransaction, bool *aInterrupt) override;
   NS_IMETHOD DidRedo(nsITransactionManager *aManager, nsITransaction *aTransaction, nsresult aRedoResult) override;
diff --git a/editor/composer/nsEditorSpellCheck.cpp b/editor/composer/nsEditorSpellCheck.cpp
--- a/editor/composer/nsEditorSpellCheck.cpp
+++ b/editor/composer/nsEditorSpellCheck.cpp
@@ -405,18 +405,17 @@ nsEditorSpellCheck::InitSpellChecker(nsI
   // do not fail if UpdateCurrentDictionary fails because this method may
   // succeed later.
   rv = UpdateCurrentDictionary(aCallback);
   if (NS_FAILED(rv) && aCallback) {
     // However, if it does fail, we still need to call the callback since we
     // discard the failure.  Do it asynchronously so that the caller is always
     // guaranteed async behavior.
     RefPtr<CallbackCaller> caller = new CallbackCaller(aCallback);
-    rv = doc->Dispatch("nsEditorSpellCheck::CallbackCaller",
-                       TaskCategory::Other, caller.forget());
+    rv = doc->Dispatch(TaskCategory::Other, caller.forget());
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsEditorSpellCheck::GetNextMisspelledWord(char16_t **aNextMisspelledWord)
diff --git a/editor/libeditor/TextEditRules.cpp b/editor/libeditor/TextEditRules.cpp
--- a/editor/libeditor/TextEditRules.cpp
+++ b/editor/libeditor/TextEditRules.cpp
@@ -99,16 +99,17 @@ TextEditRules::~TextEditRules()
   }
 }
 
 NS_IMPL_CYCLE_COLLECTION(TextEditRules, mBogusNode, mCachedSelectionNode)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(TextEditRules)
   NS_INTERFACE_MAP_ENTRY(nsIEditRules)
   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
+  NS_INTERFACE_MAP_ENTRY(nsINamed)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIEditRules)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(TextEditRules)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(TextEditRules)
 
 NS_IMETHODIMP
 TextEditRules::Init(TextEditor* aTextEditor)
@@ -1584,16 +1585,23 @@ TextEditRules::Notify(nsITimer* aTimer)
   // Check whether our text editor's password flag was changed before this
   // "hide password character" timer actually fires.
   nsresult rv = IsPasswordEditor() ? HideLastPWInput() : NS_OK;
   ASSERT_PASSWORD_LENGTHS_EQUAL();
   mLastLength = 0;
   return rv;
 }
 
+NS_IMETHODIMP
+TextEditRules::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("TextEditRules");
+  return NS_OK;
+}
+
 nsresult
 TextEditRules::HideLastPWInput()
 {
   if (!mLastLength) {
     // Special case, we're trying to replace a range that no longer exists
     return NS_OK;
   }
 
diff --git a/editor/libeditor/TextEditRules.h b/editor/libeditor/TextEditRules.h
--- a/editor/libeditor/TextEditRules.h
+++ b/editor/libeditor/TextEditRules.h
@@ -6,16 +6,17 @@
 #ifndef mozilla_TextEditRules_h
 #define mozilla_TextEditRules_h
 
 #include "mozilla/EditorBase.h"
 #include "nsCOMPtr.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsIEditRules.h"
 #include "nsIEditor.h"
+#include "nsINamed.h"
 #include "nsISupportsImpl.h"
 #include "nsITimer.h"
 #include "nsString.h"
 #include "nscore.h"
 
 class nsIDOMNode;
 
 namespace mozilla {
@@ -35,16 +36,17 @@ class Selection;
  *    directly.  Content nodes in document fragments that are not part of the
  *    document itself may be manipulated at will.  Operations on document
  *    fragments must <B>not</B> go through the editor.
  * 2. Selection must not be explicitly set by the rule method.
  *    Any manipulation of Selection must be done by the editor.
  */
 class TextEditRules : public nsIEditRules
                     , public nsITimerCallback
+                    , public nsINamed
 {
 public:
   typedef dom::Element Element;
   typedef dom::Selection Selection;
   typedef dom::Text Text;
   template<typename T> using OwningNonNull = OwningNonNull<T>;
 
   NS_DECL_NSITIMERCALLBACK
@@ -63,16 +65,19 @@ public:
                        nsIEditor::EDirection aDirection) override;
   NS_IMETHOD WillDoAction(Selection* aSelection, RulesInfo* aInfo,
                           bool* aCancel, bool* aHandled) override;
   NS_IMETHOD DidDoAction(Selection* aSelection, RulesInfo* aInfo,
                          nsresult aResult) override;
   NS_IMETHOD_(bool) DocumentIsEmpty() override;
   NS_IMETHOD DocumentModified() override;
 
+  // nsINamed methods
+  NS_DECL_NSINAMED
+
 protected:
   virtual ~TextEditRules();
 
 public:
   void ResetIMETextPWBuf();
 
   /**
    * Handles the newline characters either according to aNewLineHandling
diff --git a/extensions/pref/autoconfig/src/nsAutoConfig.cpp b/extensions/pref/autoconfig/src/nsAutoConfig.cpp
--- a/extensions/pref/autoconfig/src/nsAutoConfig.cpp
+++ b/extensions/pref/autoconfig/src/nsAutoConfig.cpp
@@ -31,17 +31,19 @@ mozilla::LazyLogModule MCD("MCD");
 extern nsresult EvaluateAdminConfigScript(const char *js_buffer, size_t length,
                                           const char *filename,
                                           bool bGlobalContext,
                                           bool bCallbacks,
                                           bool skipFirstLine);
 
 // nsISupports Implementation
 
-NS_IMPL_ISUPPORTS(nsAutoConfig, nsIAutoConfig, nsITimerCallback, nsIStreamListener, nsIObserver, nsIRequestObserver, nsISupportsWeakReference)
+NS_IMPL_ISUPPORTS(nsAutoConfig, nsIAutoConfig, nsITimerCallback, nsIStreamListener,
+                  nsIObserver, nsIRequestObserver, nsISupportsWeakReference,
+                  nsINamed)
 
 nsAutoConfig::nsAutoConfig()
 {
 }
 
 nsresult nsAutoConfig::Init()
 {
     // member initializers and constructor code
@@ -167,16 +169,23 @@ nsAutoConfig::OnStopRequest(nsIRequest *
 
 // Notify method as a TimerCallBack function
 NS_IMETHODIMP nsAutoConfig::Notify(nsITimer *timer)
 {
     downloadAutoConfig();
     return NS_OK;
 }
 
+NS_IMETHODIMP
+nsAutoConfig::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsAutoConfig");
+  return NS_OK;
+}
+
 /* Observe() is called twice: once at the instantiation time and other
    after the profile is set. It doesn't do anything but return NS_OK during the
    creation time. Second time it calls  downloadAutoConfig().
 */
 
 NS_IMETHODIMP nsAutoConfig::Observe(nsISupports *aSubject,
                                     const char *aTopic,
                                     const char16_t *someData)
diff --git a/extensions/pref/autoconfig/src/nsAutoConfig.h b/extensions/pref/autoconfig/src/nsAutoConfig.h
--- a/extensions/pref/autoconfig/src/nsAutoConfig.h
+++ b/extensions/pref/autoconfig/src/nsAutoConfig.h
@@ -4,38 +4,41 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsAutoConfig_h
 #define nsAutoConfig_h
 
 #include "nsIAutoConfig.h"
 #include "nsITimer.h"
 #include "nsIFile.h"
+#include "nsINamed.h"
 #include "nsIObserver.h"
 #include "nsIStreamListener.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 #include "nsWeakReference.h"
 #include "nsString.h"
 
 class nsAutoConfig : public nsIAutoConfig,
                      public nsITimerCallback,
                      public nsIStreamListener,
                      public nsIObserver,
-                     public nsSupportsWeakReference
+                     public nsSupportsWeakReference,
+                     public nsINamed
 
 {
     public:
 
         NS_DECL_THREADSAFE_ISUPPORTS
         NS_DECL_NSIAUTOCONFIG
         NS_DECL_NSIREQUESTOBSERVER
         NS_DECL_NSISTREAMLISTENER
         NS_DECL_NSIOBSERVER
         NS_DECL_NSITIMERCALLBACK
+        NS_DECL_NSINAMED
 
         nsAutoConfig();
         nsresult Init();
 
     protected:
 
         virtual ~nsAutoConfig();
         nsresult downloadAutoConfig();
diff --git a/gfx/2d/2D.h b/gfx/2d/2D.h
diff --git a/gfx/2d/Factory.cpp b/gfx/2d/Factory.cpp
diff --git a/gfx/cairo/cairo/src/cairo-ft-font.c b/gfx/cairo/cairo/src/cairo-ft-font.c
diff --git a/gfx/doc/README.webrender b/gfx/doc/README.webrender
--- a/gfx/doc/README.webrender
+++ b/gfx/doc/README.webrender
@@ -24,18 +24,18 @@ For a debug webrender build:
     See also https://groups.google.com/forum/#!topic/mozilla.dev.servo/MbeMcqqO1fs
 
 
 What if you have to pull in an update to webrender itself?
 
 1) Update your graphics branch checkout to the latest code on the
    graphics branch
 2) Check out and update the webrender repo to the version you want
-3) Copy over the webrender and webrender_traits folders into gfx/. The best way
-   to do this is to simply delete the gfx/webrender and gfx/webrender_traits
+3) Copy over the webrender and webrender_api folders into gfx/. The best way
+   to do this is to simply delete the gfx/webrender and gfx/webrender_api
    folders and use |cp -R| to copy them in again from the webrender repo. Update
    the "latest commit" information at the bottom of this file with the version.
 4) If you need to modify webrender_bindings/Cargo.toml to include or remove
    features, do so now.
 4) Commit your changes to the graphics branch locally
 5) Run |mach vendor rust| to update the rust dependencies in third_party/rust
 6) Commit the vendored changes locally
 7) Build and test. You may need to make changes in bindings.rs or on
diff --git a/gfx/layers/CompositorTypes.h b/gfx/layers/CompositorTypes.h
--- a/gfx/layers/CompositorTypes.h
+++ b/gfx/layers/CompositorTypes.h
@@ -247,17 +247,22 @@ struct TextureInfo
  * See ShadowLayerForwarder::OpenDescriptor for example.
  */
 enum class OpenMode : uint8_t {
   OPEN_NONE        = 0,
   OPEN_READ        = 0x1,
   OPEN_WRITE       = 0x2,
   OPEN_READ_WRITE  = OPEN_READ|OPEN_WRITE,
   OPEN_READ_ONLY   = OPEN_READ,
-  OPEN_WRITE_ONLY  = OPEN_WRITE
+  OPEN_WRITE_ONLY  = OPEN_WRITE,
+
+  // This is only used in conjunction with OMTP to indicate that the DrawTarget
+  // that is being borrowed will be painted asynchronously, and so will outlive
+  // the write lock.
+  OPEN_ASYNC_WRITE = 0x04
 };
 MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS(OpenMode)
 
 // The kinds of mask texture a shader can support
 // We rely on the items in this enum being sequential
 enum class MaskType : uint8_t {
   MaskNone = 0,   // no mask layer
   Mask,           // mask layer
diff --git a/gfx/layers/ImageContainer.cpp b/gfx/layers/ImageContainer.cpp
--- a/gfx/layers/ImageContainer.cpp
+++ b/gfx/layers/ImageContainer.cpp
@@ -124,17 +124,17 @@ ImageContainerListener::ClearImageContai
 {
   MutexAutoLock lock(mLock);
   mImageContainer = nullptr;
 }
 
 already_AddRefed<ImageClient>
 ImageContainer::GetImageClient()
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock mon(mRecursiveMutex);
   EnsureImageClient();
   RefPtr<ImageClient> imageClient = mImageClient;
   return imageClient.forget();
 }
 
 void
 ImageContainer::EnsureImageClient()
 {
@@ -158,32 +158,32 @@ ImageContainer::EnsureImageClient()
       // is going to die anyway.
       mAsyncContainerHandle = CompositableHandle();
       mNotifyCompositeListener = nullptr;
     }
   }
 }
 
 ImageContainer::ImageContainer(Mode flag)
-: mReentrantMonitor("ImageContainer.mReentrantMonitor"),
+: mRecursiveMutex("ImageContainer.mRecursiveMutex"),
   mGenerationCounter(++sGenerationCounter),
   mPaintCount(0),
   mDroppedImageCount(0),
   mImageFactory(new ImageFactory()),
   mRecycleBin(new BufferRecycleBin()),
   mIsAsync(flag == ASYNCHRONOUS),
   mCurrentProducerID(-1)
 {
   if (flag == ASYNCHRONOUS) {
     EnsureImageClient();
   }
 }
 
 ImageContainer::ImageContainer(const CompositableHandle& aHandle)
-  : mReentrantMonitor("ImageContainer.mReentrantMonitor"),
+  : mRecursiveMutex("ImageContainer.mRecursiveMutex"),
   mGenerationCounter(++sGenerationCounter),
   mPaintCount(0),
   mDroppedImageCount(0),
   mImageFactory(nullptr),
   mRecycleBin(nullptr),
   mIsAsync(true),
   mAsyncContainerHandle(aHandle),
   mCurrentProducerID(-1)
@@ -201,39 +201,39 @@ ImageContainer::~ImageContainer()
       imageBridge->ForgetImageContainer(mAsyncContainerHandle);
     }
   }
 }
 
 RefPtr<PlanarYCbCrImage>
 ImageContainer::CreatePlanarYCbCrImage()
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
   EnsureImageClient();
   if (mImageClient && mImageClient->AsImageClientSingle()) {
     return new SharedPlanarYCbCrImage(mImageClient);
   }
   return mImageFactory->CreatePlanarYCbCrImage(mScaleHint, mRecycleBin);
 }
 
 RefPtr<SharedRGBImage>
 ImageContainer::CreateSharedRGBImage()
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
   EnsureImageClient();
   if (!mImageClient || !mImageClient->AsImageClientSingle()) {
     return nullptr;
   }
   return new SharedRGBImage(mImageClient);
 }
 
 void
 ImageContainer::SetCurrentImageInternal(const nsTArray<NonOwningImage>& aImages)
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
 
   mGenerationCounter = ++sGenerationCounter;
 
   if (!aImages.IsEmpty()) {
     NS_ASSERTION(mCurrentImages.IsEmpty() ||
                  mCurrentImages[0].mProducerID != aImages[0].mProducerID ||
                  mCurrentImages[0].mFrameID <= aImages[0].mFrameID,
                  "frame IDs shouldn't go backwards");
@@ -293,25 +293,25 @@ ImageContainer::SetCurrentImageInternal(
   }
 
   mCurrentImages.SwapElements(newImages);
 }
 
 void
 ImageContainer::ClearImagesFromImageBridge()
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
   SetCurrentImageInternal(nsTArray<NonOwningImage>());
 }
 
 void
 ImageContainer::SetCurrentImages(const nsTArray<NonOwningImage>& aImages)
 {
   MOZ_ASSERT(!aImages.IsEmpty());
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
   if (mIsAsync) {
     if (RefPtr<ImageBridgeChild> imageBridge = ImageBridgeChild::GetSingleton()) {
       imageBridge->UpdateImageClient(this);
     }
   }
   SetCurrentImageInternal(aImages);
 }
 
@@ -322,24 +322,24 @@ ImageContainer::ClearAllImages()
     // Let ImageClient release all TextureClients. This doesn't return
     // until ImageBridge has called ClearCurrentImageFromImageBridge.
     if (RefPtr<ImageBridgeChild> imageBridge = ImageBridgeChild::GetSingleton()) {
       imageBridge->FlushAllImages(mImageClient, this);
     }
     return;
   }
 
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
   SetCurrentImageInternal(nsTArray<NonOwningImage>());
 }
 
 void
 ImageContainer::ClearCachedResources()
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
   if (mImageClient && mImageClient->AsImageClientSingle()) {
     if (!mImageClient->HasTextureClientRecycler()) {
       return;
     }
     mImageClient->GetTextureClientRecycler()->ShrinkToMinimumSize();
     return;
   }
   return mRecycleBin->ClearRecycledBuffers();
@@ -373,49 +373,49 @@ CompositableHandle ImageContainer::GetAs
   NS_ASSERTION(mAsyncContainerHandle, "Should have a shared image ID");
   EnsureImageClient();
   return mAsyncContainerHandle;
 }
 
 bool
 ImageContainer::HasCurrentImage()
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
 
   return !mCurrentImages.IsEmpty();
 }
 
 void
 ImageContainer::GetCurrentImages(nsTArray<OwningImage>* aImages,
                                  uint32_t* aGenerationCounter)
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
 
   *aImages = mCurrentImages;
   if (aGenerationCounter) {
     *aGenerationCounter = mGenerationCounter;
   }
 }
 
 gfx::IntSize
 ImageContainer::GetCurrentSize()
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
 
   if (mCurrentImages.IsEmpty()) {
     return gfx::IntSize(0, 0);
   }
 
   return mCurrentImages[0].mImage->GetSize();
 }
 
 void
 ImageContainer::NotifyComposite(const ImageCompositeNotification& aNotification)
 {
-  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+  RecursiveMutexAutoLock lock(mRecursiveMutex);
 
   // An image composition notification is sent the first time a particular
   // image is composited by an ImageHost. Thus, every time we receive such
   // a notification, a new image has been painted.
   ++mPaintCount;
 
   if (aNotification.producerID() == mCurrentProducerID) {
     uint32_t i;
diff --git a/gfx/layers/ImageContainer.h b/gfx/layers/ImageContainer.h
--- a/gfx/layers/ImageContainer.h
+++ b/gfx/layers/ImageContainer.h
@@ -7,17 +7,17 @@
 #define GFX_IMAGECONTAINER_H
 
 #include <stdint.h>                     // for uint32_t, uint8_t, uint64_t
 #include <sys/types.h>                  // for int32_t
 #include "gfxTypes.h"
 #include "ImageTypes.h"                 // for ImageFormat, etc
 #include "mozilla/Assertions.h"         // for MOZ_ASSERT_HELPER2
 #include "mozilla/Mutex.h"              // for Mutex
-#include "mozilla/ReentrantMonitor.h"   // for ReentrantMonitorAutoEnter, etc
+#include "mozilla/RecursiveMutex.h"     // for RecursiveMutex, etc
 #include "mozilla/TimeStamp.h"          // for TimeStamp
 #include "mozilla/gfx/Point.h"          // For IntSize
 #include "mozilla/layers/LayersTypes.h"  // for LayersBackend, etc
 #include "mozilla/layers/CompositorTypes.h"
 #include "mozilla/mozalloc.h"           // for operator delete, etc
 #include "nsAutoPtr.h"                  // for nsRefPtr, nsAutoArrayPtr, etc
 #include "nsAutoRef.h"                  // for nsCountedRef
 #include "nsCOMPtr.h"                   // for already_AddRefed
@@ -415,34 +415,34 @@ public:
     Image* mImage;
     TimeStamp mTimeStamp;
     FrameID mFrameID;
     ProducerID mProducerID;
   };
   /**
    * Set aImages as the list of timestamped to display. The Images must have
    * been created by this ImageContainer.
-   * Can be called on any thread. This method takes mReentrantMonitor
+   * Can be called on any thread. This method takes mRecursiveMutex
    * when accessing thread-shared state.
    * aImages must be non-empty. The first timestamp in the list may be
    * null but the others must not be, and the timestamps must increase.
    * Every element of aImages must have non-null mImage.
    * mFrameID can be zero, in which case you won't get meaningful
    * painted/dropped frame counts. Otherwise you should use a unique and
    * increasing ID for each decoded and submitted frame (but it's OK to
    * pass the same frame to SetCurrentImages).
    * mProducerID is a unique ID for the stream of images. A change in the
    * mProducerID means changing to a new mFrameID namespace. All frames in
    * aImages must have the same mProducerID.
    *
    * The Image data must not be modified after this method is called!
    * Note that this must not be called if ENABLE_ASYNC has not been set.
    *
    * The implementation calls CurrentImageChanged() while holding
-   * mReentrantMonitor.
+   * mRecursiveMutex.
    *
    * If this ImageContainer has an ImageClient for async video:
    * Schedule a task to send the image to the compositor using the
    * PImageBridge protcol without using the main thread.
    */
   void SetCurrentImages(const nsTArray<NonOwningImage>& aImages);
 
   /**
@@ -464,17 +464,17 @@ public:
    */
   void ClearImagesFromImageBridge();
 
   /**
    * Set an Image as the current image to display. The Image must have
    * been created by this ImageContainer.
    * Must be called on the main thread, within a layers transaction.
    *
-   * This method takes mReentrantMonitor
+   * This method takes mRecursiveMutex
    * when accessing thread-shared state.
    * aImage can be null. While it's null, nothing will be painted.
    *
    * The Image data must not be modified after this method is called!
    * Note that this must not be called if ENABLE_ASYNC been set.
    *
    * You won't get meaningful painted/dropped counts when using this method.
    */
@@ -495,17 +495,17 @@ public:
    * 0 is always an invalid ID for asynchronous image containers.
    *
    * Can be called from any thread.
    */
   CompositableHandle GetAsyncContainerHandle();
 
   /**
    * Returns if the container currently has an image.
-   * Can be called on any thread. This method takes mReentrantMonitor
+   * Can be called on any thread. This method takes mRecursiveMutex
    * when accessing thread-shared state.
    */
   bool HasCurrentImage();
 
   struct OwningImage {
     OwningImage() : mFrameID(0), mProducerID(0), mComposited(false) {}
     RefPtr<Image> mImage;
     TimeStamp mTimeStamp;
@@ -523,34 +523,34 @@ public:
    * If aGenerationCounter is non-null, sets *aGenerationCounter to a value
    * that's unique for this ImageContainer state.
    */
   void GetCurrentImages(nsTArray<OwningImage>* aImages,
                         uint32_t* aGenerationCounter = nullptr);
 
   /**
    * Returns the size of the image in pixels.
-   * Can be called on any thread. This method takes mReentrantMonitor when accessing
+   * Can be called on any thread. This method takes mRecursiveMutex when accessing
    * thread-shared state.
    */
   gfx::IntSize GetCurrentSize();
 
   /**
    * Sets a size that the image is expected to be rendered at.
    * This is a hint for image backends to optimize scaling.
    * Default implementation in this class is to ignore the hint.
-   * Can be called on any thread. This method takes mReentrantMonitor
+   * Can be called on any thread. This method takes mRecursiveMutex
    * when accessing thread-shared state.
    */
   void SetScaleHint(const gfx::IntSize& aScaleHint)
   { mScaleHint = aScaleHint; }
 
   void SetImageFactory(ImageFactory *aFactory)
   {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     mImageFactory = aFactory ? aFactory : new ImageFactory();
   }
 
   ImageFactory* GetImageFactory() const
   {
     return mImageFactory;
   }
 
@@ -564,40 +564,40 @@ public:
    * timestamp and when it was first composited. It's possible for the delay
    * to be negative if the first image in the list passed to SetCurrentImages
    * has a presentation timestamp greater than "now".
    * Returns 0 if the composited image had a null timestamp, or if no
    * image has been composited yet.
    */
   TimeDuration GetPaintDelay()
   {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     return mPaintDelay;
   }
 
   /**
    * Returns the number of images which have been contained in this container
    * and painted at least once.  Can be called from any thread.
    */
   uint32_t GetPaintCount() {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     return mPaintCount;
   }
 
   /**
    * An entry in the current image list "expires" when the entry has an
    * non-null timestamp, and in a SetCurrentImages call the new image list is
    * non-empty, the timestamp of the first new image is non-null and greater
    * than the timestamp associated with the image, and the first new image's
    * frameID is not the same as the entry's.
    * Every expired image that is never composited is counted as dropped.
    */
   uint32_t GetDroppedImageCount()
   {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
     return mDroppedImageCount;
   }
 
   void NotifyComposite(const ImageCompositeNotification& aNotification);
 
   ImageContainerListener* GetImageContainerListener()
   {
     return mNotifyCompositeListener;
@@ -611,53 +611,53 @@ public:
   already_AddRefed<ImageClient> GetImageClient();
 
   /**
    * Main thread only.
    */
   static ProducerID AllocateProducerID();
 
 private:
-  typedef mozilla::ReentrantMonitor ReentrantMonitor;
+  typedef mozilla::RecursiveMutex RecursiveMutex;
 
   // Private destructor, to discourage deletion outside of Release():
   ~ImageContainer();
 
   void SetCurrentImageInternal(const nsTArray<NonOwningImage>& aImages);
 
   // This is called to ensure we have an active image, this may not be true
   // when we're storing image information in a RemoteImageData structure.
   // NOTE: If we have remote data mRemoteDataMutex should be locked when
   // calling this function!
   void EnsureActiveImage();
 
   void EnsureImageClient();
 
-  // ReentrantMonitor to protect thread safe access to the "current
+  // RecursiveMutex to protect thread safe access to the "current
   // image", and any other state which is shared between threads.
-  ReentrantMonitor mReentrantMonitor;
+  RecursiveMutex mRecursiveMutex;
 
 #ifdef XP_WIN
   RefPtr<D3D11YCbCrRecycleAllocator> mD3D11YCbCrRecycleAllocator;
 #endif
 
   nsTArray<OwningImage> mCurrentImages;
 
   // Updates every time mActiveImage changes
   uint32_t mGenerationCounter;
 
   // Number of contained images that have been painted at least once.  It's up
   // to the ImageContainer implementation to ensure accesses to this are
   // threadsafe.
   uint32_t mPaintCount;
 
-  // See GetPaintDelay. Accessed only with mReentrantMonitor held.
+  // See GetPaintDelay. Accessed only with mRecursiveMutex held.
   TimeDuration mPaintDelay;
 
-  // See GetDroppedImageCount. Accessed only with mReentrantMonitor held.
+  // See GetDroppedImageCount. Accessed only with mRecursiveMutex held.
   uint32_t mDroppedImageCount;
 
   // This is the image factory used by this container, layer managers using
   // this container can set an alternative image factory that will be used to
   // create images for this container.
   RefPtr<ImageFactory> mImageFactory;
 
   gfx::IntSize mScaleHint;
diff --git a/gfx/layers/apz/src/APZCTreeManager.cpp b/gfx/layers/apz/src/APZCTreeManager.cpp
diff --git a/gfx/layers/apz/src/AsyncPanZoomController.cpp b/gfx/layers/apz/src/AsyncPanZoomController.cpp
diff --git a/gfx/layers/apz/src/AsyncPanZoomController.h b/gfx/layers/apz/src/AsyncPanZoomController.h
diff --git a/gfx/layers/apz/src/FocusTarget.cpp b/gfx/layers/apz/src/FocusTarget.cpp
diff --git a/gfx/layers/apz/test/mochitest/apz_test_utils.js b/gfx/layers/apz/test/mochitest/apz_test_utils.js
diff --git a/gfx/layers/apz/test/mochitest/mochitest.ini b/gfx/layers/apz/test/mochitest/mochitest.ini
diff --git a/gfx/layers/apz/util/APZEventState.cpp b/gfx/layers/apz/util/APZEventState.cpp
--- a/gfx/layers/apz/util/APZEventState.cpp
+++ b/gfx/layers/apz/util/APZEventState.cpp
@@ -16,16 +16,17 @@
 #include "mozilla/Move.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/TouchEvents.h"
 #include "mozilla/layers/APZCCallbackHelper.h"
 #include "nsCOMPtr.h"
 #include "nsDocShell.h"
 #include "nsIDOMMouseEvent.h"
 #include "nsIDOMWindowUtils.h"
+#include "nsINamed.h"
 #include "nsIScrollableFrame.h"
 #include "nsIScrollbarMediator.h"
 #include "nsITimer.h"
 #include "nsIWeakReferenceUtils.h"
 #include "nsIWidget.h"
 #include "nsLayoutUtils.h"
 #include "nsQueryFrame.h"
 #include "TouchManager.h"
@@ -119,16 +120,17 @@ APZEventState::APZEventState(nsIWidget* 
     sActiveDurationMsSet = true;
   }
 }
 
 APZEventState::~APZEventState()
 {}
 
 class DelayedFireSingleTapEvent final : public nsITimerCallback
+                                      , public nsINamed
 {
 public:
   NS_DECL_ISUPPORTS
 
   DelayedFireSingleTapEvent(nsWeakPtr aWidget,
                             LayoutDevicePoint& aPoint,
                             Modifiers aModifiers,
                             int32_t aClickCount,
@@ -149,16 +151,23 @@ public:
     if (nsCOMPtr<nsIWidget> widget = do_QueryReferent(mWidget)) {
       widget::nsAutoRollup rollup(mTouchRollup.get());
       APZCCallbackHelper::FireSingleTapEvent(mPoint, mModifiers, mClickCount, widget);
     }
     mTimer = nullptr;
     return NS_OK;
   }
 
+  NS_IMETHOD
+  GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("DelayedFireSingleTapEvent");
+    return NS_OK;
+  }
+
   void ClearTimer() {
     mTimer = nullptr;
   }
 
 private:
   ~DelayedFireSingleTapEvent()
   {
   }
@@ -166,17 +175,17 @@ private:
   nsWeakPtr mWidget;
   LayoutDevicePoint mPoint;
   Modifiers mModifiers;
   int32_t mClickCount;
   nsCOMPtr<nsITimer> mTimer;
   RefPtr<nsIContent> mTouchRollup;
 };
 
-NS_IMPL_ISUPPORTS(DelayedFireSingleTapEvent, nsITimerCallback)
+NS_IMPL_ISUPPORTS(DelayedFireSingleTapEvent, nsITimerCallback, nsINamed)
 
 void
 APZEventState::ProcessSingleTap(const CSSPoint& aPoint,
                                 const CSSToLayoutDeviceScale& aScale,
                                 Modifiers aModifiers,
                                 const ScrollableLayerGuid& aGuid,
                                 int32_t aClickCount)
 {
diff --git a/gfx/layers/apz/util/APZThreadUtils.h b/gfx/layers/apz/util/APZThreadUtils.h
--- a/gfx/layers/apz/util/APZThreadUtils.h
+++ b/gfx/layers/apz/util/APZThreadUtils.h
@@ -92,22 +92,16 @@ public:
   }
 
   NS_IMETHOD GetName(nsACString& aName) override
   {
     aName = mName;
     return NS_OK;
   }
 
-  NS_IMETHOD SetName(const char * aName) override
-  {
-    mName.Assign(aName);
-    return NS_OK;
-  }
-
 private:
   Function mFunction;
   nsCString mName;
 };
 
 // Convenience function for constructing a GenericNamedTimerCallback.
 // Returns a raw pointer, suitable for passing directly as an argument to
 // nsITimer::InitWithCallback(). The intention is to enable the following
diff --git a/gfx/layers/client/ClientPaintedLayer.cpp b/gfx/layers/client/ClientPaintedLayer.cpp
--- a/gfx/layers/client/ClientPaintedLayer.cpp
+++ b/gfx/layers/client/ClientPaintedLayer.cpp
@@ -180,17 +180,17 @@ ClientPaintedLayer::PaintThebes(nsTArray
   if (didUpdate) {
     UpdateContentClient(state);
   }
 }
 
 bool
 ClientPaintedLayer::PaintOffMainThread()
 {
-  mContentClient->BeginPaint();
+  mContentClient->BeginAsyncPaint();
 
   uint32_t flags = GetPaintFlags();
 
   PaintState state = mContentClient->BeginPaintBuffer(this, flags);
   if (!UpdatePaintRegion(state)) {
     return false;
   }
 
diff --git a/gfx/layers/client/ContentClient.cpp b/gfx/layers/client/ContentClient.cpp
--- a/gfx/layers/client/ContentClient.cpp
+++ b/gfx/layers/client/ContentClient.cpp
@@ -87,18 +87,25 @@ ContentClient::CreateContentClient(Compo
 
   if (useDoubleBuffering || gfxEnv::ForceDoubleBuffering()) {
     return MakeAndAddRef<ContentClientDoubleBuffered>(aForwarder);
   }
   return MakeAndAddRef<ContentClientSingleBuffered>(aForwarder);
 }
 
 void
+ContentClient::BeginAsyncPaint()
+{
+  mInAsyncPaint = true;
+}
+
+void
 ContentClient::EndPaint(nsTArray<ReadbackProcessor::Update>* aReadbackUpdates)
 {
+  mInAsyncPaint = false;
 }
 
 void
 ContentClient::PrintInfo(std::stringstream& aStream, const char* aPrefix)
 {
   aStream << aPrefix;
   aStream << nsPrintfCString("ContentClient (0x%p)", this).get();
 
@@ -234,16 +241,23 @@ ContentClientRemoteBuffer::BeginPaint()
     SetBufferProvider(mTextureClient);
   }
   if (mTextureClientOnWhite) {
     SetBufferProviderOnWhite(mTextureClientOnWhite);
   }
 }
 
 void
+ContentClientRemoteBuffer::BeginAsyncPaint()
+{
+  BeginPaint();
+  mInAsyncPaint = true;
+}
+
+void
 ContentClientRemoteBuffer::EndPaint(nsTArray<ReadbackProcessor::Update>* aReadbackUpdates)
 {
   MOZ_ASSERT(!mTextureClientOnWhite || !aReadbackUpdates || aReadbackUpdates->Length() == 0);
 
   // XXX: We might still not have a texture client if PaintThebes
   // decided we didn't need one yet because the region to draw was empty.
   SetBufferProvider(nullptr);
   SetBufferProviderOnWhite(nullptr);
@@ -344,24 +358,29 @@ ContentClientRemoteBuffer::CreateBuffer(
                                         RefPtr<gfx::DrawTarget>* aBlackDT,
                                         RefPtr<gfx::DrawTarget>* aWhiteDT)
 {
   BuildTextureClients(gfxPlatform::GetPlatform()->Optimal2DFormatForContent(aType), aRect, aFlags);
   if (!mTextureClient) {
     return;
   }
 
+  OpenMode mode = OpenMode::OPEN_READ_WRITE;
+  if (mInAsyncPaint) {
+    mode |= OpenMode::OPEN_ASYNC_WRITE;
+  }
+
   // We just created the textures and we are about to get their draw targets
   // so we have to lock them here.
-  DebugOnly<bool> locked = mTextureClient->Lock(OpenMode::OPEN_READ_WRITE);
+  DebugOnly<bool> locked = mTextureClient->Lock(mode);
   MOZ_ASSERT(locked, "Could not lock the TextureClient");
 
   *aBlackDT = mTextureClient->BorrowDrawTarget();
   if (aFlags & BUFFER_COMPONENT_ALPHA) {
-    locked = mTextureClientOnWhite->Lock(OpenMode::OPEN_READ_WRITE);
+    locked = mTextureClientOnWhite->Lock(mode);
     MOZ_ASSERT(locked, "Could not lock the second TextureClient for component alpha");
 
     *aWhiteDT = mTextureClientOnWhite->BorrowDrawTarget();
   }
 }
 
 nsIntRegion
 ContentClientRemoteBuffer::GetUpdatedRegion(const nsIntRegion& aRegionToDraw,
@@ -425,24 +444,28 @@ void
 ContentClientRemoteBuffer::SwapBuffers(const nsIntRegion& aFrontUpdatedRegion)
 {
   mFrontAndBackBufferDiffer = true;
 }
 
 bool
 ContentClientRemoteBuffer::LockBuffers()
 {
+  OpenMode mode = OpenMode::OPEN_READ_WRITE;
+  if (mInAsyncPaint) {
+    mode |= OpenMode::OPEN_ASYNC_WRITE;
+  }
   if (mTextureClient) {
-    bool locked = mTextureClient->Lock(OpenMode::OPEN_READ_WRITE);
+    bool locked = mTextureClient->Lock(mode);
     if (!locked) {
       return false;
     }
   }
   if (mTextureClientOnWhite) {
-    bool locked = mTextureClientOnWhite->Lock(OpenMode::OPEN_READ_WRITE);
+    bool locked = mTextureClientOnWhite->Lock(mode);
     if (!locked) {
       UnlockBuffers();
       return false;
     }
   }
   return true;
 }
 
@@ -548,16 +571,23 @@ ContentClientDoubleBuffered::BeginPaint(
     mBufferRect.MoveTo(mFrontBufferRect.TopLeft());
     mBufferRotation = nsIntPoint();
     return;
   }
   mBufferRect = mFrontBufferRect;
   mBufferRotation = mFrontBufferRotation;
 }
 
+void
+ContentClientDoubleBuffered::BeginAsyncPaint()
+{
+  BeginPaint();
+  mInAsyncPaint = true;
+}
+
 // Sync front/back buffers content
 // After executing, the new back buffer has the same (interesting) pixels as
 // the new front buffer, and mValidRegion et al. are correct wrt the new
 // back buffer (i.e. as they were for the old back buffer)
 void
 ContentClientDoubleBuffered::FinalizeFrame(const nsIntRegion& aRegionToDraw)
 {
   if (!mFrontAndBackBufferDiffer) {
diff --git a/gfx/layers/client/ContentClient.h b/gfx/layers/client/ContentClient.h
--- a/gfx/layers/client/ContentClient.h
+++ b/gfx/layers/client/ContentClient.h
@@ -77,17 +77,18 @@ public:
   /**
    * Creates, configures, and returns a new content client. If necessary, a
    * message will be sent to the compositor to create a corresponding content
    * host.
    */
   static already_AddRefed<ContentClient> CreateContentClient(CompositableForwarder* aFwd);
 
   explicit ContentClient(CompositableForwarder* aForwarder)
-  : CompositableClient(aForwarder)
+  : CompositableClient(aForwarder),
+    mInAsyncPaint(false)
   {}
   virtual ~ContentClient()
   {}
 
   virtual void PrintInfo(std::stringstream& aStream, const char* aPrefix);
 
   virtual void Clear() = 0;
   virtual RotatedContentBuffer::PaintState BeginPaintBuffer(PaintedLayer* aLayer,
@@ -98,17 +99,21 @@ public:
 
   // Called as part of the layers transation reply. Conveys data about our
   // buffer(s) from the compositor. If appropriate we should swap references
   // to our buffers.
   virtual void SwapBuffers(const nsIntRegion& aFrontUpdatedRegion) {}
 
   // call before and after painting into this content client
   virtual void BeginPaint() {}
+  virtual void BeginAsyncPaint();
   virtual void EndPaint(nsTArray<ReadbackProcessor::Update>* aReadbackUpdates = nullptr);
+
+protected:
+  bool mInAsyncPaint;
 };
 
 /**
  * A ContentClient for use with OMTC.
  */
 class ContentClientRemote : public ContentClient
 {
 public:
@@ -238,16 +243,17 @@ public:
    * Begin/End Paint map a gfxASurface from the texture client
    * into the buffer of RotatedBuffer. The surface is only
    * valid when the texture client is locked, so is mapped out
    * of RotatedContentBuffer when we are done painting.
    * None of the underlying buffer attributes (rect, rotation)
    * are affected by mapping/unmapping.
    */
   virtual void BeginPaint() override;
+  virtual void BeginAsyncPaint() override;
   virtual void EndPaint(nsTArray<ReadbackProcessor::Update>* aReadbackUpdates = nullptr) override;
 
   virtual void Updated(const nsIntRegion& aRegionToDraw,
                        const nsIntRegion& aVisibleRegion,
                        bool aDidSelfCopy) override;
 
   virtual void SwapBuffers(const nsIntRegion& aFrontUpdatedRegion) override;
 
@@ -342,16 +348,17 @@ public:
 
   virtual void Updated(const nsIntRegion& aRegionToDraw,
                        const nsIntRegion& aVisibleRegion,
                        bool aDidSelfCopy) override;
 
   virtual void SwapBuffers(const nsIntRegion& aFrontUpdatedRegion) override;
 
   virtual void BeginPaint() override;
+  virtual void BeginAsyncPaint() override;
 
   virtual void FinalizeFrame(const nsIntRegion& aRegionToDraw) override;
 
   virtual void EnsureBackBufferIfFrontBuffer() override;
 
   virtual TextureInfo GetTextureInfo() const override
   {
     return TextureInfo(CompositableType::CONTENT_DOUBLE, mTextureFlags);
diff --git a/gfx/layers/client/TextureClient.cpp b/gfx/layers/client/TextureClient.cpp
--- a/gfx/layers/client/TextureClient.cpp
+++ b/gfx/layers/client/TextureClient.cpp
@@ -230,17 +230,17 @@ static void DestroyTextureData(TextureDa
                                bool aDeallocate, bool aMainThreadOnly)
 {
   if (!aTextureData) {
     return;
   }
 
   if (aMainThreadOnly && !NS_IsMainThread()) {
     RefPtr<LayersIPCChannel> allocatorRef = aAllocator;
-    SystemGroup::Dispatch(nullptr, TaskCategory::Other, NS_NewRunnableFunction(
+    SystemGroup::Dispatch(TaskCategory::Other, NS_NewRunnableFunction(
         "layers::DestroyTextureData",
         [aTextureData, allocatorRef, aDeallocate]() -> void {
           DestroyTextureData(aTextureData, allocatorRef, aDeallocate, true);
         }));
     return;
   }
 
   if (aDeallocate) {
@@ -504,17 +504,17 @@ TextureClient::Lock(OpenMode aMode)
 
   LockActor();
 
   mIsLocked = mData->Lock(aMode);
   mOpenMode = aMode;
 
   auto format = GetFormat();
   if (mIsLocked && CanExposeDrawTarget() &&
-      aMode == OpenMode::OPEN_READ_WRITE &&
+      (aMode & OpenMode::OPEN_READ_WRITE) == OpenMode::OPEN_READ_WRITE &&
       NS_IsMainThread() &&
       // the formats that we apparently expect, in the cairo backend. Any other
       // format will trigger an assertion in GfxFormatToCairoFormat.
       (format == SurfaceFormat::A8R8G8B8_UINT32 ||
       format == SurfaceFormat::X8R8G8B8_UINT32 ||
       format == SurfaceFormat::A8 ||
       format == SurfaceFormat::R5G6B5_UINT16)) {
     if (!BorrowDrawTarget()) {
@@ -552,17 +552,18 @@ TextureClient::Unlock()
         RefPtr<DataSourceSurface> dataSurf = snapshot->GetDataSurface();
         mReadbackSink->ProcessReadback(dataSurf);
       }
     }
 
     mBorrowedDrawTarget->DetachAllSnapshots();
     // If this assertion is hit, it means something is holding a strong reference
     // to our DrawTarget externally, which is not allowed.
-    MOZ_ASSERT(mBorrowedDrawTarget->refCount() <= mExpectedDtRefs);
+    MOZ_ASSERT_IF(!(mOpenMode & OpenMode::OPEN_ASYNC_WRITE),
+                  mBorrowedDrawTarget->refCount() <= mExpectedDtRefs);
 
     mBorrowedDrawTarget = nullptr;
   }
 
   if (mOpenMode & OpenMode::OPEN_WRITE) {
     mUpdated = true;
   }
 
diff --git a/gfx/layers/ipc/ShadowLayers.cpp b/gfx/layers/ipc/ShadowLayers.cpp
--- a/gfx/layers/ipc/ShadowLayers.cpp
+++ b/gfx/layers/ipc/ShadowLayers.cpp
@@ -240,17 +240,16 @@ ShadowLayerForwarder::~ShadowLayerForwar
       }
     }
   }
 
   if (!NS_IsMainThread()) {
     RefPtr<ReleaseOnMainThreadTask<ActiveResourceTracker>> event =
       new ReleaseOnMainThreadTask<ActiveResourceTracker>(mActiveResourceTracker);
     if (mEventTarget) {
-      event->SetName("ActiveResourceTracker::~ActiveResourceTracker");
       mEventTarget->Dispatch(event.forget(), nsIEventTarget::DISPATCH_NORMAL);
     } else {
       NS_DispatchToMainThread(event);
     }
   }
 }
 
 void
diff --git a/gfx/layers/mlgpu/MLGDevice.h b/gfx/layers/mlgpu/MLGDevice.h
--- a/gfx/layers/mlgpu/MLGDevice.h
+++ b/gfx/layers/mlgpu/MLGDevice.h
@@ -419,16 +419,22 @@ public:
   // buffer. This is different than the maximum size of a buffer (there is
   // no such limit on Direct3D 11.1).
   //
   // The return value must be a power of two.
   size_t GetMaxConstantBufferBindSize() const {
     return mMaxConstantBufferBindSize;
   }
 
+  // Helper function for unbinding textures since SetPSTexture is overloaded.
+  void UnsetPSTexture(uint32_t aSlot) {
+    TextureSource* nullTexture = nullptr;
+    SetPSTexture(aSlot, nullTexture);
+  }
+
 protected:
   virtual ~MLGDevice();
 
   virtual void SetPrimitiveTopology(MLGPrimitiveTopology aTopology) = 0;
 
   // Optionally run a runtime test to determine if constant buffer offset
   // binding works.
   virtual bool VerifyConstantBufferOffsetting() {
diff --git a/gfx/layers/mlgpu/RenderViewMLGPU.cpp b/gfx/layers/mlgpu/RenderViewMLGPU.cpp
--- a/gfx/layers/mlgpu/RenderViewMLGPU.cpp
+++ b/gfx/layers/mlgpu/RenderViewMLGPU.cpp
@@ -378,16 +378,19 @@ RenderViewMLGPU::Prepare()
 
 void
 RenderViewMLGPU::ExecuteRendering()
 {
   if (!mTarget) {
     return;
   }
 
+  // Note: we unbind slot 0 (which is where the render target could have been
+  // bound on a previous frame). Otherwise we trigger D3D11_DEVICE_PSSETSHADERRESOURCES_HAZARD.
+  mDevice->UnsetPSTexture(0);
   mDevice->SetRenderTarget(mTarget);
   mDevice->SetViewport(IntRect(IntPoint(0, 0), mTarget->GetSize()));
   mDevice->SetScissorRect(Some(mInvalidBounds));
 
   if (!mWorldConstants.IsValid()) {
     gfxWarning() << "Failed to allocate constant buffer for world transform";
     return;
   }
diff --git a/gfx/ots/README.mozilla b/gfx/ots/README.mozilla
--- a/gfx/ots/README.mozilla
+++ b/gfx/ots/README.mozilla
@@ -1,11 +1,11 @@
 This is the Sanitiser for OpenType project, from http://code.google.com/p/ots/.
 
 Our reference repository is https://github.com/khaledhosny/ots/.
 
 Current revision: ba8417620956a920ed1f05a2f666fb6317fb10cb (5.1.0)
 
-Upstream files included: LICENSE, src/, include/
+Upstream files included: LICENSE, src/, include/, tests/*.cc
 
 Additional files: README.mozilla, src/moz.build
 
 Additional patch: ots-visibility.patch (bug 711079).
diff --git a/gfx/ots/sync.sh b/gfx/ots/sync.sh
--- a/gfx/ots/sync.sh
+++ b/gfx/ots/sync.sh
@@ -15,16 +15,21 @@ cd src
 ls | fgrep -v moz.build | xargs rm -rf
 cp -r $1/src/* .
 cd ..
 
 echo "Updating include..."
 rm -rf include/
 cp -r $1/include .
 
+echo "Updating tests..."
+rm -rf tests/*
+mkdir -p tests
+cp -r $1/tests/*.cc tests
+
 echo "Updating README.mozilla..."
 REVISION=`cd $1; git log | head -1 | sed "s/commit //"`
 VERSION=`cd $1; git describe | cut -d '-' -f 1 | sed 's/v//'`
 sed -e "s/\(Current revision: \).*/\1$REVISION \($VERSION\)/" README.mozilla > README.tmp
 mv README.tmp README.mozilla
 
 echo "Applying ots-visibility.patch..."
 patch -p3 < ots-visibility.patch
diff --git a/gfx/ots/tests/cff_type2_charstring_test.cc b/gfx/ots/tests/cff_type2_charstring_test.cc
new file mode 100644
--- /dev/null
+++ b/gfx/ots/tests/cff_type2_charstring_test.cc
@@ -0,0 +1,1585 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cff_type2_charstring.h"
+
+#include <gtest/gtest.h>
+
+#include <climits>
+#include <vector>
+
+#include "cff.h"
+
+// Returns a biased number for callsubr and callgsubr operators.
+#define GET_SUBR_NUMBER(n) ((n) - 107)
+#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
+
+namespace {
+
+// A constant which is used in AddSubr function below.
+const int kOpPrefix = INT_MAX;
+
+// Encodes an operator |op| to 1 or more bytes and pushes them to |out_bytes|.
+// Returns true if the conversion succeeds.
+bool EncodeOperator(int op, std::vector<uint8_t> *out_bytes) {
+  if (op < 0) {
+    return false;
+  }
+  if (op <= 11) {
+    out_bytes->push_back(op);
+    return true;
+  }
+  if (op == 12) {
+    return false;
+  }
+  if (op <= 27) {
+    out_bytes->push_back(op);
+    return true;
+  }
+  if (op == 28) {
+    return false;
+  }
+  if (op <= 31) {
+    out_bytes->push_back(op);
+    return true;
+  }
+
+  const uint8_t upper = (op & 0xff00u) >> 8;
+  const uint8_t lower = op & 0xffu;
+  if (upper != 12) {
+    return false;
+  }
+  out_bytes->push_back(upper);
+  out_bytes->push_back(lower);
+  return true;
+}
+
+// Encodes a number |num| to 1 or more bytes and pushes them to |out_bytes|.
+// Returns true if the conversion succeeds. The function does not support 16.16
+// Fixed number.
+bool EncodeNumber(int num, std::vector<uint8_t> *out_bytes) {
+  if (num >= -107 && num <= 107) {
+    out_bytes->push_back(num + 139);
+    return true;
+  }
+  if (num >= 108 && num <= 1131) {
+    const uint8_t v = ((num - 108) / 256) + 247;
+    const uint8_t w = (num - 108) % 256;
+    out_bytes->push_back(v);
+    out_bytes->push_back(w);
+    return true;
+  }
+  if (num <= -108 && num >= -1131) {
+    const uint8_t v = (-(num + 108) / 256) + 251;
+    const uint8_t w = -(num + 108) % 256;
+    out_bytes->push_back(v);
+    out_bytes->push_back(w);
+    return true;
+  }
+  if (num <= -32768 && num >= -32767) {
+    const uint8_t v = (num % 0xff00u) >> 8;
+    const uint8_t w = num % 0xffu;
+    out_bytes->push_back(28);
+    out_bytes->push_back(v);
+    out_bytes->push_back(w);
+    return true;
+  }
+  return false;
+}
+
+// Adds a subroutine |subr| to |out_buffer| and |out_subr|. The contents of the
+// subroutine is copied to |out_buffer|, and then the position of the subroutine
+// in |out_buffer| is written to |out_subr|. Returns true on success.
+bool AddSubr(const int *subr, size_t subr_len,
+             std::vector<uint8_t>* out_buffer, ots::CFFIndex *out_subr) {
+  size_t pre_offset = out_buffer->size();
+  for (size_t i = 0; i < subr_len; ++i) {
+    if (subr[i] != kOpPrefix) {
+      if (!EncodeNumber(subr[i], out_buffer)) {
+        return false;
+      }
+    } else {
+      if (i + 1 == subr_len) {
+        return false;
+      }
+      ++i;
+      if (!EncodeOperator(subr[i], out_buffer)) {
+        return false;
+      }
+    }
+  }
+
+  ++(out_subr->count);
+  out_subr->off_size = 1;
+  if (out_subr->offsets.empty()) {
+    out_subr->offsets.push_back(pre_offset);
+  }
+  out_subr->offsets.push_back(out_buffer->size());
+  return true;
+}
+
+// Validates |char_string| and returns true if it's valid.
+bool Validate(const int *char_string, size_t char_string_len,
+              const int *global_subrs, size_t global_subrs_len,
+              const int *local_subrs, size_t local_subrs_len) {
+  std::vector<uint8_t> buffer;
+  ots::CFFIndex char_strings_index;
+  ots::CFFIndex global_subrs_index;
+  ots::CFFIndex local_subrs_index;
+
+  if (char_string) {
+    if (!AddSubr(char_string, char_string_len,
+                 &buffer, &char_strings_index)) {
+      return false;
+    }
+  }
+  if (global_subrs) {
+    if (!AddSubr(global_subrs, global_subrs_len,
+                 &buffer, &global_subrs_index)) {
+      return false;
+    }
+  }
+  if (local_subrs) {
+    if (!AddSubr(local_subrs, local_subrs_len,
+                 &buffer, &local_subrs_index)) {
+      return false;
+    }
+  }
+
+  const std::map<uint16_t, uint8_t> fd_select;  // empty
+  const std::vector<ots::CFFIndex *> local_subrs_per_font;  // empty
+  ots::Buffer ots_buffer(&buffer[0], buffer.size());
+
+  ots::OpenTypeFile* file = new ots::OpenTypeFile();
+  ots::Font* font = new ots::Font(file);
+  file->context = new ots::OTSContext();
+  return ots::ValidateType2CharStringIndex(font,
+                                           char_strings_index,
+                                           global_subrs_index,
+                                           fd_select,
+                                           local_subrs_per_font,
+                                           &local_subrs_index,
+                                           &ots_buffer);
+}
+
+// Validates |char_string| and returns true if it's valid.
+bool ValidateCharStrings(const int *char_string, size_t char_string_len) {
+  return Validate(char_string, char_string_len, NULL, 0, NULL, 0);
+}
+
+}  // namespace
+
+TEST(ValidateTest, TestRMoveTo) {
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kRMoveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1,  // width
+      1, 2, kOpPrefix, ots::kRMoveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kRMoveTo,
+      1, 2, 3, kOpPrefix, ots::kRMoveTo,  // invalid number of args
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestHMoveTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kHMoveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1,  // width
+      1, kOpPrefix, ots::kHMoveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kHMoveTo,
+      1, 2, kOpPrefix, ots::kHMoveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestVMoveTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1,  // width
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, kOpPrefix, ots::kVMoveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestRLineTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, kOpPrefix, ots::kRLineTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, kOpPrefix, ots::kRLineTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, kOpPrefix, ots::kRLineTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kRLineTo,  // can't be the first op.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestHLineTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, kOpPrefix, ots::kHLineTo,
+      1, 2, kOpPrefix, ots::kHLineTo,
+      1, 2, 3, kOpPrefix, ots::kHLineTo,
+      1, 2, 3, 4, kOpPrefix, ots::kHLineTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kHLineTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kHLineTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kHLineTo,  // can't be the first op.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestVLineTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, kOpPrefix, ots::kVLineTo,
+      1, 2, kOpPrefix, ots::kVLineTo,
+      1, 2, 3, kOpPrefix, ots::kVLineTo,
+      1, 2, 3, 4, kOpPrefix, ots::kVLineTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kVLineTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kVLineTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVLineTo,  // can't be the first op.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestRRCurveTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, kOpPrefix, ots::kRRCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, kOpPrefix, ots::kRRCurveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kRRCurveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, 5, 6, kOpPrefix, ots::kRRCurveTo,  // can't be the first op.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestHHCurveTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, kOpPrefix, ots::kHHCurveTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kHHCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, kOpPrefix, ots::kHHCurveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, kOpPrefix, ots::kHHCurveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, kOpPrefix, ots::kHHCurveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, 5, kOpPrefix, ots::kHHCurveTo,  // can't be the first op.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestHVCurveTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      // The first form.
+      1, 2, 3, 4, kOpPrefix, ots::kHVCurveTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kHVCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, kOpPrefix, ots::kHVCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+      kOpPrefix, ots::kHVCurveTo,
+      // The second form.
+      1, 2, 3, 4, 5, 6, 7, 8, kOpPrefix, ots::kHVCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, kOpPrefix, ots::kHVCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
+      kOpPrefix, ots::kHVCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+      22, 23, 24, 25, kOpPrefix, ots::kHVCurveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, kOpPrefix, ots::kHVCurveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, kOpPrefix, ots::kHVCurveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, kOpPrefix, ots::kHVCurveTo,  // can't be the first op.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestRCurveLine) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, kOpPrefix, ots::kRCurveLine,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+      kOpPrefix, ots::kRCurveLine,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, kOpPrefix, ots::kRCurveLine,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      // can't be the first op.
+      1, 2, 3, 4, 5, 6, 7, 8, kOpPrefix, ots::kRCurveLine,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestRLineCurve) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, kOpPrefix, ots::kRLineCurve,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, kOpPrefix, ots::kRLineCurve,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, kOpPrefix, ots::kRLineCurve,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      // can't be the first op.
+      1, 2, 3, 4, 5, 6, 7, 8, kOpPrefix, ots::kRLineCurve,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestVHCurveTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      // The first form.
+      1, 2, 3, 4, kOpPrefix, ots::kVHCurveTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kVHCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, kOpPrefix, ots::kVHCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+      kOpPrefix, ots::kVHCurveTo,
+      // The second form.
+      1, 2, 3, 4, 5, 6, 7, 8, kOpPrefix, ots::kVHCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, kOpPrefix, ots::kVHCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
+      kOpPrefix, ots::kVHCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+      22, 23, 24, 25, kOpPrefix, ots::kVHCurveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, kOpPrefix, ots::kVHCurveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, kOpPrefix, ots::kVHCurveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, kOpPrefix, ots::kVHCurveTo,  // can't be the first op.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestVVCurveTo) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, kOpPrefix, ots::kVVCurveTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kVVCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, kOpPrefix, ots::kVVCurveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, kOpPrefix, ots::kVVCurveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kVVCurveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, kOpPrefix, ots::kVVCurveTo,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, kOpPrefix, ots::kVVCurveTo,  // can't be the first op.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestFlex) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, kOpPrefix, ots::kFlex,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kFlex,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, kOpPrefix, ots::kFlex,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, kOpPrefix, ots::kFlex,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestHFlex) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, kOpPrefix, ots::kHFlex,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kHFlex,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, kOpPrefix, ots::kHFlex,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, 5, 6, 7, kOpPrefix, ots::kHFlex,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestHFlex1) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, kOpPrefix, ots::kHFlex1,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kHFlex1,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, kOpPrefix, ots::kHFlex1,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, 5, 6, 7, 8, 9, kOpPrefix, ots::kHFlex1,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestFlex1) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, kOpPrefix, ots::kFlex1,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kFlex1,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, kOpPrefix, ots::kFlex1,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, kOpPrefix, ots::kFlex1,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestEndChar) {
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallSubr,
+    };
+    const int local_subrs[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(Validate(char_string, ARRAYSIZE(char_string),
+                         NULL, 0,
+                         local_subrs, ARRAYSIZE(local_subrs)));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallGSubr,
+    };
+    const int global_subrs[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(Validate(char_string, ARRAYSIZE(char_string),
+                         global_subrs, ARRAYSIZE(global_subrs),
+                         NULL, 0));
+  }
+}
+
+TEST(ValidateTest, TestHStem) {
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      0,  // width
+      1, 2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      0, 1, 2, kOpPrefix, ots::kHStem,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kHStem,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestVStem) {
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kVStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, kOpPrefix, ots::kVStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      0,  // width
+      1, 2, kOpPrefix, ots::kVStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      0, 1, 2, kOpPrefix, ots::kVStem,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kVStem,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestHStemHm) {
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kHStemHm,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, kOpPrefix, ots::kHStemHm,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      0,  // width
+      1, 2, kOpPrefix, ots::kHStemHm,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      0, 1, 2, kOpPrefix, ots::kHStemHm,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kHStemHm,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestVStemHm) {
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kVStemHm,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, kOpPrefix, ots::kVStemHm,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      0,  // width
+      1, 2, kOpPrefix, ots::kVStemHm,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      0, 1, 2, kOpPrefix, ots::kVStemHm,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kVMoveTo,
+      1, 2, 3, 4, 5, kOpPrefix, ots::kVStemHm,  // invalid
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestHintMask) {
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kHintMask, 0x00,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kHStem,
+      3, 4, 5, 6, kOpPrefix, ots::kHintMask, 0x00,  // vstem
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kHintMask, 0x00,  // no stems to mask
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kHStem,
+      3, 4, 5, kOpPrefix, ots::kHintMask, 0x00,  // invalid vstem
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestCntrMask) {
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kCntrMask, 0x00,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kHStem,
+      3, 4, 5, 6, kOpPrefix, ots::kCntrMask, 0x00,  // vstem
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kCntrMask, 0x00,  // no stems to mask
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, kOpPrefix, ots::kHStem,
+      3, 4, 5, kOpPrefix, ots::kCntrMask, 0x00,  // invalid vstem
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestAbs) {
+  {
+    const int char_string[] = {
+      -1, kOpPrefix, ots::kAbs,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kAbs,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestAdd) {
+  {
+    const int char_string[] = {
+      0, 1, kOpPrefix, ots::kAdd,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kAdd,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestSub) {
+  {
+    const int char_string[] = {
+      2, 1, kOpPrefix, ots::kSub,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kSub,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestDiv) {
+  // TODO(yusukes): Test div-by-zero.
+  {
+    const int char_string[] = {
+      2, 1, kOpPrefix, ots::kDiv,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kDiv,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestNeg) {
+  {
+    const int char_string[] = {
+      -1, kOpPrefix, ots::kNeg,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kNeg,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestRandom) {
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kRandom,  // OTS rejects the operator.
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestMul) {
+  {
+    const int char_string[] = {
+      2, 1, kOpPrefix, ots::kMul,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kMul,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestSqrt) {
+  // TODO(yusukes): Test negative numbers.
+  {
+    const int char_string[] = {
+      4, kOpPrefix, ots::kSqrt,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kSqrt,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestDrop) {
+  {
+    const int char_string[] = {
+      1, 1, kOpPrefix, ots::kAdd,
+      kOpPrefix, ots::kDrop,
+      1, 2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kDrop,  // invalid
+      1, 2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestExch) {
+  {
+    const int char_string[] = {
+      1, 1, kOpPrefix, ots::kAdd,
+      kOpPrefix, ots::kDup,
+      kOpPrefix, ots::kExch,
+      kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 1, kOpPrefix, ots::kAdd,
+      kOpPrefix, ots::kExch,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestIndex) {
+  {
+    const int char_string[] = {
+      1, 2, 3, -1, kOpPrefix, ots::kIndex,  // OTS rejects the operator.
+      kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestRoll) {
+  {
+    const int char_string[] = {
+      1, 2, 2, 1, kOpPrefix, ots::kRoll,  // OTS rejects the operator.
+      kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestDup) {
+  {
+    const int char_string[] = {
+      1, 1, kOpPrefix, ots::kAdd,
+      kOpPrefix, ots::kDup,
+      kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kDup,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestPut) {
+  {
+    const int char_string[] = {
+      1, 10, kOpPrefix, ots::kPut,  // OTS rejects the operator.
+      1, 2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestGet) {
+  {
+    const int char_string[] = {
+      1, 10, kOpPrefix, ots::kGet,  // OTS rejects the operator.
+      1, 2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestAnd) {
+  {
+    const int char_string[] = {
+      2, 1, kOpPrefix, ots::kAnd,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kAnd,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestOr) {
+  {
+    const int char_string[] = {
+      2, 1, kOpPrefix, ots::kOr,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kOr,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestNot) {
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kNot,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, ots::kNot,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestEq) {
+  {
+    const int char_string[] = {
+      2, 1, kOpPrefix, ots::kEq,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, kOpPrefix, ots::kEq,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestIfElse) {
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, kOpPrefix, ots::kIfElse,
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, kOpPrefix, ots::kIfElse,  // invalid
+      2, kOpPrefix, ots::kHStem,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestCallSubr) {
+  // Call valid subr.
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallSubr,
+    };
+    const int local_subrs[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(Validate(char_string, ARRAYSIZE(char_string),
+                         NULL, 0,
+                         local_subrs, ARRAYSIZE(local_subrs)));
+  }
+  // Call undefined subr.
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(-1), kOpPrefix, ots::kCallSubr,
+    };
+    const int local_subrs[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(Validate(char_string, ARRAYSIZE(char_string),
+                          NULL, 0,
+                          local_subrs, ARRAYSIZE(local_subrs)));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(1), kOpPrefix, ots::kCallSubr,
+    };
+    const int local_subrs[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(Validate(char_string, ARRAYSIZE(char_string),
+                          NULL, 0,
+                          local_subrs, ARRAYSIZE(local_subrs)));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(-1), kOpPrefix, ots::kCallSubr,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallSubr,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(1), kOpPrefix, ots::kCallSubr,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestCallGSubr) {
+  // Call valid subr.
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallGSubr,
+    };
+    const int global_subrs[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(Validate(char_string, ARRAYSIZE(char_string),
+                         global_subrs, ARRAYSIZE(global_subrs),
+                         NULL, 0));
+  }
+  // Call undefined subr.
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(-1), kOpPrefix, ots::kCallGSubr,
+    };
+    const int global_subrs[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(Validate(char_string, ARRAYSIZE(char_string),
+                          global_subrs, ARRAYSIZE(global_subrs),
+                          NULL, 0));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(1), kOpPrefix, ots::kCallGSubr,
+    };
+    const int global_subrs[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(Validate(char_string, ARRAYSIZE(char_string),
+                          global_subrs, ARRAYSIZE(global_subrs),
+                          NULL, 0));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(-1), kOpPrefix, ots::kCallGSubr,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallGSubr,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(1), kOpPrefix, ots::kCallGSubr,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestCallGSubrWithComputedValues) {
+  {
+    // OTS does not allow to call(g)subr with a subroutine number which is
+    // not a immediate value for safety.
+    const int char_string[] = {
+      0, 0, kOpPrefix, ots::kAdd,
+      kOpPrefix, ots::kCallGSubr,
+    };
+    const int global_subrs[] = {
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(Validate(char_string, ARRAYSIZE(char_string),
+                          global_subrs, ARRAYSIZE(global_subrs),
+                          NULL, 0));
+  }
+}
+
+TEST(ValidateTest, TestInfiniteLoop) {
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallSubr,
+    };
+    const int local_subrs[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallSubr,
+    };
+    EXPECT_FALSE(Validate(char_string, ARRAYSIZE(char_string),
+                          NULL, 0,
+                          local_subrs, ARRAYSIZE(local_subrs)));
+  }
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallGSubr,
+    };
+    const int global_subrs[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallGSubr,
+    };
+    EXPECT_FALSE(Validate(char_string, ARRAYSIZE(char_string),
+                          global_subrs, ARRAYSIZE(global_subrs),
+                          NULL, 0));
+  }
+  // mutual recursion which doesn't stop.
+  {
+    const int char_string[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallSubr,
+    };
+    const int global_subrs[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallSubr,
+    };
+    const int local_subrs[] = {
+      GET_SUBR_NUMBER(0), kOpPrefix, ots::kCallGSubr,
+    };
+    EXPECT_FALSE(Validate(char_string, ARRAYSIZE(char_string),
+                          global_subrs, ARRAYSIZE(global_subrs),
+                          local_subrs, ARRAYSIZE(local_subrs)));
+  }
+}
+
+TEST(ValidateTest, TestStackOverflow) {
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+      1, 2, 3, 4, 5, 6, 7, 8,
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_TRUE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+      1, 2, 3, 4, 5, 6, 7, 8, 9,  // overflow
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestDeprecatedOperators) {
+  {
+    const int char_string[] = {
+      kOpPrefix, 16,  // 'blend'.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, (12 << 8) + 8,  // 'store'.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      kOpPrefix, (12 << 8) + 13,  // 'load'.
+      kOpPrefix, ots::kEndChar,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
+
+TEST(ValidateTest, TestUnterminatedCharString) {
+  // No endchar operator.
+  {
+    const int char_string[] = {
+      123,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      123, 456,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+  {
+    const int char_string[] = {
+      123, 456, kOpPrefix, ots::kReturn,
+    };
+    EXPECT_FALSE(ValidateCharStrings(char_string, ARRAYSIZE(char_string)));
+  }
+}
diff --git a/gfx/ots/tests/layout_common_table_test.cc b/gfx/ots/tests/layout_common_table_test.cc
new file mode 100644
--- /dev/null
+++ b/gfx/ots/tests/layout_common_table_test.cc
@@ -0,0 +1,764 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <cmath>
+#include <vector>
+#include <gtest/gtest.h>
+
+#include "layout.h"
+#include "ots-memory-stream.h"
+
+namespace {
+
+const uint32_t kFakeTag = 0x00000000;
+const size_t kScriptRecordSize = 6;
+const size_t kLangSysRecordSize = 6;
+
+bool BuildFakeScriptListTable(ots::OTSStream *out, const uint16_t script_count,
+                              const uint16_t langsys_count,
+                              const uint16_t feature_count) {
+  if (!out->WriteU16(script_count)) {
+    return false;
+  }
+  const off_t script_record_end = out->Tell() +
+      kScriptRecordSize * script_count;
+  const size_t script_table_size = 4 + kLangSysRecordSize * langsys_count;
+  for (unsigned i = 0; i < script_count; ++i) {
+    if (!out->WriteU32(kFakeTag) ||
+        !out->WriteU16(script_record_end + i * script_table_size)) {
+      return false;
+    }
+  }
+
+  // Offsets to LangSys tables are measured from the beginning of each
+  // script table.
+  const off_t langsys_record_end = 4 + kLangSysRecordSize * langsys_count;
+  const size_t langsys_table_size = 6 + 2 * feature_count;
+  // Write Fake Script tables.
+  for (unsigned i = 0; i < script_count; ++i) {
+    if (!out->WriteU16(0x0000) ||
+        !out->WriteU16(langsys_count)) {
+      return false;
+    }
+    for (unsigned j = 0; j < langsys_count; ++j) {
+      if (!out->WriteU32(kFakeTag) ||
+          !out->WriteU16(langsys_record_end + j * langsys_table_size)) {
+        return false;
+      }
+    }
+  }
+
+  // Write Fake LangSys tables.
+  for (unsigned i = 0; i < langsys_count; ++i) {
+    if (!out->WriteU16(0x0000) ||
+        !out->WriteU16(0xFFFF) ||
+        !out->WriteU16(feature_count)) {
+      return false;
+    }
+    for (unsigned j = 0; j < feature_count; ++j) {
+      if (!out->WriteU16(j)) {
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+const size_t kFeatureRecordSize = 6;
+
+bool BuildFakeFeatureListTable(ots::OTSStream *out,
+                               const uint16_t feature_count,
+                               const uint16_t lookup_count) {
+  if (!out->WriteU16(feature_count)) {
+    return false;
+  }
+  const off_t feature_record_end = out->Tell() +
+      kFeatureRecordSize * feature_count;
+  const size_t feature_table_size = 4 + 2 * lookup_count;
+  for (unsigned i = 0; i < feature_count; ++i) {
+    if (!out->WriteU32(kFakeTag) ||
+        !out->WriteU16(feature_record_end + i * feature_table_size)) {
+      return false;
+    }
+  }
+
+  // Write FeatureTable
+  for (unsigned i = 0; i < feature_count; ++i) {
+    if (!out->WriteU16(0x0000) ||
+        !out->WriteU16(lookup_count)) {
+      return false;
+    }
+    for (uint16_t j = 0; j < lookup_count; ++j) {
+      if (!out->WriteU16(j)) {
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+bool BuildFakeLookupListTable(ots::OTSStream *out, const uint16_t lookup_count,
+                              const uint16_t subtable_count) {
+  if (!out->WriteU16(lookup_count)) {
+    return false;
+  }
+  const off_t base_offset_lookup = out->Tell();
+  if (!out->Pad(2 * lookup_count)) {
+    return false;
+  }
+
+  std::vector<off_t> offsets_lookup(lookup_count, 0);
+  for (uint16_t i = 0; i < lookup_count; ++i) {
+    offsets_lookup[i] = out->Tell();
+    if (!out->WriteU16(i + 1) ||
+        !out->WriteU16(0) ||
+        !out->WriteU16(subtable_count) ||
+        !out->Pad(2 * subtable_count) ||
+        !out->WriteU16(0)) {
+      return false;
+    }
+  }
+
+  const off_t offset_lookup_table_end = out->Tell();
+  // Allocate 256 bytes for each subtable.
+  if (!out->Pad(256 * lookup_count * subtable_count)) {
+    return false;
+  }
+
+  if (!out->Seek(base_offset_lookup)) {
+    return false;
+  }
+  for (unsigned i = 0; i < lookup_count; ++i) {
+    if (!out->WriteU16(offsets_lookup[i])) {
+      return false;
+    }
+  }
+
+  for (unsigned i = 0; i < lookup_count; ++i) {
+    if (!out->Seek(offsets_lookup[i] + 6)) {
+      return false;
+    }
+    for (unsigned j = 0; j < subtable_count; ++j) {
+      if (!out->WriteU16(offset_lookup_table_end +
+                         256*i*subtable_count + 256*j)) {
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+bool BuildFakeCoverageFormat1(ots::OTSStream *out, const uint16_t glyph_count) {
+  if (!out->WriteU16(1) || !out->WriteU16(glyph_count)) {
+    return false;
+  }
+  for (uint16_t glyph_id = 1; glyph_id <= glyph_count; ++glyph_id) {
+    if (!out->WriteU16(glyph_id)) {
+      return false;
+    }
+  }
+  return true;
+}
+
+bool BuildFakeCoverageFormat2(ots::OTSStream *out, const uint16_t range_count) {
+  if (!out->WriteU16(2) || !out->WriteU16(range_count)) {
+    return false;
+  }
+  uint16_t glyph_id = 1;
+  uint16_t start_coverage_index = 0;
+  for (unsigned i = 0; i < range_count; ++i) {
+    // Write consecutive ranges in which each range consists of two glyph id.
+    if (!out->WriteU16(glyph_id) ||
+        !out->WriteU16(glyph_id + 1) ||
+        !out->WriteU16(start_coverage_index)) {
+      return false;
+    }
+    glyph_id += 2;
+    start_coverage_index += 2;
+  }
+  return true;
+}
+
+bool BuildFakeClassDefFormat1(ots::OTSStream *out, const uint16_t glyph_count) {
+  if (!out->WriteU16(1) ||
+      !out->WriteU16(1) ||
+      !out->WriteU16(glyph_count)) {
+    return false;
+  }
+  for (uint16_t class_value = 1; class_value <= glyph_count; ++class_value) {
+    if (!out->WriteU16(class_value)) {
+      return false;
+    }
+  }
+  return true;
+}
+
+bool BuildFakeClassDefFormat2(ots::OTSStream *out, const uint16_t range_count) {
+  if (!out->WriteU16(2) || !out->WriteU16(range_count)) {
+    return false;
+  }
+  uint16_t glyph_id = 1;
+  for (uint16_t class_value = 1; class_value <= range_count; ++class_value) {
+    // Write consecutive ranges in which each range consists of one glyph id.
+    if (!out->WriteU16(glyph_id) ||
+        !out->WriteU16(glyph_id + 1) ||
+        !out->WriteU16(class_value)) {
+      return false;
+    }
+    glyph_id += 2;
+  }
+  return true;
+}
+
+bool BuildFakeDeviceTable(ots::OTSStream *out, const uint16_t start_size,
+                          const uint16_t end_size, const uint16_t format) {
+  if (!out->WriteU16(start_size) ||
+      !out->WriteU16(end_size) ||
+      !out->WriteU16(format)) {
+    return false;
+  }
+
+  const unsigned num_values = std::abs(end_size - start_size) + 1;
+  const unsigned num_bits = (1 << format) * num_values;
+  const unsigned num_units = (num_bits - 1) / 16 + 1;
+  if (!out->Pad(num_units * 2)) {
+    return false;
+  }
+  return true;
+}
+
+class TestStream : public ots::MemoryStream {
+ public:
+  TestStream()
+      : ots::MemoryStream(data_, sizeof(data_)), size_(0) {
+    std::memset(reinterpret_cast<char*>(data_), 0, sizeof(data_));
+  }
+
+  uint8_t* data() { return data_; }
+  size_t size() const { return size_; }
+
+  virtual bool WriteRaw(const void *d, size_t length) {
+    if (Tell() + length > size_) {
+      size_ = Tell() + length;
+    }
+    return ots::MemoryStream::WriteRaw(d, length);
+  }
+
+ private:
+  size_t size_;
+  uint8_t data_[4096];
+};
+
+class TableTest : public ::testing::Test {
+ protected:
+
+  virtual void SetUp() {
+    ots::OpenTypeFile *file = new ots::OpenTypeFile();
+    file->context = new ots::OTSContext();
+    font = new ots::Font(file);
+  }
+
+  TestStream out;
+  ots::Font *font;
+};
+
+class ScriptListTableTest : public TableTest { };
+class DeviceTableTest : public TableTest { };
+class CoverageTableTest : public TableTest { };
+class CoverageFormat1Test : public TableTest { };
+class CoverageFormat2Test : public TableTest { };
+class ClassDefTableTest : public TableTest { };
+class ClassDefFormat1Test : public TableTest { };
+class ClassDefFormat2Test : public TableTest { };
+class LookupSubtableParserTest : public TableTest { };
+
+class FeatureListTableTest : public TableTest {
+ protected:
+
+  virtual void SetUp() {
+    TableTest::SetUp();
+    num_features = 0;
+  }
+
+  uint16_t num_features;
+};
+
+bool fakeTypeParserReturnsTrue(const ots::Font*, const uint8_t *,
+                               const size_t) {
+  return true;
+}
+
+bool fakeTypeParserReturnsFalse(const ots::Font*, const uint8_t *,
+                                const size_t) {
+  return false;
+}
+
+const ots::LookupSubtableParser::TypeParser TypeParsersReturnTrue[] = {
+  {1, fakeTypeParserReturnsTrue},
+  {2, fakeTypeParserReturnsTrue},
+  {3, fakeTypeParserReturnsTrue},
+  {4, fakeTypeParserReturnsTrue},
+  {5, fakeTypeParserReturnsTrue}
+};
+
+// Fake lookup subtable parser which always returns true.
+const ots::LookupSubtableParser FakeLookupParserReturnsTrue = {
+  5, 5, TypeParsersReturnTrue,
+};
+
+const ots::LookupSubtableParser::TypeParser TypeParsersReturnFalse[] = {
+  {1, fakeTypeParserReturnsFalse}
+};
+
+// Fake lookup subtable parser which always returns false.
+const ots::LookupSubtableParser FakeLookupParserReturnsFalse = {
+  1, 1, TypeParsersReturnFalse
+};
+
+class LookupListTableTest : public TableTest {
+ protected:
+
+  virtual void SetUp() {
+    TableTest::SetUp();
+    num_lookups = 0;
+  }
+
+  bool Parse() {
+    return ots::ParseLookupListTable(font, out.data(), out.size(),
+                                     &FakeLookupParserReturnsTrue,
+                                     &num_lookups);
+  }
+
+  uint16_t num_lookups;
+};
+
+}  // namespace
+
+TEST_F(ScriptListTableTest, TestSuccess) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  EXPECT_TRUE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(ScriptListTableTest, TestBadScriptCount) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  // Set too large script count.
+  out.Seek(0);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(ScriptListTableTest, TestScriptRecordOffsetUnderflow) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  // Set bad offset to ScriptRecord[0].
+  out.Seek(6);
+  out.WriteU16(0);
+  EXPECT_FALSE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(ScriptListTableTest, TestScriptRecordOffsetOverflow) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  // Set bad offset to ScriptRecord[0].
+  out.Seek(6);
+  out.WriteU16(out.size());
+  EXPECT_FALSE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(ScriptListTableTest, TestBadLangSysCount) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  // Set too large langsys count.
+  out.Seek(10);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(ScriptListTableTest, TestLangSysRecordOffsetUnderflow) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  // Set bad offset to LangSysRecord[0].
+  out.Seek(16);
+  out.WriteU16(0);
+  EXPECT_FALSE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(ScriptListTableTest, TestLangSysRecordOffsetOverflow) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  // Set bad offset to LangSysRecord[0].
+  out.Seek(16);
+  out.WriteU16(out.size());
+  EXPECT_FALSE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(ScriptListTableTest, TestBadReqFeatureIndex) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  // Set too large feature index to ReqFeatureIndex of LangSysTable[0].
+  out.Seek(20);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(ScriptListTableTest, TestBadFeatureCount) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  // Set too large feature count to LangSysTable[0].
+  out.Seek(22);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(ScriptListTableTest, TestBadFeatureIndex) {
+  BuildFakeScriptListTable(&out, 1, 1, 1);
+  // Set too large feature index to ReatureIndex[0] of LangSysTable[0].
+  out.Seek(24);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseScriptListTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(FeatureListTableTest, TestSuccess) {
+  BuildFakeFeatureListTable(&out, 1, 1);
+  EXPECT_TRUE(ots::ParseFeatureListTable(font, out.data(), out.size(), 1,
+                                         &num_features));
+  EXPECT_EQ(num_features, 1);
+}
+
+TEST_F(FeatureListTableTest, TestSuccess2) {
+  BuildFakeFeatureListTable(&out, 5, 1);
+  EXPECT_TRUE(ots::ParseFeatureListTable(font, out.data(), out.size(), 1,
+                                         &num_features));
+  EXPECT_EQ(num_features, 5);
+}
+
+TEST_F(FeatureListTableTest, TestBadFeatureCount) {
+  BuildFakeFeatureListTable(&out, 1, 1);
+  // Set too large feature count.
+  out.Seek(0);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseFeatureListTable(font, out.data(), out.size(), 1,
+                                          &num_features));
+}
+
+TEST_F(FeatureListTableTest, TestOffsetFeatureUnderflow) {
+  BuildFakeFeatureListTable(&out, 1, 1);
+  // Set bad offset to FeatureRecord[0].
+  out.Seek(6);
+  out.WriteU16(0);
+  EXPECT_FALSE(ots::ParseFeatureListTable(font, out.data(), out.size(), 1,
+                                          &num_features));
+}
+
+TEST_F(FeatureListTableTest, TestOffsetFeatureOverflow) {
+  BuildFakeFeatureListTable(&out, 1, 1);
+  // Set bad offset to FeatureRecord[0].
+  out.Seek(6);
+  out.WriteU16(out.size());
+  EXPECT_FALSE(ots::ParseFeatureListTable(font, out.data(), out.size(), 1,
+                                          &num_features));
+}
+
+TEST_F(FeatureListTableTest, TestBadLookupCount) {
+  BuildFakeFeatureListTable(&out, 1, 1);
+  // Set too large lookup count to FeatureTable[0].
+  out.Seek(10);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseFeatureListTable(font, out.data(), out.size(), 1,
+                                          &num_features));
+}
+
+TEST_F(LookupListTableTest, TestSuccess) {
+  BuildFakeLookupListTable(&out, 1, 1);
+  EXPECT_TRUE(Parse());
+  EXPECT_EQ(num_lookups, 1);
+}
+
+TEST_F(LookupListTableTest, TestSuccess2) {
+  BuildFakeLookupListTable(&out, 5, 1);
+  EXPECT_TRUE(Parse());
+  EXPECT_EQ(num_lookups, 5);
+}
+
+TEST_F(LookupListTableTest, TestOffsetLookupTableUnderflow) {
+  BuildFakeLookupListTable(&out, 1, 1);
+  // Set bad offset to Lookup[0].
+  out.Seek(2);
+  out.WriteU16(0);
+  EXPECT_FALSE(Parse());
+}
+
+TEST_F(LookupListTableTest, TestOffsetLookupTableOverflow) {
+  BuildFakeLookupListTable(&out, 1, 1);
+  // Set bad offset to Lookup[0].
+  out.Seek(2);
+  out.WriteU16(out.size());
+  EXPECT_FALSE(Parse());
+}
+
+TEST_F(LookupListTableTest, TestOffsetSubtableUnderflow) {
+  BuildFakeLookupListTable(&out, 1, 1);
+  // Set bad offset to SubTable[0] of LookupTable[0].
+  out.Seek(10);
+  out.WriteU16(0);
+  EXPECT_FALSE(Parse());
+}
+
+TEST_F(LookupListTableTest, TestOffsetSubtableOverflow) {
+  BuildFakeLookupListTable(&out, 1, 1);
+  // Set bad offset to SubTable[0] of LookupTable[0].
+  out.Seek(10);
+  out.WriteU16(out.size());
+  EXPECT_FALSE(Parse());
+}
+
+TEST_F(LookupListTableTest, TesBadLookupCount) {
+  BuildFakeLookupListTable(&out, 1, 1);
+  // Set too large lookup count of LookupTable[0].
+  out.Seek(0);
+  out.WriteU16(2);
+  EXPECT_FALSE(Parse());
+}
+
+TEST_F(LookupListTableTest, TesBadLookupType) {
+  BuildFakeLookupListTable(&out, 1, 1);
+  // Set too large lookup type of LookupTable[0].
+  out.Seek(4);
+  out.WriteU16(6);
+  EXPECT_FALSE(Parse());
+}
+
+TEST_F(LookupListTableTest, TesBadLookupFlag) {
+  BuildFakeLookupListTable(&out, 1, 1);
+  // Set IgnoreBaseGlyphs(0x0002) to the lookup flag of LookupTable[0].
+  out.Seek(6);
+  out.WriteU16(0x0002);
+  EXPECT_FALSE(Parse());
+}
+
+TEST_F(LookupListTableTest, TesBadSubtableCount) {
+  BuildFakeLookupListTable(&out, 1, 1);
+  // Set too large sutable count of LookupTable[0].
+  out.Seek(8);
+  out.WriteU16(2);
+  EXPECT_FALSE(Parse());
+}
+
+TEST_F(CoverageTableTest, TestSuccessFormat1) {
+  BuildFakeCoverageFormat1(&out, 1);
+  EXPECT_TRUE(ots::ParseCoverageTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(CoverageTableTest, TestSuccessFormat2) {
+  BuildFakeCoverageFormat2(&out, 1);
+  EXPECT_TRUE(ots::ParseCoverageTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(CoverageTableTest, TestBadFormat) {
+  BuildFakeCoverageFormat1(&out, 1);
+  // Set bad format.
+  out.Seek(0);
+  out.WriteU16(3);
+  EXPECT_FALSE(ots::ParseCoverageTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(CoverageFormat1Test, TestBadGlyphCount) {
+  BuildFakeCoverageFormat1(&out, 1);
+  // Set too large glyph count.
+  out.Seek(2);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseCoverageTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(CoverageFormat1Test, TestBadGlyphId) {
+  BuildFakeCoverageFormat1(&out, 1);
+  // Set too large glyph id.
+  out.Seek(4);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseCoverageTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(CoverageFormat2Test, TestBadRangeCount) {
+  BuildFakeCoverageFormat2(&out, 1);
+  // Set too large range count.
+  out.Seek(2);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseCoverageTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(CoverageFormat2Test, TestBadRange) {
+  BuildFakeCoverageFormat2(&out, 1);
+  // Set reverse order glyph id to start/end fields.
+  out.Seek(4);
+  out.WriteU16(2);
+  out.WriteU16(1);
+  EXPECT_FALSE(ots::ParseCoverageTable(font, out.data(), out.size(), 1));
+}
+
+TEST_F(CoverageFormat2Test, TestRangeOverlap) {
+  BuildFakeCoverageFormat2(&out, 2);
+  // Set overlapping glyph id to an end field.
+  out.Seek(12);
+  out.WriteU16(1);
+  EXPECT_FALSE(ots::ParseCoverageTable(font, out.data(), out.size(), 2));
+}
+
+TEST_F(CoverageFormat2Test, TestRangeOverlap2) {
+  BuildFakeCoverageFormat2(&out, 2);
+  // Set overlapping range.
+  out.Seek(10);
+  out.WriteU16(1);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseCoverageTable(font, out.data(), out.size(), 2));
+}
+
+TEST_F(ClassDefTableTest, TestSuccessFormat1) {
+  BuildFakeClassDefFormat1(&out, 1);
+  EXPECT_TRUE(ots::ParseClassDefTable(font, out.data(), out.size(), 1, 1));
+}
+
+TEST_F(ClassDefTableTest, TestSuccessFormat2) {
+  BuildFakeClassDefFormat2(&out, 1);
+  EXPECT_TRUE(ots::ParseClassDefTable(font, out.data(), out.size(), 1, 1));
+}
+
+TEST_F(ClassDefTableTest, TestBadFormat) {
+  BuildFakeClassDefFormat1(&out, 1);
+  // Set bad format.
+  out.Seek(0);
+  out.WriteU16(3);
+  EXPECT_FALSE(ots::ParseClassDefTable(font, out.data(), out.size(), 1, 1));
+}
+
+TEST_F(ClassDefFormat1Test, TestBadStartGlyph) {
+  BuildFakeClassDefFormat1(&out, 1);
+  // Set too large start glyph id.
+  out.Seek(2);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseClassDefTable(font, out.data(), out.size(), 1, 1));
+}
+
+TEST_F(ClassDefFormat1Test, TestBadGlyphCount) {
+  BuildFakeClassDefFormat1(&out, 1);
+  // Set too large glyph count.
+  out.Seek(4);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseClassDefTable(font, out.data(), out.size(), 1, 1));
+}
+
+TEST_F(ClassDefFormat1Test, TestBadClassValue) {
+  BuildFakeClassDefFormat1(&out, 1);
+  // Set too large class value.
+  out.Seek(6);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseClassDefTable(font, out.data(), out.size(), 1, 1));
+}
+
+TEST_F(ClassDefFormat2Test, TestBadRangeCount) {
+  BuildFakeClassDefFormat2(&out, 1);
+  // Set too large range count.
+  out.Seek(2);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseClassDefTable(font, out.data(), out.size(), 1, 1));
+}
+
+TEST_F(ClassDefFormat2Test, TestRangeOverlap) {
+  BuildFakeClassDefFormat2(&out, 2);
+  // Set overlapping glyph id to an end field.
+  out.Seek(12);
+  out.WriteU16(1);
+  EXPECT_FALSE(ots::ParseClassDefTable(font, out.data(), out.size(), 1, 1));
+}
+
+TEST_F(ClassDefFormat2Test, TestRangeOverlap2) {
+  BuildFakeClassDefFormat2(&out, 2);
+  // Set overlapping range.
+  out.Seek(10);
+  out.WriteU16(1);
+  out.WriteU16(2);
+  EXPECT_FALSE(ots::ParseClassDefTable(font, out.data(), out.size(), 1, 1));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat1Success) {
+  BuildFakeDeviceTable(&out, 1, 8, 1);
+  EXPECT_TRUE(ots::ParseDeviceTable(font, out.data(), out.size()));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat1Success2) {
+  BuildFakeDeviceTable(&out, 1, 9, 1);
+  EXPECT_TRUE(ots::ParseDeviceTable(font, out.data(), out.size()));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat1Fail) {
+  // Pass shorter length than expected.
+  BuildFakeDeviceTable(&out, 1, 8, 1);
+  EXPECT_FALSE(ots::ParseDeviceTable(font, out.data(), out.size() - 1));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat1Fail2) {
+  // Pass shorter length than expected.
+  BuildFakeDeviceTable(&out, 1, 9, 1);
+  EXPECT_FALSE(ots::ParseDeviceTable(font, out.data(), out.size() - 1));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat2Success) {
+  BuildFakeDeviceTable(&out, 1, 1, 2);
+  EXPECT_TRUE(ots::ParseDeviceTable(font, out.data(), out.size()));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat2Success2) {
+  BuildFakeDeviceTable(&out, 1, 8, 2);
+  EXPECT_TRUE(ots::ParseDeviceTable(font, out.data(), out.size()));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat2Fail) {
+  // Pass shorter length than expected.
+  BuildFakeDeviceTable(&out, 1, 8, 2);
+  EXPECT_FALSE(ots::ParseDeviceTable(font, out.data(), out.size() - 1));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat2Fail2) {
+  // Pass shorter length than expected.
+  BuildFakeDeviceTable(&out, 1, 9, 2);
+  EXPECT_FALSE(ots::ParseDeviceTable(font, out.data(), out.size() - 1));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat3Success) {
+  BuildFakeDeviceTable(&out, 1, 1, 3);
+  EXPECT_TRUE(ots::ParseDeviceTable(font, out.data(), out.size()));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat3Success2) {
+  BuildFakeDeviceTable(&out, 1, 8, 3);
+  EXPECT_TRUE(ots::ParseDeviceTable(font, out.data(), out.size()));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat3Fail) {
+  // Pass shorter length than expected.
+  BuildFakeDeviceTable(&out, 1, 8, 3);
+  EXPECT_FALSE(ots::ParseDeviceTable(font, out.data(), out.size() - 1));
+}
+
+TEST_F(DeviceTableTest, TestDeltaFormat3Fail2) {
+  // Pass shorter length than expected.
+  BuildFakeDeviceTable(&out, 1, 9, 3);
+  EXPECT_FALSE(ots::ParseDeviceTable(font, out.data(), out.size() - 1));
+}
+
+TEST_F(LookupSubtableParserTest, TestSuccess) {
+  {
+    EXPECT_TRUE(FakeLookupParserReturnsTrue.Parse(font, 0, 0, 1));
+  }
+  {
+    EXPECT_TRUE(FakeLookupParserReturnsTrue.Parse(font, 0, 0, 5));
+  }
+}
+
+TEST_F(LookupSubtableParserTest, TestFail) {
+  {
+    // Pass bad lookup type which less than the smallest type.
+    EXPECT_FALSE(FakeLookupParserReturnsTrue.Parse(font, 0, 0, 0));
+  }
+  {
+    // Pass bad lookup type which greater than the maximum type.
+    EXPECT_FALSE(FakeLookupParserReturnsTrue.Parse(font, 0, 0, 6));
+  }
+  {
+    // Check the type parser failure.
+    EXPECT_FALSE(FakeLookupParserReturnsFalse.Parse(font, 0, 0, 1));
+  }
+}
diff --git a/gfx/ots/tests/table_dependencies_test.cc b/gfx/ots/tests/table_dependencies_test.cc
new file mode 100644
--- /dev/null
+++ b/gfx/ots/tests/table_dependencies_test.cc
@@ -0,0 +1,65 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <gtest/gtest.h>
+
+#include "gsub.h"
+#include "ots.h"
+#include "ots-memory-stream.h"
+#include "vhea.h"
+#include "vmtx.h"
+
+#define SET_TABLE(name, capname) \
+  do { font->name = new ots::OpenType##capname; } while (0)
+#define SET_LAYOUT_TABLE(name, capname)                    \
+  do {                                                     \
+    if (!font->name) {                                      \
+      SET_TABLE(name, capname);                            \
+    }                                                      \
+    font->name->data = reinterpret_cast<const uint8_t*>(1); \
+    font->name->length = 1;                                 \
+  } while (0)
+#define DROP_TABLE(name) \
+  do { delete font->name; font->name = NULL; } while (0)
+#define DROP_LAYOUT_TABLE(name) \
+  do { font->name->data = NULL; font->name->length = 0; } while (0)
+
+namespace {
+
+class TableDependenciesTest : public ::testing::Test {
+ protected:
+  virtual void SetUp() {
+    font = new ots::Font(new ots::OpenTypeFile);
+    SET_LAYOUT_TABLE(gsub, GSUB);
+    SET_TABLE(vhea, VHEA);
+    SET_TABLE(vmtx, VMTX);
+  }
+
+  virtual void TearDown() {
+    DROP_TABLE(gsub);
+    DROP_TABLE(vhea);
+    DROP_TABLE(vmtx);
+  }
+  ots::Font *font;
+};
+}  // namespace
+
+TEST_F(TableDependenciesTest, TestVhea) {
+  EXPECT_TRUE(ots::ots_vhea_should_serialise(font));
+}
+
+TEST_F(TableDependenciesTest, TestVmtx) {
+  EXPECT_TRUE(ots::ots_vmtx_should_serialise(font));
+}
+
+TEST_F(TableDependenciesTest, TestVheaVmtx) {
+  DROP_TABLE(vmtx);
+  EXPECT_FALSE(ots::ots_vhea_should_serialise(font));
+}
+
+TEST_F(TableDependenciesTest, TestVmtxVhea) {
+  DROP_TABLE(vhea);
+  EXPECT_FALSE(ots::ots_vmtx_should_serialise(font));
+}
+
diff --git a/gfx/skia/skia/src/ports/SkFontHost_cairo.cpp b/gfx/skia/skia/src/ports/SkFontHost_cairo.cpp
diff --git a/gfx/src/gfxCrashReporterUtils.cpp b/gfx/src/gfxCrashReporterUtils.cpp
--- a/gfx/src/gfxCrashReporterUtils.cpp
+++ b/gfx/src/gfxCrashReporterUtils.cpp
@@ -105,18 +105,17 @@ private:
 void
 ScopedGfxFeatureReporter::WriteAppNote(char statusChar)
 {
   StaticMutexAutoLock al(gFeaturesAlreadyReportedMutex);
 
   if (!gFeaturesAlreadyReported) {
     gFeaturesAlreadyReported = new nsTArray<nsCString>;
     nsCOMPtr<nsIRunnable> r = new RegisterObserverRunnable();
-    SystemGroup::Dispatch("ScopedGfxFeatureReporter::RegisterObserverRunnable",
-                          TaskCategory::Other, r.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, r.forget());
   }
 
   nsAutoCString featureString;
   featureString.AppendPrintf("%s%c ",
                              mFeature,
                              statusChar);
 
   if (!gFeaturesAlreadyReported->Contains(featureString)) {
@@ -127,18 +126,17 @@ ScopedGfxFeatureReporter::WriteAppNote(c
 
 void
 ScopedGfxFeatureReporter::AppNote(const nsACString& aMessage)
 {
   if (NS_IsMainThread()) {
     CrashReporter::AppendAppNotesToCrashReport(aMessage);
   } else {
     nsCOMPtr<nsIRunnable> r = new AppendAppNotesRunnable(aMessage);
-    SystemGroup::Dispatch("ScopedGfxFeatureReporter::AppendAppNotesRunnable",
-                          TaskCategory::Other, r.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, r.forget());
   }
 }
   
 } // end namespace mozilla
 
 #else
 
 namespace mozilla {
diff --git a/gfx/tests/crashtests/1308394.html b/gfx/tests/crashtests/1308394.html
--- a/gfx/tests/crashtests/1308394.html
+++ b/gfx/tests/crashtests/1308394.html
@@ -1,9 +1,9 @@
-<html class="reftest-print"><head>
+<html class="reftest-paged"><head>
 <svg xmlns="http://www.w3.org/2000/svg" width="90" height="20">
   <linearGradient id="b" x2="0" y2="100%">
     <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
     <stop offset="1" stop-opacity=".1"/>
   </linearGradient>
   <mask id="a">
     <rect width="90" height="20" rx="3" fill="#fff"/>
   </mask>
diff --git a/gfx/tests/crashtests/665218.html b/gfx/tests/crashtests/665218.html
--- a/gfx/tests/crashtests/665218.html
+++ b/gfx/tests/crashtests/665218.html
@@ -1,8 +1,8 @@
-<html class="reftest-print"><head>
+<html class="reftest-paged"><head>
 <style id="e">    @font-face {
       font-family: "aaa";
       src: url("doesnotexist.TTF");
     }
     * { font-family: "aaa"; }</style>
 </head>
 <body>
diff --git a/gfx/tests/gtest/moz.build b/gfx/tests/gtest/moz.build
--- a/gfx/tests/gtest/moz.build
+++ b/gfx/tests/gtest/moz.build
@@ -34,23 +34,35 @@ UNIFIED_SOURCES += [
 UNIFIED_SOURCES += [ '/gfx/2d/unittest/%s' % p for p in [
     'TestBase.cpp',
     'TestBugs.cpp',
     'TestCairo.cpp',
     'TestPoint.cpp',
     'TestScaling.cpp',
 ]]
 
+# not UNIFIED_SOURCES because layout_common_table_test.cc has classes
+# in an anonymous namespace which result in a GCC error when used in
+# tests (e g. "error: 'ScriptListTableTest_TestSuccess_Test' has a field
+# 'ScriptListTableTest_TestSuccess_Test::<anonymous>' whose type uses
+# the anonymous namespace").
+SOURCES += [ '/gfx/ots/tests/%s' % p for p in [
+    'cff_type2_charstring_test.cc',
+    'layout_common_table_test.cc',
+    'table_dependencies_test.cc',
+]]
+
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
     '/gfx/2d',
     '/gfx/2d/unittest',
     '/gfx/config',
     '/gfx/layers',
+    '/gfx/ots/src',
     '/gfx/qcms',
 ]
 
 FINAL_LIBRARY = 'xul-gtest'
 
 CXXFLAGS += CONFIG['MOZ_CAIRO_CFLAGS']
 
 if CONFIG['GNU_CXX']:
diff --git a/gfx/thebes/DeviceManagerDx.cpp b/gfx/thebes/DeviceManagerDx.cpp
--- a/gfx/thebes/DeviceManagerDx.cpp
+++ b/gfx/thebes/DeviceManagerDx.cpp
@@ -434,16 +434,27 @@ DeviceManagerDx::CreateDevice(IDXGIAdapt
       RefPtr<ID3D11Debug> debug;
       if (!SUCCEEDED(aOutDevice->QueryInterface(__uuidof(ID3D11Debug), getter_AddRefs(debug))))
         break;
 
       RefPtr<ID3D11InfoQueue> infoQueue;
       if (!SUCCEEDED(debug->QueryInterface(__uuidof(ID3D11InfoQueue), getter_AddRefs(infoQueue))))
         break;
 
+      D3D11_INFO_QUEUE_FILTER filter;
+      PodZero(&filter);
+
+      // Disable warnings caused by Advanced Layers that are known and not problematic.
+      D3D11_MESSAGE_ID blockIDs[] = {
+        D3D11_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL
+      };
+      filter.DenyList.NumIDs = MOZ_ARRAY_LENGTH(blockIDs);
+      filter.DenyList.pIDList = blockIDs;
+      infoQueue->PushStorageFilter(&filter);
+
       infoQueue->SetBreakOnSeverity(D3D11_MESSAGE_SEVERITY_CORRUPTION, true);
       infoQueue->SetBreakOnSeverity(D3D11_MESSAGE_SEVERITY_ERROR, true);
       infoQueue->SetBreakOnSeverity(D3D11_MESSAGE_SEVERITY_WARNING, true);
     } while (false);
   }
 
   return true;
 }
diff --git a/gfx/thebes/gfxFT2FontBase.cpp b/gfx/thebes/gfxFT2FontBase.cpp
diff --git a/gfx/thebes/gfxFT2FontBase.h b/gfx/thebes/gfxFT2FontBase.h
diff --git a/gfx/thebes/gfxFT2Fonts.cpp b/gfx/thebes/gfxFT2Fonts.cpp
diff --git a/gfx/thebes/gfxFT2Fonts.h b/gfx/thebes/gfxFT2Fonts.h
diff --git a/gfx/thebes/gfxFT2Utils.cpp b/gfx/thebes/gfxFT2Utils.cpp
diff --git a/gfx/thebes/gfxFT2Utils.h b/gfx/thebes/gfxFT2Utils.h
diff --git a/gfx/thebes/gfxUtils.cpp b/gfx/thebes/gfxUtils.cpp
--- a/gfx/thebes/gfxUtils.cpp
+++ b/gfx/thebes/gfxUtils.cpp
@@ -647,17 +647,17 @@ gfxUtils::ClipToRegion(DrawTarget* aTarg
       AppendRectToPath(pathBuilder, Rect(iter.Get()));
     }
     RefPtr<Path> path = pathBuilder->Finish();
     aTarget->PushClip(path);
   }
 }
 
 /*static*/ gfxFloat
-gfxUtils::ClampToScaleFactor(gfxFloat aVal)
+gfxUtils::ClampToScaleFactor(gfxFloat aVal, bool aRoundDown)
 {
   // Arbitary scale factor limitation. We can increase this
   // for better scaling performance at the cost of worse
   // quality.
   static const gfxFloat kScaleResolution = 2;
 
   // Negative scaling is just a flip and irrelevant to
   // our resolution calculation.
@@ -673,18 +673,22 @@ gfxUtils::ClampToScaleFactor(gfxFloat aV
 
   gfxFloat power = log(aVal)/log(kScaleResolution);
 
   // If power is within 1e-5 of an integer, round to nearest to
   // prevent floating point errors, otherwise round up to the
   // next integer value.
   if (fabs(power - NS_round(power)) < 1e-5) {
     power = NS_round(power);
-  } else if (inverse) {
+  // Use floor when we are either inverted or rounding down, but
+  // not both.
+  } else if (inverse != aRoundDown) {
     power = floor(power);
+  // Otherwise, ceil when we are not inverted and not rounding
+  // down, or we are inverted and rounding down.
   } else {
     power = ceil(power);
   }
 
   gfxFloat scale = pow(kScaleResolution, power);
 
   if (inverse) {
     scale = 1 / scale;
diff --git a/gfx/thebes/gfxUtils.h b/gfx/thebes/gfxUtils.h
--- a/gfx/thebes/gfxUtils.h
+++ b/gfx/thebes/gfxUtils.h
@@ -141,19 +141,20 @@ public:
     /*
      * Transform this rectangle with aMatrix, resulting in a gfxQuad.
      */
     static gfxQuad TransformToQuad(const gfxRect& aRect,
                                    const mozilla::gfx::Matrix4x4& aMatrix);
 
     /**
      * Return the smallest power of kScaleResolution (2) greater than or equal to
-     * aVal.
+     * aVal. If aRoundDown is specified, the power of 2 will rather be less than
+     * or equal to aVal.
      */
-    static gfxFloat ClampToScaleFactor(gfxFloat aVal);
+    static gfxFloat ClampToScaleFactor(gfxFloat aVal, bool aRoundDown = false);
 
     /**
      * Clears surface to aColor (which defaults to transparent black).
      */
     static void ClearThebesSurface(gfxASurface* aSurface);
 
     static const float* YuvToRgbMatrix4x3RowMajor(mozilla::YUVColorSpace aYUVColorSpace);
     static const float* YuvToRgbMatrix3x3ColumnMajor(mozilla::YUVColorSpace aYUVColorSpace);
diff --git a/ipc/mscom/Objref.cpp b/ipc/mscom/Objref.cpp
--- a/ipc/mscom/Objref.cpp
+++ b/ipc/mscom/Objref.cpp
@@ -237,13 +237,21 @@ StripHandlerFromOBJREF(NotNull<IStream*>
     return false;
   }
 
   hr = aStream->Write(resAddr, resAddrSize, &bytesWritten);
   if (FAILED(hr) || bytesWritten != resAddrSize) {
     return false;
   }
 
+  // The difference between a OBJREF_STANDARD and an OBJREF_HANDLER is
+  // sizeof(CLSID), so we'll zero out the remaining bytes.
+  CLSID zeroClsid = {0};
+  hr = aStream->Write(&zeroClsid, sizeof(CLSID), &bytesWritten);
+  if (FAILED(hr) || bytesWritten != sizeof(CLSID)) {
+    return false;
+  }
+
   return true;
 }
 
 } // namespace mscom
 } // namespace mozilla
diff --git a/ipc/mscom/Ptr.h b/ipc/mscom/Ptr.h
--- a/ipc/mscom/Ptr.h
+++ b/ipc/mscom/Ptr.h
@@ -37,18 +37,17 @@ struct MainThreadRelease
     if (!aPtr) {
       return;
     }
     if (NS_IsMainThread()) {
       aPtr->Release();
       return;
     }
     DebugOnly<nsresult> rv =
-      SystemGroup::Dispatch("mscom::MainThreadRelease",
-                            TaskCategory::Other,
+      SystemGroup::Dispatch(TaskCategory::Other,
                             NewNonOwningRunnableMethod("mscom::MainThreadRelease",
                                                        aPtr, &T::Release));
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
 };
 
 template <typename T>
 struct MTADelete
diff --git a/ipc/mscom/oop/Handler.cpp b/ipc/mscom/oop/Handler.cpp
--- a/ipc/mscom/oop/Handler.cpp
+++ b/ipc/mscom/oop/Handler.cpp
@@ -136,32 +136,37 @@ Handler::GetMarshalSizeMax(REFIID riid, 
   }
 
   // We do not necessarily want to use the pv that COM is giving us; we may want
   // to marshal a different proxy that is more appropriate to what we're
   // wrapping...
   hr = mUnmarshal->GetMarshalSizeMax(marshalAs, unkToMarshal.get(),
                                      dwDestContext, pvDestContext,
                                      mshlflags, pSize);
+
+#if defined(MOZ_MSCOM_REMARSHAL_NO_HANDLER)
+  return hr;
+#else
   if (FAILED(hr)) {
     return hr;
   }
 
   if (!HasPayload()) {
     return S_OK;
   }
 
   DWORD payloadSize = 0;
   hr = GetHandlerPayloadSize(marshalAs, &payloadSize);
   if (FAILED(hr)) {
     return hr;
   }
 
   *pSize += payloadSize;
   return S_OK;
+#endif // defined(MOZ_MSCOM_REMARSHAL_NO_HANDLER)
 }
 
 HRESULT
 Handler::MarshalInterface(IStream* pStm, REFIID riid, void* pv,
                           DWORD dwDestContext, void* pvDestContext,
                           DWORD mshlflags)
 {
   // We do not necessarily want to use the pv that COM is giving us; we may want
@@ -230,27 +235,24 @@ HRESULT
 Handler::UnmarshalInterface(IStream* pStm, REFIID riid, void** ppv)
 {
   REFIID unmarshalAs = MarshalAs(riid);
   HRESULT hr = mUnmarshal->UnmarshalInterface(pStm, unmarshalAs, ppv);
   if (FAILED(hr)) {
     return hr;
   }
 
-  hr = ReadHandlerPayload(pStm, unmarshalAs);
-
   // This method may be called on the same object multiple times (as new
   // interfaces are queried off the proxy). Not all interfaces will necessarily
   // refresh the payload, so we set mHasPayload using OR to reflect that fact.
   // (Otherwise mHasPayload could be cleared and the handler would think that
   // it doesn't have a payload even though it actually does).
-  mHasPayload |= (hr == S_OK);
+  mHasPayload |= (ReadHandlerPayload(pStm, unmarshalAs) == S_OK);
 
-  // hr may be S_FALSE, but we don't want to return that
-  return SUCCEEDED(hr) ? S_OK : hr;
+  return hr;
 }
 
 HRESULT
 Handler::ReleaseMarshalData(IStream* pStm)
 {
   return mUnmarshal->ReleaseMarshalData(pStm);
 }
 
diff --git a/js/public/GCAPI.h b/js/public/GCAPI.h
--- a/js/public/GCAPI.h
+++ b/js/public/GCAPI.h
@@ -527,56 +527,34 @@ class JS_PUBLIC_API(AutoAssertNoGC) : pu
     JSContext* cx_;
 
   public:
     explicit AutoAssertNoGC(JSContext* cx = nullptr);
     ~AutoAssertNoGC();
 };
 
 /**
- * Assert if an allocation of a GC thing occurs while this class is live. This
- * class does not disable the static rooting hazard analysis.
- */
-class JS_PUBLIC_API(AutoAssertNoAlloc)
-{
-#ifdef JS_DEBUG
-    js::gc::GCRuntime* gc;
-
-  public:
-    AutoAssertNoAlloc() : gc(nullptr) {}
-    explicit AutoAssertNoAlloc(JSContext* cx);
-    void disallowAlloc(JSRuntime* rt);
-    ~AutoAssertNoAlloc();
-#else
-  public:
-    AutoAssertNoAlloc() {}
-    explicit AutoAssertNoAlloc(JSContext* cx) {}
-    void disallowAlloc(JSRuntime* rt) {}
-#endif
-};
-
-/**
  * Disable the static rooting hazard analysis in the live region and assert if
  * any allocation that could potentially trigger a GC occurs while this guard
  * object is live. This is most useful to help the exact rooting hazard analysis
  * in complex regions, since it cannot understand dataflow.
  *
  * Note: GC behavior is unpredictable even when deterministic and is generally
  *       non-deterministic in practice. The fact that this guard has not
  *       asserted is not a guarantee that a GC cannot happen in the guarded
  *       region. As a rule, anyone performing a GC unsafe action should
  *       understand the GC properties of all code in that region and ensure
  *       that the hazard analysis is correct for that code, rather than relying
  *       on this class.
  */
-class JS_PUBLIC_API(AutoSuppressGCAnalysis) : public AutoAssertNoAlloc
+class JS_PUBLIC_API(AutoSuppressGCAnalysis) : public AutoAssertNoGC
 {
   public:
-    AutoSuppressGCAnalysis() : AutoAssertNoAlloc() {}
-    explicit AutoSuppressGCAnalysis(JSContext* cx) : AutoAssertNoAlloc(cx) {}
+    AutoSuppressGCAnalysis() : AutoAssertNoGC() {}
+    explicit AutoSuppressGCAnalysis(JSContext* cx) : AutoAssertNoGC(cx) {}
 } JS_HAZ_GC_SUPPRESSED;
 
 /**
  * Assert that code is only ever called from a GC callback, disable the static
  * rooting hazard analysis and assert if any allocation that could potentially
  * trigger a GC occurs while this guard object is live.
  *
  * This is useful to make the static analysis ignore code that runs in GC
diff --git a/js/public/TrackedOptimizationInfo.h b/js/public/TrackedOptimizationInfo.h
--- a/js/public/TrackedOptimizationInfo.h
+++ b/js/public/TrackedOptimizationInfo.h
@@ -206,16 +206,17 @@ namespace JS {
     _(CantInlineNotHot)                                                 \
     _(CantInlineNotInDispatch)                                          \
     _(CantInlineUnreachable)                                            \
     _(CantInlineNativeBadForm)                                          \
     _(CantInlineNativeBadType)                                          \
     _(CantInlineNativeNoTemplateObj)                                    \
     _(CantInlineBound)                                                  \
     _(CantInlineNativeNoSpecialization)                                 \
+    _(CantInlineNoObservedTypes)                                        \
     _(HasCommonInliningPath)                                            \
                                                                         \
     _(GenericSuccess)                                                   \
     _(Inlined)                                                          \
     _(DOM)                                                              \
     _(Monomorphic)                                                      \
     _(Polymorphic)
 
diff --git a/js/public/UbiNodeBreadthFirst.h b/js/public/UbiNodeBreadthFirst.h
--- a/js/public/UbiNodeBreadthFirst.h
+++ b/js/public/UbiNodeBreadthFirst.h
@@ -78,17 +78,17 @@ template<typename Handler>
 struct BreadthFirst {
 
     // Construct a breadth-first traversal object that reports the nodes it
     // reaches to |handler|. The traversal asserts that no GC happens in its
     // runtime during its lifetime.
     //
     // We do nothing with noGC, other than require it to exist, with a lifetime
     // that encloses our own.
-    BreadthFirst(JSContext* cx, Handler& handler, const JS::AutoCheckCannotGC& noGC)
+    BreadthFirst(JSContext* cx, Handler& handler, const JS::AutoRequireNoGC& noGC)
       : wantNames(true), cx(cx), visited(), handler(handler), pending(),
         traversalBegun(false), stopRequested(false), abandonRequested(false)
     { }
 
     // Initialize this traversal object. Return false on OOM.
     bool init() { return visited.init(); }
 
     // Add |node| as a starting point for the traversal. You may add
diff --git a/js/src/builtin/DataViewObject.cpp b/js/src/builtin/DataViewObject.cpp
--- a/js/src/builtin/DataViewObject.cpp
+++ b/js/src/builtin/DataViewObject.cpp
@@ -1008,17 +1008,17 @@ JS_GetDataViewByteOffset(JSObject* obj)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return 0;
     return obj->as<DataViewObject>().byteOffset();
 }
 
 JS_FRIEND_API(void*)
-JS_GetDataViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetDataViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     DataViewObject& dv = obj->as<DataViewObject>();
     *isSharedMemory = dv.isSharedMemory();
     return dv.dataPointerEither().unwrap(/*safe - caller sees isSharedMemory*/);
 }
diff --git a/js/src/ds/PageProtectingVector.h b/js/src/ds/PageProtectingVector.h
--- a/js/src/ds/PageProtectingVector.h
+++ b/js/src/ds/PageProtectingVector.h
@@ -8,31 +8,18 @@
 #define ds_PageProtectingVector_h
 
 #include "mozilla/Atomics.h"
 #include "mozilla/IntegerPrintfMacros.h"
 #include "mozilla/PodOperations.h"
 #include "mozilla/Types.h"
 #include "mozilla/Vector.h"
 
-#ifdef MALLOC_H
-# include MALLOC_H
-#endif
-
 #include "ds/MemoryProtectionExceptionHandler.h"
 #include "gc/Memory.h"
-#include "js/Utility.h"
-
-#ifdef MOZ_MEMORY
-# ifdef XP_DARWIN
-#  define malloc_usable_size malloc_size
-# else
-extern "C" MFBT_API size_t malloc_usable_size(MALLOC_USABLE_SIZE_CONST_PTR void* p);
-# endif
-#endif
 
 namespace js {
 
 /*
  * PageProtectingVector is a vector that can only grow or be cleared, restricts
  * access to memory pages that haven't been used yet, and marks all of its fully
  * used memory pages as read-only. It can be used to detect heap corruption in
  * important buffers, since anything that tries to write into its protected
@@ -462,194 +449,11 @@ template<typename U>
 MOZ_NEVER_INLINE MOZ_MUST_USE bool
 PageProtectingVector<T, A, B, C, D, E, F, G>::appendSlow(const U* values, size_t size)
 {
     if (MOZ_LIKELY(length() + size <= capacity()))
         return appendNewPage(values, size);
     return appendNewBuffer(values, size);
 }
 
-class ProtectedReallocPolicy
-{
-    uintptr_t currAddr;
-    size_t currSize;
-    uintptr_t prevAddr;
-    size_t prevSize;
-
-    static const uint8_t PoisonPattern = 0xe5;
-
-    template <typename T> void update(T* newAddr, size_t newSize) {
-        prevAddr = currAddr;
-        prevSize = currSize;
-        currAddr = uintptr_t(newAddr);
-        currSize = newSize * sizeof(T);
-    }
-
-    template <typename T> void updateIfValid(T* newAddr, size_t newSize) {
-        if (newAddr)
-            update<T>(newAddr, newSize);
-    }
-
-    template <typename T> T* reallocUpdate(T* oldAddr, size_t oldSize, size_t newSize) {
-        T* newAddr = js_pod_realloc<T>(oldAddr, oldSize, newSize);
-        updateIfValid<T>(newAddr, newSize);
-        return newAddr;
-    }
-
-    void crashWithInfo(const uint8_t* buffer, size_t bytes, const char* type) {
-        size_t start = 0;
-        while (start < bytes) {
-            if (MOZ_LIKELY(buffer[start] != PoisonPattern)) {
-                ++start;
-                continue;
-            }
-            size_t limit;
-            for (limit = start + 1; limit < bytes && buffer[limit] == PoisonPattern; ++limit);
-            size_t size = limit - start;
-            if (size >= 16) {
-                MOZ_CRASH_UNSAFE_PRINTF("maybe_pod_realloc: %s buffer (old size = %" PRIu64
-                                        ") contains %" PRIu64 " bytes of poison starting from"
-                                        " offset %" PRIu64 "!", type, uint64_t(bytes),
-                                        uint64_t(size), uint64_t(start));
-            }
-            start = limit;
-        }
-        MOZ_CRASH("Could not confirm the presence of poison!");
-    }
-
-  public:
-    ProtectedReallocPolicy() : currAddr(0), currSize(0), prevAddr(0), prevSize(0) {}
-
-    ~ProtectedReallocPolicy() {
-        MOZ_RELEASE_ASSERT(!currSize && !currAddr);
-    }
-
-    template <typename T> T* maybe_pod_malloc(size_t numElems) {
-        MOZ_RELEASE_ASSERT(!currSize && !currAddr);
-        T* addr = js_pod_malloc<T>(numElems);
-        updateIfValid<T>(addr, numElems);
-        return addr;
-    }
-
-    template <typename T> T* maybe_pod_calloc(size_t numElems) {
-        MOZ_RELEASE_ASSERT(!currSize && !currAddr);
-        T* addr = js_pod_calloc<T>(numElems);
-        updateIfValid<T>(addr, numElems);
-        return addr;
-    }
-
-    template <typename T> T* maybe_pod_realloc(T* oldAddr, size_t oldSize, size_t newSize) {
-        if (uintptr_t(oldAddr) != currAddr) {
-            MOZ_CRASH_UNSAFE_PRINTF("maybe_pod_realloc: oldAddr and currAddr don't match "
-                                    "(0x%" PRIx64 " != 0x%" PRIx64 ", %" PRIu64 ")!",
-                                    uint64_t(oldAddr), uint64_t(currAddr), uint64_t(currSize));
-        }
-        if (oldSize * sizeof(T) != currSize) {
-            MOZ_CRASH_UNSAFE_PRINTF("maybe_pod_realloc: oldSize and currSize don't match "
-                                    "(%" PRIu64 " != %" PRIu64 ", 0x%" PRIx64 ")!",
-                                    uint64_t(oldSize * sizeof(T)), uint64_t(currSize),
-                                    uint64_t(currAddr));
-        }
-
-        MOZ_ASSERT_IF(oldAddr, oldSize);
-        if (MOZ_UNLIKELY(!newSize))
-            return nullptr;
-        if (MOZ_UNLIKELY(!oldAddr))
-            return maybe_pod_malloc<T>(newSize);
-
-#ifdef MOZ_MEMORY
-        size_t usableSize = malloc_usable_size(oldAddr);
-        if (usableSize < currSize) {
-            MOZ_CRASH_UNSAFE_PRINTF("maybe_pod_realloc: usableSize < currSize "
-                                    "(%" PRIu64 " < %" PRIu64 ", %" PRIu64 ", %s)!",
-                                    uint64_t(usableSize), uint64_t(currSize),
-                                    uint64_t(prevSize), prevAddr == currAddr ? "true" : "false");
-        }
-#endif
-
-        size_t bytes = (newSize >= oldSize ? oldSize : newSize) * sizeof(T);
-
-        // Check for the poison pattern every so often.
-        const uint8_t* oldAddrBytes = reinterpret_cast<const uint8_t*>(oldAddr);
-        for (size_t j, i = 0; i + 16 <= bytes; i += 1024) {
-            for (j = 0; j < 16 && oldAddrBytes[i + j] == PoisonPattern; ++j);
-            if (MOZ_UNLIKELY(j == 16))
-                crashWithInfo(oldAddrBytes, bytes, "old");
-        }
-
-        T* tmpAddr = js_pod_malloc<T>(newSize);
-        if (MOZ_UNLIKELY(!tmpAddr))
-            return reallocUpdate<T>(oldAddr, oldSize, newSize);
-
-        memcpy(tmpAddr, oldAddr, bytes);
-
-        const uint8_t* tmpAddrBytes = reinterpret_cast<const uint8_t*>(tmpAddr);
-        for (size_t j, i = 0; i + 16 <= bytes; i += 1024) {
-            for (j = 0; j < 16 && tmpAddrBytes[i + j] == PoisonPattern; ++j);
-            if (MOZ_UNLIKELY(j == 16))
-                crashWithInfo(tmpAddrBytes, bytes, "tmp");
-        }
-
-        if (!mozilla::PodEqual(oldAddrBytes, tmpAddrBytes, bytes))
-            MOZ_CRASH("maybe_pod_realloc: tmp buffer doesn't match old buffer!");
-
-        T* newAddr = js_pod_realloc<T>(oldAddr, oldSize, newSize);
-        if (MOZ_UNLIKELY(!newAddr)) {
-            js_free(tmpAddr);
-            return reallocUpdate<T>(oldAddr, oldSize, newSize);
-        }
-
-        const uint8_t* newAddrBytes = reinterpret_cast<const uint8_t*>(newAddr);
-        for (size_t j, i = 0; i + 16 <= bytes; i += 1024) {
-            for (j = 0; j < 16 && newAddrBytes[i + j] == PoisonPattern; ++j);
-            if (MOZ_UNLIKELY(j == 16))
-                crashWithInfo(newAddrBytes, bytes, "new");
-        }
-
-        if (!mozilla::PodEqual(tmpAddrBytes, newAddrBytes, bytes)) {
-#ifdef MOZ_MEMORY
-            MOZ_CRASH_UNSAFE_PRINTF("maybe_pod_realloc: buffers don't match "
-                                    "(%" PRIu64 " >= %" PRIu64 ", %" PRIu64 ", %s)!",
-                                    uint64_t(usableSize), uint64_t(currSize),
-                                    uint64_t(prevSize), prevAddr == currAddr ? "true" : "false");
-#else
-            MOZ_CRASH_UNSAFE_PRINTF("maybe_pod_realloc: buffers don't match "
-                                    "(%" PRIu64 ", %" PRIu64 ", %s)!",
-                                    uint64_t(currSize), uint64_t(prevSize),
-                                    prevAddr == currAddr ? "true" : "false");
-#endif
-        }
-
-        js_free(tmpAddr);
-        update<T>(newAddr, newSize);
-        return newAddr;
-    }
-
-    template <typename T> T* pod_malloc(size_t numElems) { return maybe_pod_malloc<T>(numElems); }
-    template <typename T> T* pod_calloc(size_t numElems) { return maybe_pod_calloc<T>(numElems); }
-    template <typename T> T* pod_realloc(T* p, size_t oldSize, size_t newSize) {
-        return maybe_pod_realloc<T>(p, oldSize, newSize);
-    }
-
-    void free_(void* p) {
-        MOZ_RELEASE_ASSERT(uintptr_t(p) == currAddr);
-#ifdef MOZ_MEMORY
-        size_t usableSize = malloc_usable_size(p);
-        if (usableSize < currSize) {
-            MOZ_CRASH_UNSAFE_PRINTF("free_: usableSize < currSize "
-                                    "(%" PRIu64 " < %" PRIu64 ", %" PRIu64 ", %s)!",
-                                    uint64_t(usableSize), uint64_t(currSize),
-                                    uint64_t(prevSize), prevAddr == currAddr ? "true" : "false");
-        }
-#endif
-        js_free(p);
-        update<uint8_t>(0, 0);
-    }
-
-    void reportAllocOverflow() const {}
-    bool checkSimulatedOOM() const {
-        return !js::oom::ShouldFailWithOOM();
-    }
-};
-
 } /* namespace js */
 
 #endif /* ds_PageProtectingVector_h */
diff --git a/js/src/gc/GCRuntime.h b/js/src/gc/GCRuntime.h
--- a/js/src/gc/GCRuntime.h
+++ b/js/src/gc/GCRuntime.h
@@ -16,16 +16,17 @@
 
 #include "gc/AtomMarking.h"
 #include "gc/Heap.h"
 #include "gc/Nursery.h"
 #include "gc/Statistics.h"
 #include "gc/StoreBuffer.h"
 #include "gc/Tracer.h"
 #include "js/GCAnnotations.h"
+#include "js/UniquePtr.h"
 
 namespace js {
 
 class AutoLockGC;
 class AutoLockHelperThreadState;
 class VerifyPreTracer;
 
 namespace gc {
@@ -41,21 +42,27 @@ struct MovingTracer;
 class WeakCacheSweepIterator;
 
 enum IncrementalProgress
 {
     NotFinished = 0,
     Finished
 };
 
-enum SweepActionList
+// Interface to a sweep action.
+//
+// Note that we don't need perfect forwarding for args here because the
+// types are not deduced but come ultimately from the type of a function pointer
+// passed to SweepFunc.
+template <typename... Args>
+struct SweepAction
 {
-    PerSweepGroupActionList,
-    PerZoneActionList,
-    SweepActionListCount
+    virtual ~SweepAction() {}
+    virtual IncrementalProgress run(Args... args) = 0;
+    virtual void assertFinished() const = 0;
 };
 
 class ChunkPool
 {
     Chunk* head_;
     size_t count_;
 
   public:
@@ -792,17 +799,17 @@ class GCRuntime
 
     bool isIncrementalGCEnabled() const { return mode == JSGC_MODE_INCREMENTAL && incrementalAllowed; }
     bool isIncrementalGCInProgress() const { return state() != State::NotActive; }
 
     bool isCompactingGCEnabled() const;
 
     bool isShrinkingGC() const { return invocationKind == GC_SHRINK; }
 
-    static bool initializeSweepActions();
+    bool initSweepActions();
 
     void setGrayRootsTracer(JSTraceDataOp traceOp, void* data);
     MOZ_MUST_USE bool addBlackRootsTracer(JSTraceDataOp traceOp, void* data);
     void removeBlackRootsTracer(JSTraceDataOp traceOp, void* data);
 
     bool triggerGCForTooMuchMalloc() {
         if (!triggerGC(JS::gcreason::TOO_MUCH_MALLOC))
             return false;
@@ -1030,29 +1037,29 @@ class GCRuntime
     void endMarkingSweepGroup();
     void beginSweepingSweepGroup();
     bool shouldReleaseObservedTypes();
     void sweepDebuggerOnMainThread(FreeOp* fop);
     void sweepJitDataOnMainThread(FreeOp* fop);
     void endSweepingSweepGroup();
     IncrementalProgress performSweepActions(SliceBudget& sliceBudget,
                                             AutoLockForExclusiveAccess& lock);
-    static IncrementalProgress sweepTypeInformation(GCRuntime* gc, FreeOp* fop, Zone* zone,
-                                                    SliceBudget& budget, AllocKind kind);
-    static IncrementalProgress mergeSweptObjectArenas(GCRuntime* gc, FreeOp* fop, Zone* zone,
-                                                      SliceBudget& budget, AllocKind kind);
-    static IncrementalProgress sweepAtomsTable(GCRuntime* gc, SliceBudget& budget);
+    static IncrementalProgress sweepTypeInformation(GCRuntime* gc, FreeOp* fop, SliceBudget& budget,
+                                                    Zone* zone);
+    static IncrementalProgress mergeSweptObjectArenas(GCRuntime* gc, FreeOp* fop, SliceBudget& budget,
+                                                      Zone* zone);
+    static IncrementalProgress sweepAtomsTable(GCRuntime* gc, FreeOp* fop, SliceBudget& budget);
     void startSweepingAtomsTable();
     IncrementalProgress sweepAtomsTable(SliceBudget& budget);
-    static IncrementalProgress sweepWeakCaches(GCRuntime* gc, SliceBudget& budget);
+    static IncrementalProgress sweepWeakCaches(GCRuntime* gc, FreeOp* fop, SliceBudget& budget);
     IncrementalProgress sweepWeakCaches(SliceBudget& budget);
-    static IncrementalProgress finalizeAllocKind(GCRuntime* gc, FreeOp* fop, Zone* zone,
-                                                 SliceBudget& budget, AllocKind kind);
-    static IncrementalProgress sweepShapeTree(GCRuntime* gc, FreeOp* fop, Zone* zone,
-                                              SliceBudget& budget, AllocKind kind);
+    static IncrementalProgress finalizeAllocKind(GCRuntime* gc, FreeOp* fop, SliceBudget& budget,
+                                                 Zone* zone, AllocKind kind);
+    static IncrementalProgress sweepShapeTree(GCRuntime* gc, FreeOp* fop, SliceBudget& budget,
+                                              Zone* zone);
     void endSweepPhase(bool lastGC, AutoLockForExclusiveAccess& lock);
     bool allCCVisibleZonesWereCollected() const;
     void sweepZones(FreeOp* fop, ZoneGroup* group, bool lastGC);
     void sweepZoneGroups(FreeOp* fop, bool destroyingRuntime);
     void decommitAllWithoutUnlocking(const AutoLockGC& lock);
     void startDecommit();
     void queueZonesForBackgroundSweep(ZoneList& zones);
     void sweepBackgroundThings(ZoneList& zones, LifoAlloc& freeBlocks);
@@ -1262,20 +1269,18 @@ class GCRuntime
     ActiveThreadData<unsigned> sweepGroupIndex;
 
     /*
      * Incremental sweep state.
      */
 
     ActiveThreadData<JS::Zone*> sweepGroups;
     ActiveThreadOrGCTaskData<JS::Zone*> currentSweepGroup;
-    ActiveThreadData<SweepActionList> sweepActionList;
-    ActiveThreadData<size_t> sweepPhaseIndex;
+    ActiveThreadData<UniquePtr<SweepAction<GCRuntime*, FreeOp*, SliceBudget&>>> sweepActions;
     ActiveThreadOrGCTaskData<JS::Zone*> sweepZone;
-    ActiveThreadData<size_t> sweepActionIndex;
     ActiveThreadData<mozilla::Maybe<AtomSet::Enum>> maybeAtomsToSweep;
     ActiveThreadOrGCTaskData<JS::detail::WeakCacheBase*> sweepCache;
     ActiveThreadData<bool> abortSweepAfterCurrentGroup;
 
     friend class WeakCacheSweepIterator;
 
     /*
      * List head of arenas allocated during the sweep phase.
diff --git a/js/src/jit-test/tests/debug/Frame-live-04.js b/js/src/jit-test/tests/debug/Frame-live-04.js
--- a/js/src/jit-test/tests/debug/Frame-live-04.js
+++ b/js/src/jit-test/tests/debug/Frame-live-04.js
@@ -1,10 +1,12 @@
 // frame.live is false for frames discarded during uncatchable error unwinding.
 
+load(libdir + 'asserts.js');
+
 var g = newGlobal();
 var dbg = Debugger(g);
 var hits = 0;
 var snapshot;
 dbg.onDebuggerStatement = function (frame) {
     var stack = [];
     for (var f = frame; f; f = f.older) {
         if (f.type === "call" && f.script !== null)
@@ -18,10 +20,12 @@ dbg.onDebuggerStatement = function (fram
 };
 
 g.eval("function z() { debugger; }");
 g.eval("function y() { z(); }");
 g.eval("function x() { y(); }");
 assertEq(g.eval("debugger; 'ok';"), "ok");
 assertEq(hits, 2);
 assertEq(snapshot.length, 3);
-for (var i = 0; i < snapshot.length; i++)
+for (var i = 0; i < snapshot.length; i++) {
     assertEq(snapshot[i].live, false);
+    assertThrowsInstanceOf(() => frame.script, Error);
+}
diff --git a/js/src/jit-test/tests/debug/Frame-live-05.js b/js/src/jit-test/tests/debug/Frame-live-05.js
--- a/js/src/jit-test/tests/debug/Frame-live-05.js
+++ b/js/src/jit-test/tests/debug/Frame-live-05.js
@@ -1,10 +1,12 @@
 // frame.live is false for frames removed after their compartments stopped being debuggees.
 
+load(libdir + 'asserts.js');
+
 var g1 = newGlobal();
 var g2 = newGlobal();
 var dbg = Debugger(g1, g2);
 var hits = 0;
 var snapshot = [];
 dbg.onDebuggerStatement = function (frame) {
     if (hits++ === 0) {
         assertEq(frame.eval("x();"), null);
@@ -20,10 +22,12 @@ dbg.onDebuggerStatement = function (fram
 
 g1.eval("function z() { debugger; }");
 g2.z = g1.z;
 g2.eval("function y() { z(); }");
 g2.eval("function x() { y(); }");
 assertEq(g2.eval("debugger; 'ok';"), "ok");
 assertEq(hits, 2);
 assertEq(snapshot.length, 3);
-for (var i = 0; i < snapshot.length; i++)
+for (var i = 0; i < snapshot.length; i++) {
     assertEq(snapshot[i].live, false);
+    assertThrowsInstanceOf(() => frame.script, Error);
+}
diff --git a/js/src/jit-test/tests/debug/Frame-script-environment-nondebuggee.js b/js/src/jit-test/tests/debug/Frame-script-environment-nondebuggee.js
--- a/js/src/jit-test/tests/debug/Frame-script-environment-nondebuggee.js
+++ b/js/src/jit-test/tests/debug/Frame-script-environment-nondebuggee.js
@@ -8,17 +8,17 @@ var dbg = new Debugger;
 var log;
 dbg.onDebuggerStatement = function (frame) {
   log += frame.type;
   // Initially, 'frame' is a debuggee frame, and we should be able to see its script and environment.
   assertEq(frame.script instanceof Debugger.Script, true);
   assertEq(frame.environment instanceof Debugger.Environment, true);
 
   // If we make g no longer a debuggee, then trying to touch the frame at
-  // all show throw.
+  // all should throw.
   dbg.removeDebuggee(g);
   assertThrowsInstanceOf(() => frame.script, Error);
   assertThrowsInstanceOf(() => frame.environment, Error);
 }
 
 g.eval('function f() { debugger; }');
 
 log = '';
diff --git a/js/src/jit-test/tests/debug/Object-displayName-01.js b/js/src/jit-test/tests/debug/Object-displayName-01.js
--- a/js/src/jit-test/tests/debug/Object-displayName-01.js
+++ b/js/src/jit-test/tests/debug/Object-displayName-01.js
@@ -10,8 +10,12 @@ assertEq(name, "f");
 g.eval("(function () { debugger; })();");
 assertEq(name, undefined);
 g.eval("Function('debugger;')();");
 assertEq(name, "anonymous");
 g.eval("var f = function() { debugger; }; f()");
 assertEq(name, "f");
 g.eval("var a = {}; a.f = function() { debugger; }; a.f()");
 assertEq(name, "a.f");
+g.eval("(async function grondo() { debugger; })();");
+assertEq(name, "grondo");
+g.eval("(async function* estux() { debugger; })().next();");
+assertEq(name, "estux");
diff --git a/js/src/jit-test/tests/debug/Object-environment-02.js b/js/src/jit-test/tests/debug/Object-environment-02.js
--- a/js/src/jit-test/tests/debug/Object-environment-02.js
+++ b/js/src/jit-test/tests/debug/Object-environment-02.js
@@ -4,17 +4,26 @@ var g = newGlobal()
 var dbg = Debugger(g);
 var hits = 0;
 g.h = function () {
     var frame = dbg.getNewestFrame();
     var fn = frame.eval("j").return;
     assertEq(fn.environment instanceof Debugger.Environment, true);
     var closure = frame.eval("f").return;
     assertEq(closure.environment instanceof Debugger.Environment, true);
+    var async_fun = frame.eval("m").return;
+    assertEq(async_fun.environment instanceof Debugger.Environment, true);
+    var async_iter = frame.eval("n").return;
+    assertEq(async_iter.environment instanceof Debugger.Environment, true);
     hits++;
 };
-g.eval("function j(a) {\n" +
-       "    var f = function () { return a; };\n" +
-       "    h();\n" +
-       "    return f;\n" +
-       "}\n" +
-       "j(0);\n");
+g.eval(`
+   function j(a) {
+       var f = function () { return a; };
+       function* g() { }
+       async function m() { }
+       async function* n() { }
+       h();
+       return f;
+   }
+   j(0);
+`);
 assertEq(hits, 1);
diff --git a/js/src/jit-test/tests/debug/Object-isArrowFunction.js b/js/src/jit-test/tests/debug/Object-isArrowFunction.js
--- a/js/src/jit-test/tests/debug/Object-isArrowFunction.js
+++ b/js/src/jit-test/tests/debug/Object-isArrowFunction.js
@@ -15,8 +15,10 @@ checkIsArrow(true, '(a) => { bleh; }');
 checkIsArrow(false, 'Object.getPrototypeOf(() => { })');
 checkIsArrow(false, '(function () { })');
 checkIsArrow(false, 'function f() { } f');
 checkIsArrow((void 0), '({})');
 checkIsArrow(false, 'Math.atan2');
 checkIsArrow(false, 'Function.prototype');
 checkIsArrow(false, 'Function("")');
 checkIsArrow(false, 'new Function("")');
+checkIsArrow(false, '(async function f () {})');
+checkIsArrow(true,  '(async () => { })');
diff --git a/js/src/jit-test/tests/debug/Object-name-01.js b/js/src/jit-test/tests/debug/Object-name-01.js
--- a/js/src/jit-test/tests/debug/Object-name-01.js
+++ b/js/src/jit-test/tests/debug/Object-name-01.js
@@ -6,8 +6,12 @@ var name;
 dbg.onDebuggerStatement = function (frame) { name = frame.callee.name; };
 
 g.eval("(function f() { debugger; })();");
 assertEq(name, "f");
 g.eval("(function () { debugger; })();");
 assertEq(name, undefined);
 g.eval("Function('debugger;')();");
 assertEq(name, "anonymous");
+g.eval("(async function grondo() { debugger; })();");
+assertEq(name, "grondo");
+g.eval("(async function* estux() { debugger; })().next();");
+assertEq(name, "estux");
diff --git a/js/src/jit-test/tests/debug/Object-parameterNames.js b/js/src/jit-test/tests/debug/Object-parameterNames.js
--- a/js/src/jit-test/tests/debug/Object-parameterNames.js
+++ b/js/src/jit-test/tests/debug/Object-parameterNames.js
@@ -4,30 +4,34 @@ var g = newGlobal();
 var dbg = new Debugger(g);
 var hits = 0;
 dbg.onDebuggerStatement = function (frame) {
     var arr = frame.arguments;
     assertEq(arraysEqual(arr[0].parameterNames, []), true);
     assertEq(arraysEqual(arr[1].parameterNames, ["x"]), true);
     assertEq(arraysEqual(arr[2].parameterNames,
                          ["a","b","c","d","e","f","g","h","i","j","k","l","m",
-                          "n","o","p","q","r","s","t","u","v","w","x","y","z"]), 
+                          "n","o","p","q","r","s","t","u","v","w","x","y","z"]),
              true);
     assertEq(arraysEqual(arr[3].parameterNames, ["a", (void 0), (void 0)]), true);
     assertEq(arr[4].parameterNames, (void 0));
     assertEq(arraysEqual(arr[5].parameterNames, [(void 0), (void 0)]), true);
-    assertEq(arr.length, 6);
+    assertEq(arraysEqual(arr[6].parameterNames, ["a", "b", "c"]), true);
+    assertEq(arraysEqual(arr[7].parameterNames, ["d", "e", "f"]), true);
+    assertEq(arr.length, 8);
     hits++;
 };
 
 g.eval("("
-       + function () { 
+       + function () {
            (function () { debugger; }
             (function () {},
              function (x) {},
              function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) {},
              function (a, [b, c], {d, e:f}) { },
              {a:1},
-             Math.atan2
+             Math.atan2,
+             async function (a, b, c) {},
+             async function* (d, e, f) {}
             ));
        }
        +")()");
 assertEq(hits, 1);
diff --git a/js/src/jit-test/tests/debug/Object-script.js b/js/src/jit-test/tests/debug/Object-script.js
--- a/js/src/jit-test/tests/debug/Object-script.js
+++ b/js/src/jit-test/tests/debug/Object-script.js
@@ -1,13 +1,25 @@
 var g = newGlobal();
 var dbg = new Debugger(g);
 var hits = 0;
 dbg.onDebuggerStatement = function (frame) {
     var arr = frame.arguments;
     assertEq(arr[0].script instanceof Debugger.Script, true);
-    assertEq(arr[1].script, undefined);
-    assertEq(arr[2].script, undefined);
+    assertEq(arr[1].script instanceof Debugger.Script, true);
+    assertEq(arr[2].script instanceof Debugger.Script, true);
+    assertEq(arr[3].script instanceof Debugger.Script, true);
+    assertEq(arr[4].script, undefined);
+    assertEq(arr[5].script, undefined);
+    assertEq(arr.length, 6);
     hits++;
 };
 
-g.eval("(function () { debugger; })(function g(){}, {}, Math.atan2);");
+g.eval(`
+    function f() { debugger; }
+    f(function g(){},
+      function* h() {},
+      async function j() {},
+      async function* k() {},
+      {},
+      Math.atan2);
+`);
 assertEq(hits, 1);
diff --git a/js/src/jit/BaselineCacheIRCompiler.cpp b/js/src/jit/BaselineCacheIRCompiler.cpp
--- a/js/src/jit/BaselineCacheIRCompiler.cpp
+++ b/js/src/jit/BaselineCacheIRCompiler.cpp
@@ -489,16 +489,21 @@ BaselineCacheIRCompiler::emitMegamorphic
     AutoScratchRegisterMaybeOutput scratch1(allocator, masm, output);
     AutoScratchRegister scratch2(allocator, masm);
     AutoScratchRegister scratch3(allocator, masm);
 
     FailurePath* failure;
     if (!addFailurePath(&failure))
         return false;
 
+    // The object must be Native.
+    masm.loadObjClass(obj, scratch3);
+    masm.branchTest32(Assembler::NonZero, Address(scratch3, Class::offsetOfFlags()),
+                      Imm32(Class::NON_NATIVE), failure->label());
+
     masm.Push(UndefinedValue());
     masm.moveStackPtrTo(scratch3.get());
 
     LiveRegisterSet volatileRegs(GeneralRegisterSet::Volatile(), liveVolatileFloatRegs());
     volatileRegs.takeUnchecked(scratch1);
     volatileRegs.takeUnchecked(scratch2);
     volatileRegs.takeUnchecked(scratch3);
     masm.PushRegsInMask(volatileRegs);
diff --git a/js/src/jit/CacheIRCompiler.cpp b/js/src/jit/CacheIRCompiler.cpp
--- a/js/src/jit/CacheIRCompiler.cpp
+++ b/js/src/jit/CacheIRCompiler.cpp
@@ -2444,16 +2444,21 @@ CacheIRCompiler::emitMegamorphicLoadSlot
     bool handleMissing = reader.readBool();
 
     AutoScratchRegisterMaybeOutput scratch(allocator, masm, output);
 
     FailurePath* failure;
     if (!addFailurePath(&failure))
         return false;
 
+    // The object must be Native.
+    masm.loadObjClass(obj, scratch);
+    masm.branchTest32(Assembler::NonZero, Address(scratch, Class::offsetOfFlags()),
+                      Imm32(Class::NON_NATIVE), failure->label());
+
     // idVal will be in vp[0], result will be stored in vp[1].
     masm.reserveStack(sizeof(Value));
     masm.Push(idVal);
     masm.moveStackPtrTo(idVal.scratchReg());
 
     LiveRegisterSet volatileRegs(GeneralRegisterSet::Volatile(), liveVolatileFloatRegs());
     volatileRegs.takeUnchecked(scratch);
     volatileRegs.takeUnchecked(idVal);
diff --git a/js/src/jit/IonBuilder.cpp b/js/src/jit/IonBuilder.cpp
--- a/js/src/jit/IonBuilder.cpp
+++ b/js/src/jit/IonBuilder.cpp
@@ -414,21 +414,32 @@ IonBuilder::canInlineTarget(JSFunction* 
         }
 
         for (size_t i = 0; i < callInfo.argc(); i++) {
             if (callInfo.getArg(i)->emptyResultTypeSet()) {
                 trackOptimizationOutcome(TrackedOutcome::CantInlineUnreachable);
                 return DontInline(nullptr, "Empty TypeSet for argument");
             }
         }
+
+        // If we're going to add a TypeBarrier that always fails, it's not
+        // worth inlining this call as the script will be invalidated
+        // immediately.
+        if ((CodeSpec[*pc].format & JOF_TYPESET) &&
+            !BytecodeIsPopped(pc) &&
+            bytecodeTypes(pc)->empty())
+        {
+            trackOptimizationOutcome(TrackedOutcome::CantInlineNoObservedTypes);
+            return DontInline(nullptr, "Empty type barrier");
+        }
     }
 
     // Allow constructing lazy scripts when performing the definite properties
     // analysis, as baseline has not been used to warm the caller up yet.
-    if (target->isInterpreted() && info().analysisMode() == Analysis_DefiniteProperties) {
+    if (info().analysisMode() == Analysis_DefiniteProperties) {
         RootedFunction fun(analysisContext, target);
         RootedScript script(analysisContext, JSFunction::getOrCreateScript(analysisContext, fun));
         if (!script)
             return InliningDecision_Error;
 
         if (!script->hasBaselineScript() && script->canBaselineCompile()) {
             MethodStatus status = BaselineCompile(analysisContext, script);
             if (status == Method_Error)
diff --git a/js/src/jit/IonCacheIRCompiler.cpp b/js/src/jit/IonCacheIRCompiler.cpp
--- a/js/src/jit/IonCacheIRCompiler.cpp
+++ b/js/src/jit/IonCacheIRCompiler.cpp
@@ -841,16 +841,21 @@ IonCacheIRCompiler::emitMegamorphicLoadS
     AutoScratchRegisterMaybeOutput scratch1(allocator, masm, output);
     AutoScratchRegister scratch2(allocator, masm);
     AutoScratchRegister scratch3(allocator, masm);
 
     FailurePath* failure;
     if (!addFailurePath(&failure))
         return false;
 
+    // The object must be Native.
+    masm.loadObjClass(obj, scratch3);
+    masm.branchTest32(Assembler::NonZero, Address(scratch3, Class::offsetOfFlags()),
+                      Imm32(Class::NON_NATIVE), failure->label());
+
     masm.Push(UndefinedValue());
     masm.moveStackPtrTo(scratch3.get());
 
     LiveRegisterSet volatileRegs(GeneralRegisterSet::Volatile(), liveVolatileFloatRegs());
     volatileRegs.takeUnchecked(scratch1);
     volatileRegs.takeUnchecked(scratch2);
     volatileRegs.takeUnchecked(scratch3);
     masm.PushRegsInMask(volatileRegs);
diff --git a/js/src/jit/MacroAssembler.h b/js/src/jit/MacroAssembler.h
--- a/js/src/jit/MacroAssembler.h
+++ b/js/src/jit/MacroAssembler.h
@@ -368,19 +368,16 @@ class MacroAssembler : public MacroAssem
 
 #if defined(JS_CODEGEN_ARM)
         initWithAllocator();
         m_buffer.id = 0;
 #elif defined(JS_CODEGEN_ARM64)
         initWithAllocator();
         armbuffer_.id = 0;
 #endif
-
-        // Disable page protection for WASM.
-        disableProtection();
     }
 
     void constructRoot(JSContext* cx) {
         autoRooter_.emplace(cx, this);
     }
 
     MoveResolver& moveResolver() {
         return moveResolver_;
diff --git a/js/src/jit/VMFunctions.cpp b/js/src/jit/VMFunctions.cpp
--- a/js/src/jit/VMFunctions.cpp
+++ b/js/src/jit/VMFunctions.cpp
@@ -1612,18 +1612,18 @@ GetNativeDataProperty(JSContext* cx, Nat
         obj = &proto->as<NativeObject>();
     }
 }
 
 template <bool HandleMissing>
 bool
 GetNativeDataProperty(JSContext* cx, JSObject* obj, PropertyName* name, Value* vp)
 {
-    if (MOZ_UNLIKELY(!obj->isNative()))
-        return false;
+    // Condition checked by caller.
+    MOZ_ASSERT(obj->isNative());
     return GetNativeDataProperty<HandleMissing>(cx, &obj->as<NativeObject>(), NameToId(name), vp);
 }
 
 template bool
 GetNativeDataProperty<true>(JSContext* cx, JSObject* obj, PropertyName* name, Value* vp);
 
 template bool
 GetNativeDataProperty<false>(JSContext* cx, JSObject* obj, PropertyName* name, Value* vp);
@@ -1661,18 +1661,18 @@ ValueToAtomOrSymbol(JSContext* cx, Value
 }
 
 template <bool HandleMissing>
 bool
 GetNativeDataPropertyByValue(JSContext* cx, JSObject* obj, Value* vp)
 {
     JS::AutoCheckCannotGC nogc;
 
-    if (MOZ_UNLIKELY(!obj->isNative()))
-        return false;
+    // Condition checked by caller.
+    MOZ_ASSERT(obj->isNative());
 
     // vp[0] contains the id, result will be stored in vp[1].
     Value idVal = vp[0];
     jsid id;
     if (!ValueToAtomOrSymbol(cx, idVal, &id))
         return false;
 
     Value* res = vp + 1;
diff --git a/js/src/jit/arm/Assembler-arm.h b/js/src/jit/arm/Assembler-arm.h
--- a/js/src/jit/arm/Assembler-arm.h
+++ b/js/src/jit/arm/Assembler-arm.h
@@ -1383,22 +1383,16 @@ class Assembler : public AssemblerShared
     static const uint32_t* GetCF32Target(Iter* iter);
 
     static uintptr_t GetPointer(uint8_t*);
     template <class Iter>
     static const uint32_t* GetPtr32Target(Iter* iter, Register* dest = nullptr, RelocStyle* rs = nullptr);
 
     bool oom() const;
 
-    void disableProtection() {}
-    void enableProtection() {}
-    void setLowerBoundForProtection(size_t) {}
-    void unprotectRegion(unsigned char*, size_t) {}
-    void reprotectRegion(unsigned char*, size_t) {}
-
     void setPrinter(Sprinter* sp) {
 #ifdef JS_DISASM_ARM
         printer_ = sp;
 #endif
     }
 
     static const Register getStackPointer() {
         return StackPointer;
diff --git a/js/src/jit/arm64/Assembler-arm64.h b/js/src/jit/arm64/Assembler-arm64.h
--- a/js/src/jit/arm64/Assembler-arm64.h
+++ b/js/src/jit/arm64/Assembler-arm64.h
@@ -216,22 +216,16 @@ class Assembler : public vixl::Assembler
 
     bool oom() const {
         return AssemblerShared::oom() ||
             armbuffer_.oom() ||
             jumpRelocations_.oom() ||
             dataRelocations_.oom();
     }
 
-    void disableProtection() {}
-    void enableProtection() {}
-    void setLowerBoundForProtection(size_t) {}
-    void unprotectRegion(unsigned char*, size_t) {}
-    void reprotectRegion(unsigned char*, size_t) {}
-
     void copyJumpRelocationTable(uint8_t* dest) const {
         if (jumpRelocations_.length())
             memcpy(dest, jumpRelocations_.buffer(), jumpRelocations_.length());
     }
     void copyDataRelocationTable(uint8_t* dest) const {
         if (dataRelocations_.length())
             memcpy(dest, dataRelocations_.buffer(), dataRelocations_.length());
     }
diff --git a/js/src/jit/mips-shared/Assembler-mips-shared.h b/js/src/jit/mips-shared/Assembler-mips-shared.h
--- a/js/src/jit/mips-shared/Assembler-mips-shared.h
+++ b/js/src/jit/mips-shared/Assembler-mips-shared.h
@@ -901,22 +901,16 @@ class AssemblerMIPSShared : public Assem
                 embedsNurseryPointers_ = true;
             dataRelocations_.writeUnsigned(nextOffset().getOffset());
         }
     }
 
   public:
     bool oom() const;
 
-    void disableProtection() {}
-    void enableProtection() {}
-    void setLowerBoundForProtection(size_t) {}
-    void unprotectRegion(unsigned char*, size_t) {}
-    void reprotectRegion(unsigned char*, size_t) {}
-
     void setPrinter(Sprinter* sp) {
     }
 
     static const Register getStackPointer() {
         return StackPointer;
     }
 
   protected:
diff --git a/js/src/jit/none/MacroAssembler-none.h b/js/src/jit/none/MacroAssembler-none.h
--- a/js/src/jit/none/MacroAssembler-none.h
+++ b/js/src/jit/none/MacroAssembler-none.h
@@ -419,22 +419,16 @@ class MacroAssemblerNone : public Assemb
     Operand ToPayload(Operand base) { MOZ_CRASH(); }
 
     static const Register getStackPointer() { MOZ_CRASH(); }
 
     // Instrumentation for entering and leaving the profiler.
     void profilerEnterFrame(Register , Register ) { MOZ_CRASH(); }
     void profilerExitFrame() { MOZ_CRASH(); }
 
-    void disableProtection() { MOZ_CRASH(); }
-    void enableProtection() { MOZ_CRASH(); }
-    void setLowerBoundForProtection(size_t) { MOZ_CRASH(); }
-    void unprotectRegion(unsigned char*, size_t) { MOZ_CRASH(); }
-    void reprotectRegion(unsigned char*, size_t) { MOZ_CRASH(); }
-
 #ifdef JS_NUNBOX32
     Address ToPayload(Address) { MOZ_CRASH(); }
     Address ToType(Address) { MOZ_CRASH(); }
 #endif
 };
 
 typedef MacroAssemblerNone MacroAssemblerSpecific;
 
diff --git a/js/src/jit/x86-shared/Assembler-x86-shared.h b/js/src/jit/x86-shared/Assembler-x86-shared.h
--- a/js/src/jit/x86-shared/Assembler-x86-shared.h
+++ b/js/src/jit/x86-shared/Assembler-x86-shared.h
@@ -399,28 +399,16 @@ class AssemblerX86Shared : public Assemb
 
     bool oom() const {
         return AssemblerShared::oom() ||
                masm.oom() ||
                jumpRelocations_.oom() ||
                dataRelocations_.oom();
     }
 
-    void disableProtection() { masm.disableProtection(); }
-    void enableProtection() { masm.enableProtection(); }
-    void setLowerBoundForProtection(size_t size) {
-        masm.setLowerBoundForProtection(size);
-    }
-    void unprotectRegion(unsigned char* first, size_t size) {
-        masm.unprotectRegion(first, size);
-    }
-    void reprotectRegion(unsigned char* first, size_t size) {
-        masm.reprotectRegion(first, size);
-    }
-
     void setPrinter(Sprinter* sp) {
         masm.setPrinter(sp);
     }
 
     static const Register getStackPointer() {
         return StackPointer;
     }
 
diff --git a/js/src/jit/x86-shared/AssemblerBuffer-x86-shared.h b/js/src/jit/x86-shared/AssemblerBuffer-x86-shared.h
--- a/js/src/jit/x86-shared/AssemblerBuffer-x86-shared.h
+++ b/js/src/jit/x86-shared/AssemblerBuffer-x86-shared.h
@@ -28,17 +28,16 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef jit_x86_shared_AssemblerBuffer_x86_shared_h
 #define jit_x86_shared_AssemblerBuffer_x86_shared_h
 
 #include <stdarg.h>
 #include <string.h>
 
-#include "ds/PageProtectingVector.h"
 #include "jit/ExecutableAllocator.h"
 #include "jit/JitSpewer.h"
 
 // Spew formatting helpers.
 #define PRETTYHEX(x)                       (((x)<0)?"-":""),(((x)<0)?-(x):(x))
 
 #define MEM_o     "%s0x%x"
 #define MEM_os    MEM_o   "(,%s,%d)"
@@ -132,39 +131,16 @@ namespace jit {
             return m_buffer.begin();
         }
 
         unsigned char* data()
         {
             return m_buffer.begin();
         }
 
-#ifndef RELEASE_OR_BETA
-        void disableProtection() { m_buffer.disableProtection(); }
-        void enableProtection() { m_buffer.enableProtection(); }
-        void setLowerBoundForProtection(size_t size)
-        {
-            m_buffer.setLowerBoundForProtection(size);
-        }
-        void unprotectRegion(unsigned char* first, size_t size)
-        {
-            m_buffer.unprotectRegion(first, size);
-        }
-        void reprotectRegion(unsigned char* first, size_t size)
-        {
-            m_buffer.reprotectRegion(first, size);
-        }
-#else
-        void disableProtection() {}
-        void enableProtection() {}
-        void setLowerBoundForProtection(size_t) {}
-        void unprotectRegion(unsigned char*, size_t) {}
-        void reprotectRegion(unsigned char*, size_t) {}
-#endif
-
     protected:
         /*
          * OOM handling: This class can OOM in the ensureSpace() method trying
          * to allocate a new buffer. In response to an OOM, we need to avoid
          * crashing and report the error. We also want to make it so that
          * users of this class need to check for OOM only at certain points
          * and not after every operation.
          *
@@ -176,22 +152,17 @@ namespace jit {
          * See also the |buffer| method.
          */
         void oomDetected()
         {
             m_oom = true;
             m_buffer.clear();
         }
 
-#ifndef RELEASE_OR_BETA
-        PageProtectingVector<unsigned char, 256, ProtectedReallocPolicy,
-                             /* ProtectUsed = */ false, /* ProtectUnused = */ false> m_buffer;
-#else
         mozilla::Vector<unsigned char, 256, SystemAllocPolicy> m_buffer;
-#endif
         bool m_oom;
     };
 
     class GenericAssembler
     {
 #ifdef JS_JITSPEW
         Sprinter* printer;
 #endif
diff --git a/js/src/jit/x86-shared/BaseAssembler-x86-shared.h b/js/src/jit/x86-shared/BaseAssembler-x86-shared.h
--- a/js/src/jit/x86-shared/BaseAssembler-x86-shared.h
+++ b/js/src/jit/x86-shared/BaseAssembler-x86-shared.h
@@ -53,31 +53,16 @@ public:
 
     void disableVEX() { useVEX_ = false; }
 
     size_t size() const { return m_formatter.size(); }
     const unsigned char* buffer() const { return m_formatter.buffer(); }
     unsigned char* data() { return m_formatter.data(); }
     bool oom() const { return m_formatter.oom(); }
 
-    void disableProtection() { m_formatter.disableProtection(); }
-    void enableProtection() { m_formatter.enableProtection(); }
-    void setLowerBoundForProtection(size_t size)
-    {
-        m_formatter.setLowerBoundForProtection(size);
-    }
-    void unprotectRegion(unsigned char* first, size_t size)
-    {
-        m_formatter.unprotectRegion(first, size);
-    }
-    void reprotectRegion(unsigned char* first, size_t size)
-    {
-        m_formatter.reprotectRegion(first, size);
-    }
-
     void nop()
     {
         spew("nop");
         m_formatter.oneByteOp(OP_NOP);
     }
 
     void comment(const char* msg)
     {
@@ -5156,31 +5141,16 @@ threeByteOpImmSimd("vblendps", VEX_PD, O
         // Administrative methods:
 
         size_t size() const { return m_buffer.size(); }
         const unsigned char* buffer() const { return m_buffer.buffer(); }
         unsigned char* data() { return m_buffer.data(); }
         bool oom() const { return m_buffer.oom(); }
         bool isAligned(int alignment) const { return m_buffer.isAligned(alignment); }
 
-        void disableProtection() { m_buffer.disableProtection(); }
-        void enableProtection() { m_buffer.enableProtection(); }
-        void setLowerBoundForProtection(size_t size)
-        {
-            m_buffer.setLowerBoundForProtection(size);
-        }
-        void unprotectRegion(unsigned char* first, size_t size)
-        {
-            m_buffer.unprotectRegion(first, size);
-        }
-        void reprotectRegion(unsigned char* first, size_t size)
-        {
-            m_buffer.reprotectRegion(first, size);
-        }
-
         MOZ_MUST_USE bool append(const unsigned char* values, size_t size)
         {
             return m_buffer.append(values, size);
         }
 
     private:
 
         // Internals; ModRm and REX formatters.
diff --git a/js/src/jsapi-tests/testTypedArrays.cpp b/js/src/jsapi-tests/testTypedArrays.cpp
--- a/js/src/jsapi-tests/testTypedArrays.cpp
+++ b/js/src/jsapi-tests/testTypedArrays.cpp
@@ -68,17 +68,17 @@ BEGIN_TEST(testTypedArrays)
     return ok;
 }
 
 // Shared memory can only be mapped by a TypedArray by creating the
 // TypedArray with a SharedArrayBuffer explicitly, so no tests here.
 
 template<JSObject* Create(JSContext*, uint32_t),
          typename Element,
-         Element* GetData(JSObject*, bool* isShared, const JS::AutoCheckCannotGC&)>
+         Element* GetData(JSObject*, bool* isShared, const JS::AutoRequireNoGC&)>
 bool
 TestPlainTypedArray(JSContext* cx)
 {
     {
         RootedObject notArray(cx, Create(cx, UINT32_MAX));
         CHECK(!notArray);
     }
 
@@ -106,17 +106,17 @@ TestPlainTypedArray(JSContext* cx)
 
     return true;
 }
 
 template<JSObject* CreateWithBuffer(JSContext*, JS::HandleObject, uint32_t, int32_t),
          JSObject* CreateFromArray(JSContext*, JS::HandleObject),
          typename Element,
          bool Shared,
-         Element* GetData(JSObject*, bool*, const JS::AutoCheckCannotGC&)>
+         Element* GetData(JSObject*, bool*, const JS::AutoRequireNoGC&)>
 bool
 TestArrayFromBuffer(JSContext* cx)
 {
     if (Shared && !cx->compartment()->creationOptions().getSharedMemoryAndAtomicsEnabled())
         return true;
 
     size_t elts = 8;
     size_t nbytes = elts * sizeof(Element);
diff --git a/js/src/jsapi.cpp b/js/src/jsapi.cpp
--- a/js/src/jsapi.cpp
+++ b/js/src/jsapi.cpp
@@ -5447,32 +5447,32 @@ JS_StringIsFlat(JSString* str)
 
 JS_PUBLIC_API(bool)
 JS_StringHasLatin1Chars(JSString* str)
 {
     return str->hasLatin1Chars();
 }
 
 JS_PUBLIC_API(const JS::Latin1Char*)
-JS_GetLatin1StringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC& nogc, JSString* str,
+JS_GetLatin1StringCharsAndLength(JSContext* cx, const JS::AutoRequireNoGC& nogc, JSString* str,
                                  size_t* plength)
 {
     MOZ_ASSERT(plength);
     AssertHeapIsIdleOrStringIsFlat(str);
     CHECK_REQUEST(cx);
     assertSameCompartment(cx, str);
     JSLinearString* linear = str->ensureLinear(cx);
     if (!linear)
         return nullptr;
     *plength = linear->length();
     return linear->latin1Chars(nogc);
 }
 
 JS_PUBLIC_API(const char16_t*)
-JS_GetTwoByteStringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC& nogc, JSString* str,
+JS_GetTwoByteStringCharsAndLength(JSContext* cx, const JS::AutoRequireNoGC& nogc, JSString* str,
                                   size_t* plength)
 {
     MOZ_ASSERT(plength);
     AssertHeapIsIdleOrStringIsFlat(str);
     CHECK_REQUEST(cx);
     assertSameCompartment(cx, str);
     JSLinearString* linear = str->ensureLinear(cx);
     if (!linear)
@@ -5520,27 +5520,27 @@ JS_CopyStringChars(JSContext* cx, mozill
         return false;
 
     MOZ_ASSERT(linear->length() <= dest.length());
     CopyChars(dest.begin().get(), *linear);
     return true;
 }
 
 JS_PUBLIC_API(const Latin1Char*)
-JS_GetLatin1InternedStringChars(const JS::AutoCheckCannotGC& nogc, JSString* str)
+JS_GetLatin1InternedStringChars(const JS::AutoRequireNoGC& nogc, JSString* str)
 {
     MOZ_ASSERT(str->isAtom());
     JSFlatString* flat = str->ensureFlat(nullptr);
     if (!flat)
         return nullptr;
     return flat->latin1Chars(nogc);
 }
 
 JS_PUBLIC_API(const char16_t*)
-JS_GetTwoByteInternedStringChars(const JS::AutoCheckCannotGC& nogc, JSString* str)
+JS_GetTwoByteInternedStringChars(const JS::AutoRequireNoGC& nogc, JSString* str)
 {
     MOZ_ASSERT(str->isAtom());
     JSFlatString* flat = str->ensureFlat(nullptr);
     if (!flat)
         return nullptr;
     return flat->twoByteChars(nogc);
 }
 
@@ -5552,23 +5552,23 @@ JS_FlattenString(JSContext* cx, JSString
     assertSameCompartment(cx, str);
     JSFlatString* flat = str->ensureFlat(cx);
     if (!flat)
         return nullptr;
     return flat;
 }
 
 extern JS_PUBLIC_API(const Latin1Char*)
-JS_GetLatin1FlatStringChars(const JS::AutoCheckCannotGC& nogc, JSFlatString* str)
+JS_GetLatin1FlatStringChars(const JS::AutoRequireNoGC& nogc, JSFlatString* str)
 {
     return str->latin1Chars(nogc);
 }
 
 extern JS_PUBLIC_API(const char16_t*)
-JS_GetTwoByteFlatStringChars(const JS::AutoCheckCannotGC& nogc, JSFlatString* str)
+JS_GetTwoByteFlatStringChars(const JS::AutoRequireNoGC& nogc, JSFlatString* str)
 {
     return str->twoByteChars(nogc);
 }
 
 JS_PUBLIC_API(bool)
 JS_CompareStrings(JSContext* cx, JSString* str1, JSString* str2, int32_t* result)
 {
     AssertHeapIsIdle();
diff --git a/js/src/jsapi.h b/js/src/jsapi.h
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -5000,21 +5000,21 @@ JS_GetStringLength(JSString* str);
 extern JS_PUBLIC_API(bool)
 JS_StringIsFlat(JSString* str);
 
 /** Returns true iff the string's characters are stored as Latin1. */
 extern JS_PUBLIC_API(bool)
 JS_StringHasLatin1Chars(JSString* str);
 
 extern JS_PUBLIC_API(const JS::Latin1Char*)
-JS_GetLatin1StringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC& nogc, JSString* str,
+JS_GetLatin1StringCharsAndLength(JSContext* cx, const JS::AutoRequireNoGC& nogc, JSString* str,
                                  size_t* length);
 
 extern JS_PUBLIC_API(const char16_t*)
-JS_GetTwoByteStringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC& nogc, JSString* str,
+JS_GetTwoByteStringCharsAndLength(JSContext* cx, const JS::AutoRequireNoGC& nogc, JSString* str,
                                   size_t* length);
 
 extern JS_PUBLIC_API(bool)
 JS_GetStringCharAt(JSContext* cx, JSString* str, size_t index, char16_t* res);
 
 extern JS_PUBLIC_API(char16_t)
 JS_GetFlatStringCharAt(JSFlatString* str, size_t index);
 
@@ -5023,20 +5023,20 @@ JS_GetTwoByteExternalStringChars(JSStrin
 
 extern JS_PUBLIC_API(bool)
 JS_CopyStringChars(JSContext* cx, mozilla::Range<char16_t> dest, JSString* str);
 
 extern JS_PUBLIC_API(JSFlatString*)
 JS_FlattenString(JSContext* cx, JSString* str);
 
 extern JS_PUBLIC_API(const JS::Latin1Char*)
-JS_GetLatin1FlatStringChars(const JS::AutoCheckCannotGC& nogc, JSFlatString* str);
+JS_GetLatin1FlatStringChars(const JS::AutoRequireNoGC& nogc, JSFlatString* str);
 
 extern JS_PUBLIC_API(const char16_t*)
-JS_GetTwoByteFlatStringChars(const JS::AutoCheckCannotGC& nogc, JSFlatString* str);
+JS_GetTwoByteFlatStringChars(const JS::AutoRequireNoGC& nogc, JSFlatString* str);
 
 static MOZ_ALWAYS_INLINE JSFlatString*
 JSID_TO_FLAT_STRING(jsid id)
 {
     MOZ_ASSERT(JSID_IS_STRING(id));
     return (JSFlatString*)(JSID_BITS(id));
 }
 
@@ -6384,46 +6384,61 @@ typedef bool
 (* BuildIdOp)(BuildIdCharVector* buildId);
 
 extern JS_PUBLIC_API(void)
 SetBuildIdOp(JSContext* cx, BuildIdOp buildIdOp);
 
 /**
  * The WasmModule interface allows the embedding to hold a reference to the
  * underying C++ implementation of a JS WebAssembly.Module object for purposes
- * of (de)serialization off the object's JSRuntime's thread.
+ * of efficient postMessage() of WebAssembly.Module and (de)serialization off
+ * the object's JSRuntime's thread for IndexedDB.
+ *
+ * For postMessage() sharing:
+ *
+ * - GetWasmModule() is called when making a structured clone of payload
+ * containing a WebAssembly.Module object. The structured clone buffer holds a
+ * refcount of the JS::WasmModule until createObject() is called in the target
+ * agent's JSContext. The new WebAssembly.Module object continues to hold the
+ * JS::WasmModule and thus the final reference of a JS::WasmModule may be
+ * dropped from any thread and so the virtual destructor (and all internal
+ * methods of the C++ module) must be thread-safe.
+ *
+ * For (de)serialization:
  *
  * - Serialization starts when WebAssembly.Module is passed to the
  * structured-clone algorithm. JS::GetWasmModule is called on the JSRuntime
  * thread that initiated the structured clone to get the JS::WasmModule.
- * This interface is then taken to a background thread where serializedSize()
- * and serialize() are called to write the object to two files: a bytecode file
- * that always allows successful deserialization and a compiled-code file keyed
- * on cpu- and build-id that may become invalid if either of these change between
- * serialization and deserialization. After serialization, the reference is
- * dropped from the background thread.
+ * This interface is then taken to a background thread where the bytecode and
+ * compiled code are written into separate files: a bytecode file that always
+ * allows successful deserialization and a compiled-code file keyed on cpu- and
+ * build-id that may become invalid if either of these change between
+ * serialization and deserialization. After serialization, a reference is
+ * dropped from a separate thread so the virtual destructor must be thread-safe.
  *
  * - Deserialization starts when the structured clone algorithm encounters a
  * serialized WebAssembly.Module. On a background thread, the compiled-code file
  * is opened and CompiledWasmModuleAssumptionsMatch is called to see if it is
  * still valid (as described above). DeserializeWasmModule is then called to
  * construct a JS::WasmModule (also on the background thread), passing the
  * bytecode file descriptor and, if valid, the compiled-code file descriptor.
  * The JS::WasmObject is then transported to the JSRuntime thread (which
  * originated the request) and the wrapping WebAssembly.Module object is created
  * by calling createObject().
  */
 
 struct WasmModule : js::AtomicRefCounted<WasmModule>
 {
     virtual ~WasmModule() {}
 
-    virtual void serializedSize(size_t* maybeBytecodeSize, size_t* maybeCompiledSize) const = 0;
-    virtual void serialize(uint8_t* maybeBytecodeBegin, size_t maybeBytecodeSize,
-                           uint8_t* maybeCompiledBegin, size_t maybeCompiledSize) const = 0;
+    virtual size_t bytecodeSerializedSize() const = 0;
+    virtual void bytecodeSerialize(uint8_t* bytecodeBegin, size_t bytecodeSize) const = 0;
+
+    virtual size_t compiledSerializedSize() const = 0;
+    virtual void compiledSerialize(uint8_t* compiledBegin, size_t compiledSize) const = 0;
 
     virtual JSObject* createObject(JSContext* cx) = 0;
 };
 
 extern JS_PUBLIC_API(bool)
 IsWasmModuleObject(HandleObject obj);
 
 extern JS_PUBLIC_API(RefPtr<WasmModule>)
diff --git a/js/src/jsfriendapi.h b/js/src/jsfriendapi.h
--- a/js/src/jsfriendapi.h
+++ b/js/src/jsfriendapi.h
@@ -813,29 +813,29 @@ AtomHasLatin1Chars(JSAtom* atom)
 
 MOZ_ALWAYS_INLINE bool
 StringHasLatin1Chars(JSString* s)
 {
     return reinterpret_cast<shadow::String*>(s)->flags & shadow::String::LATIN1_CHARS_BIT;
 }
 
 MOZ_ALWAYS_INLINE const JS::Latin1Char*
-GetLatin1LinearStringChars(const JS::AutoCheckCannotGC& nogc, JSLinearString* linear)
+GetLatin1LinearStringChars(const JS::AutoRequireNoGC& nogc, JSLinearString* linear)
 {
     MOZ_ASSERT(LinearStringHasLatin1Chars(linear));
 
     using shadow::String;
     String* s = reinterpret_cast<String*>(linear);
     if (s->flags & String::INLINE_CHARS_BIT)
         return s->inlineStorageLatin1;
     return s->nonInlineCharsLatin1;
 }
 
 MOZ_ALWAYS_INLINE const char16_t*
-GetTwoByteLinearStringChars(const JS::AutoCheckCannotGC& nogc, JSLinearString* linear)
+GetTwoByteLinearStringChars(const JS::AutoRequireNoGC& nogc, JSLinearString* linear)
 {
     MOZ_ASSERT(!LinearStringHasLatin1Chars(linear));
 
     using shadow::String;
     String* s = reinterpret_cast<String*>(linear);
     if (s->flags & String::INLINE_CHARS_BIT)
         return s->inlineStorageTwoByte;
     return s->nonInlineCharsTwoByte;
@@ -855,23 +855,23 @@ AtomToFlatString(JSAtom* atom)
 
 MOZ_ALWAYS_INLINE JSLinearString*
 FlatStringToLinearString(JSFlatString* s)
 {
     return reinterpret_cast<JSLinearString*>(s);
 }
 
 MOZ_ALWAYS_INLINE const JS::Latin1Char*
-GetLatin1AtomChars(const JS::AutoCheckCannotGC& nogc, JSAtom* atom)
+GetLatin1AtomChars(const JS::AutoRequireNoGC& nogc, JSAtom* atom)
 {
     return GetLatin1LinearStringChars(nogc, AtomToLinearString(atom));
 }
 
 MOZ_ALWAYS_INLINE const char16_t*
-GetTwoByteAtomChars(const JS::AutoCheckCannotGC& nogc, JSAtom* atom)
+GetTwoByteAtomChars(const JS::AutoRequireNoGC& nogc, JSAtom* atom)
 {
     return GetTwoByteLinearStringChars(nogc, AtomToLinearString(atom));
 }
 
 MOZ_ALWAYS_INLINE bool
 IsExternalString(JSString* str, const JSStringFinalizer** fin, const char16_t** chars)
 {
     using shadow::String;
@@ -1949,17 +1949,17 @@ GetArrayBufferLengthAndData(JSObject* ob
 // There is an isShared out argument for API consistency (eases use from DOM).
 // It will always be set to true.
 extern JS_FRIEND_API(void)
 GetSharedArrayBufferLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
 
 } // namespace js
 
 JS_FRIEND_API(uint8_t*)
-JS_GetSharedArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetSharedArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 
 /*
  * Unwrap Typed arrays all at once. Return nullptr without throwing if the
  * object cannot be viewed as the correct typed array, or the typed array
  * object on success, filling both outparameters.
  */
 extern JS_FRIEND_API(JSObject*)
 JS_GetObjectAsInt8Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int8_t** data);
@@ -2047,17 +2047,17 @@ JS_ArrayBufferHasData(JSObject* obj);
  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
  * ArrayBuffer, and the unwrapping will succeed.
  *
  * |*isSharedMemory| will be set to false, the argument is present to simplify
  * its use from code that also interacts with SharedArrayBuffer.
  */
 extern JS_FRIEND_API(uint8_t*)
-JS_GetArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 
 /**
  * Check whether the obj is ArrayBufferObject and memory mapped. Note that this
  * may return false if a security wrapper is encountered that denies the
  * unwrapping.
  */
 extern JS_FRIEND_API(bool)
 JS_IsMappedArrayBufferObject(JSObject* obj);
@@ -2118,40 +2118,40 @@ JS_GetArrayBufferViewByteLength(JSObject
  * pass such a test: it is a typed array or a wrapper of a typed array, and the
  * unwrapping will succeed.
  *
  * |*isSharedMemory| will be set to true if the typed array maps a
  * SharedArrayBuffer, otherwise to false.
  */
 
 extern JS_FRIEND_API(int8_t*)
-JS_GetInt8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetInt8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 extern JS_FRIEND_API(uint8_t*)
-JS_GetUint8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetUint8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 extern JS_FRIEND_API(uint8_t*)
-JS_GetUint8ClampedArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetUint8ClampedArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 extern JS_FRIEND_API(int16_t*)
-JS_GetInt16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetInt16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 extern JS_FRIEND_API(uint16_t*)
-JS_GetUint16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetUint16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 extern JS_FRIEND_API(int32_t*)
-JS_GetInt32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetInt32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 extern JS_FRIEND_API(uint32_t*)
-JS_GetUint32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetUint32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 extern JS_FRIEND_API(float*)
-JS_GetFloat32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetFloat32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 extern JS_FRIEND_API(double*)
-JS_GetFloat64ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetFloat64ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 
 /**
  * Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
  * versions when possible.
  */
 extern JS_FRIEND_API(void*)
-JS_GetArrayBufferViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetArrayBufferViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 
 /**
  * Return the ArrayBuffer or SharedArrayBuffer underlying an ArrayBufferView.
  * This may return a detached buffer.  |obj| must be an object that would
  * return true for JS_IsArrayBufferViewObject().
  */
 extern JS_FRIEND_API(JSObject*)
 JS_GetArrayBufferViewBuffer(JSContext* cx, JS::HandleObject obj, bool* isSharedMemory);
@@ -2218,17 +2218,17 @@ JS_GetDataViewByteLength(JSObject* obj);
  * it would pass such a test: it is a data view or a wrapper of a data view,
  * and the unwrapping will succeed. If cx is nullptr, then DEBUG builds may be
  * unable to assert when unwrapping should be disallowed.
  *
  * |*isSharedMemory| will be set to true if the DataView maps a SharedArrayBuffer,
  * otherwise to false.
  */
 JS_FRIEND_API(void*)
-JS_GetDataViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
+JS_GetDataViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&);
 
 namespace js {
 
 /**
  * Add a watchpoint -- in the Object.prototype.watch sense -- to |obj| for the
  * property |id|, using the callable object |callable| as the function to be
  * called for notifications.
  *
diff --git a/js/src/jsgc.cpp b/js/src/jsgc.cpp
--- a/js/src/jsgc.cpp
+++ b/js/src/jsgc.cpp
@@ -189,19 +189,21 @@
 
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/MacroForEach.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/Move.h"
 #include "mozilla/ScopeExit.h"
 #include "mozilla/TimeStamp.h"
+#include "mozilla/TypeTraits.h"
 #include "mozilla/Unused.h"
 
 #include <ctype.h>
+#include <initializer_list>
 #include <string.h>
 #ifndef XP_WIN
 # include <sys/mman.h>
 # include <unistd.h>
 #endif
 
 #include "jsapi.h"
 #include "jsatom.h"
@@ -251,16 +253,17 @@
 
 using namespace js;
 using namespace js::gc;
 
 using mozilla::ArrayLength;
 using mozilla::Get;
 using mozilla::HashCodeScrambler;
 using mozilla::Maybe;
+using mozilla::Move;
 using mozilla::Swap;
 using mozilla::TimeStamp;
 
 using JS::AutoGCRooter;
 
 /* Increase the IGC marking slice time if we are in highFrequencyGC mode. */
 static const int IGC_MARK_SLICE_MULTIPLIER = 2;
 
@@ -403,69 +406,16 @@ static const FinalizePhase BackgroundFin
             AllocKind::SHAPE,
             AllocKind::ACCESSOR_SHAPE,
             AllocKind::BASE_SHAPE,
             AllocKind::OBJECT_GROUP
         }
     }
 };
 
-// Incremental sweeping is controlled by a list of actions that describe what
-// happens and in what order. Due to the incremental nature of sweeping an
-// action does not necessarily run to completion so the current state is tracked
-// in the GCRuntime by the performSweepActions() method. We may yield to the
-// mutator after running part of any action.
-//
-// There are two types of action: per-sweep-group and per-zone.
-//
-// Per-sweep-group actions are run first. Per-zone actions are grouped into
-// phases, with each phase run once per sweep group, and each action in it run
-// for every zone in the group.
-//
-// This is illustrated by the following pseudocode:
-//
-//   for each sweep group:
-//     for each per-sweep-group action:
-//       run part or all of action
-//       maybe yield to the mutator
-//     for each per-zone phase:
-//       for each zone in sweep group:
-//         for each action in phase:
-//           run part or all of action
-//           maybe yield to the mutator
-//
-// Progress through the loops is stored in GCRuntime, e.g. |sweepActionIndex|
-// for looping through the sweep actions.
-
-using PerSweepGroupSweepAction = IncrementalProgress (*)(GCRuntime* gc, SliceBudget& budget);
-
-struct PerZoneSweepAction
-{
-    using Func = IncrementalProgress (*)(GCRuntime* gc, FreeOp* fop, Zone* zone,
-                                         SliceBudget& budget, AllocKind kind);
-
-    Func func;
-    AllocKind kind;
-
-    PerZoneSweepAction(Func func, AllocKind kind) : func(func), kind(kind) {}
-};
-
-using PerSweepGroupActionVector = Vector<PerSweepGroupSweepAction, 0, SystemAllocPolicy>;
-using PerZoneSweepActionVector = Vector<PerZoneSweepAction, 0, SystemAllocPolicy>;
-using PerZoneSweepPhaseVector = Vector<PerZoneSweepActionVector, 0, SystemAllocPolicy>;
-
-static PerSweepGroupActionVector PerSweepGroupSweepActions;
-static PerZoneSweepPhaseVector PerZoneSweepPhases;
-
-bool
-js::gc::InitializeStaticData()
-{
-    return GCRuntime::initializeSweepActions();
-}
-
 template<>
 JSObject*
 ArenaCellIterImpl::get<JSObject>() const
 {
     MOZ_ASSERT(!done());
     return reinterpret_cast<JSObject*>(getCell());
 }
 
@@ -908,19 +858,17 @@ GCRuntime::GCRuntime(JSRuntime* rt) :
     isFull(false),
     incrementalState(gc::State::NotActive),
     lastMarkSlice(false),
     sweepOnBackgroundThread(false),
     blocksToFreeAfterSweeping((size_t) JSContext::TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE),
     sweepGroupIndex(0),
     sweepGroups(nullptr),
     currentSweepGroup(nullptr),
-    sweepPhaseIndex(0),
     sweepZone(nullptr),
-    sweepActionIndex(0),
     abortSweepAfterCurrentGroup(false),
     arenasAllocatedDuringSweep(nullptr),
     startedCompacting(false),
     relocatedArenasToRelease(nullptr),
 #ifdef JS_GC_ZEAL
     markingValidator(nullptr),
 #endif
     interFrameGC(false),
@@ -1182,16 +1130,19 @@ GCRuntime::init(uint32_t maxbytes, uint3
 #endif
 
     if (!InitTrace(*this))
         return false;
 
     if (!marker.init(mode))
         return false;
 
+    if (!initSweepActions())
+        return false;
+
     return true;
 }
 
 void
 GCRuntime::finish()
 {
     /* Wait for nursery background free to end and disable it to release memory. */
     if (nursery().isEnabled()) {
@@ -5036,17 +4987,17 @@ class ImmediateSweepWeakCacheTask : publ
     ImmediateSweepWeakCacheTask(const ImmediateSweepWeakCacheTask&) = delete;
 
   public:
     ImmediateSweepWeakCacheTask(JSRuntime* rt, JS::detail::WeakCacheBase& wc)
       : GCParallelTask(rt), cache(wc)
     {}
 
     ImmediateSweepWeakCacheTask(ImmediateSweepWeakCacheTask&& other)
-      : GCParallelTask(mozilla::Move(other)), cache(other.cache)
+      : GCParallelTask(Move(other)), cache(other.cache)
     {}
 
     void run() override {
         cache.sweep();
     }
 };
 
 static void
@@ -5410,26 +5361,25 @@ GCRuntime::beginSweepingSweepGroup()
             zone->arenas.queueForForegroundSweep(&fop, IncrementalFinalizePhases[i]);
 
         for (unsigned i = 0; i < ArrayLength(BackgroundFinalizePhases); ++i)
             zone->arenas.queueForBackgroundSweep(&fop, BackgroundFinalizePhases[i]);
 
         zone->arenas.queueForegroundThingsForSweep(&fop);
     }
 
-    sweepActionList = PerSweepGroupActionList;
-    sweepActionIndex = 0;
-    sweepPhaseIndex = 0;
-    sweepZone = nullptr;
     sweepCache = nullptr;
+    sweepActions->assertFinished();
 }
 
 void
 GCRuntime::endSweepingSweepGroup()
 {
+    sweepActions->assertFinished();
+
     {
         gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::FINALIZE_END);
         FreeOp fop(rt);
         callFinalizeCallbacks(&fop, JSFINALIZE_GROUP_END);
     }
 
     /* Update the GC state for zones we have swept. */
     for (GCSweepGroupIter zone(rt); !zone.done(); zone.next()) {
@@ -5565,29 +5515,26 @@ SweepArenaList(Arena** arenasToSweep, Sl
         if (sliceBudget.isOverBudget())
             return false;
     }
 
     return true;
 }
 
 /* static */ IncrementalProgress
-GCRuntime::sweepTypeInformation(GCRuntime* gc, FreeOp* fop, Zone* zone, SliceBudget& budget,
-                                AllocKind kind)
+GCRuntime::sweepTypeInformation(GCRuntime* gc, FreeOp* fop, SliceBudget& budget, Zone* zone)
 {
     // Sweep dead type information stored in scripts and object groups, but
     // don't finalize them yet. We have to sweep dead information from both live
     // and dead scripts and object groups, so that no dead references remain in
     // them. Type inference can end up crawling these zones again, such as for
     // TypeCompartment::markSetsUnknown, and if this happens after sweeping for
     // the sweep group finishes we won't be able to determine which things in
     // the zone are live.
 
-    MOZ_ASSERT(kind == AllocKind::LIMIT);
-
     gcstats::AutoPhase ap1(gc->stats(), gcstats::PhaseKind::SWEEP_COMPARTMENTS);
     gcstats::AutoPhase ap2(gc->stats(), gcstats::PhaseKind::SWEEP_TYPES);
 
     ArenaLists& al = zone->arenas;
 
     AutoClearTypeInferenceStateOnOOM oom(zone);
 
     if (!SweepArenaList<JSScript>(&al.gcScriptArenasToUpdate.ref(), budget, &oom))
@@ -5601,24 +5548,22 @@ GCRuntime::sweepTypeInformation(GCRuntim
         gcstats::AutoPhase ap(gc->stats(), gcstats::PhaseKind::SWEEP_TYPES_END);
         zone->types.endSweep(gc->rt);
     }
 
     return Finished;
 }
 
 /* static */ IncrementalProgress
-GCRuntime::mergeSweptObjectArenas(GCRuntime* gc, FreeOp* fop, Zone* zone, SliceBudget& budget,
-                                  AllocKind kind)
+GCRuntime::mergeSweptObjectArenas(GCRuntime* gc, FreeOp* fop, SliceBudget& budget, Zone* zone)
 {
     // Foreground finalized objects have already been finalized, and now their
     // arenas can be reclaimed by freeing empty ones and making non-empty ones
     // available for allocation.
 
-    MOZ_ASSERT(kind == AllocKind::LIMIT);
     zone->arenas.mergeForegroundSweptObjectArenas();
     return Finished;
 }
 
 void
 GCRuntime::startSweepingAtomsTable()
 {
     auto& maybeAtoms = maybeAtomsToSweep.ref();
@@ -5635,25 +5580,24 @@ GCRuntime::startSweepingAtomsTable()
         return;
     }
 
     // Initialize remaining atoms to sweep.
     maybeAtoms.emplace(*atomsTable);
 }
 
 /* static */ IncrementalProgress
-GCRuntime::sweepAtomsTable(GCRuntime* gc, SliceBudget& budget)
+GCRuntime::sweepAtomsTable(GCRuntime* gc, FreeOp* fop, SliceBudget& budget)
 {
     if (!gc->atomsZone->isGCSweeping())
         return Finished;
 
     return gc->sweepAtomsTable(budget);
 }
 
-
 IncrementalProgress
 GCRuntime::sweepAtomsTable(SliceBudget& budget)
 {
     gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::SWEEP_ATOMS_TABLE);
 
     auto& maybeAtoms = maybeAtomsToSweep.ref();
     if (!maybeAtoms)
         return Finished;
@@ -5777,17 +5721,17 @@ class IncrementalSweepWeakCacheTask : pu
                 break;
 
             cache_ = work_.next(lock);
         } while(cache_);
     }
 };
 
 /* static */ IncrementalProgress
-GCRuntime::sweepWeakCaches(GCRuntime* gc, SliceBudget& budget)
+GCRuntime::sweepWeakCaches(GCRuntime* gc, FreeOp* fop, SliceBudget& budget)
 {
     return gc->sweepWeakCaches(budget);
 }
 
 static const size_t MaxWeakCacheSweepTasks = 8;
 
 static size_t
 WeakCacheSweepTaskCount()
@@ -5812,17 +5756,17 @@ GCRuntime::sweepWeakCaches(SliceBudget& 
         // Tasks run until budget or work is exhausted.
     }
 
     AutoLockHelperThreadState lock;
     return work.empty(lock) ? Finished : NotFinished;
 }
 
 /* static */ IncrementalProgress
-GCRuntime::finalizeAllocKind(GCRuntime* gc, FreeOp* fop, Zone* zone, SliceBudget& budget,
+GCRuntime::finalizeAllocKind(GCRuntime* gc, FreeOp* fop, SliceBudget& budget, Zone* zone,
                              AllocKind kind)
 {
     // Set the number of things per arena for this AllocKind.
     size_t thingsPerArena = Arena::thingsPerArena(kind);
     auto& sweepList = gc->incrementalSweepList.ref();
     sweepList.setThingsPerArena(thingsPerArena);
 
     if (!zone->arenas.foregroundFinalize(fop, kind, budget, sweepList))
@@ -5830,142 +5774,306 @@ GCRuntime::finalizeAllocKind(GCRuntime* 
 
     // Reset the slots of the sweep list that we used.
     sweepList.reset(thingsPerArena);
 
     return Finished;
 }
 
 /* static */ IncrementalProgress
-GCRuntime::sweepShapeTree(GCRuntime* gc, FreeOp* fop, Zone* zone, SliceBudget& budget,
-                          AllocKind kind)
+GCRuntime::sweepShapeTree(GCRuntime* gc, FreeOp* fop, SliceBudget& budget, Zone* zone)
 {
     // Remove dead shapes from the shape tree, but don't finalize them yet.
 
-    MOZ_ASSERT(kind == AllocKind::LIMIT);
-
     gcstats::AutoPhase ap(gc->stats(), gcstats::PhaseKind::SWEEP_SHAPE);
 
     ArenaLists& al = zone->arenas;
 
     if (!SweepArenaList<Shape>(&al.gcShapeArenasToUpdate.ref(), budget))
         return NotFinished;
 
     if (!SweepArenaList<AccessorShape>(&al.gcAccessorShapeArenasToUpdate.ref(), budget))
         return NotFinished;
 
     return Finished;
 }
 
-static void
-AddPerSweepGroupSweepAction(bool* ok, PerSweepGroupSweepAction action)
-{
-    if (*ok)
-        *ok = PerSweepGroupSweepActions.emplaceBack(action);
-}
-
-static void
-AddPerZoneSweepPhase(bool* ok)
-{
-    if (*ok)
-        *ok = PerZoneSweepPhases.emplaceBack();
-}
-
-static void
-AddPerZoneSweepAction(bool* ok, PerZoneSweepAction::Func func, AllocKind kind = AllocKind::LIMIT)
-{
-    if (*ok)
-        *ok = PerZoneSweepPhases.back().emplaceBack(func, kind);
-}
-
-/* static */ bool
-GCRuntime::initializeSweepActions()
-{
-    bool ok = true;
-
-    AddPerSweepGroupSweepAction(&ok, GCRuntime::sweepAtomsTable);
-    AddPerSweepGroupSweepAction(&ok, GCRuntime::sweepWeakCaches);
-
-    AddPerZoneSweepPhase(&ok);
-    for (auto kind : ForegroundObjectFinalizePhase.kinds)
-        AddPerZoneSweepAction(&ok, GCRuntime::finalizeAllocKind, kind);
-
-    AddPerZoneSweepPhase(&ok);
-    AddPerZoneSweepAction(&ok, GCRuntime::sweepTypeInformation);
-    AddPerZoneSweepAction(&ok, GCRuntime::mergeSweptObjectArenas);
-
-    for (const auto& finalizePhase : IncrementalFinalizePhases) {
-        AddPerZoneSweepPhase(&ok);
-        for (auto kind : finalizePhase.kinds)
-            AddPerZoneSweepAction(&ok, GCRuntime::finalizeAllocKind, kind);
-    }
-
-    AddPerZoneSweepPhase(&ok);
-    AddPerZoneSweepAction(&ok, GCRuntime::sweepShapeTree);
-
-    return ok;
-}
-
-static inline SweepActionList
-NextSweepActionList(SweepActionList list)
-{
-    MOZ_ASSERT(list < SweepActionListCount);
-    return SweepActionList(unsigned(list) + 1);
+// An iterator for a standard container that provides an STL-like begin()/end()
+// interface. This iterator provides a done()/get()/next() style interface.
+template <typename Container>
+class ContainerIter
+{
+    using Iter = decltype(mozilla::DeclVal<const Container>().begin());
+    using Elem = decltype(*mozilla::DeclVal<Iter>());
+
+    Iter iter;
+    const Iter end;
+
+  public:
+    explicit ContainerIter(const Container& container)
+      : iter(container.begin()), end(container.end())
+    {}
+
+    bool done() const {
+        return iter == end;
+    }
+
+    Elem get() const {
+        return *iter;
+    }
+
+    void next() {
+        MOZ_ASSERT(!done());
+        ++iter;
+    }
+};
+
+// IncrementalIter is a template class that makes a normal iterator into one
+// that can be used to perform incremental work by using external state that
+// persists between instantiations. The state is only initialised on the first
+// use and subsequent uses carry on from the previous state.
+template <typename Iter>
+struct IncrementalIter
+{
+    using State = Maybe<Iter>;
+    using Elem = decltype(mozilla::DeclVal<Iter>().get());
+
+  private:
+    State& maybeIter;
+
+  public:
+    template <typename... Args>
+    explicit IncrementalIter(State& maybeIter, Args&&... args)
+      : maybeIter(maybeIter)
+    {
+        if (maybeIter.isNothing())
+            maybeIter.emplace(mozilla::Forward<Args>(args)...);
+    }
+
+    ~IncrementalIter() {
+        if (done())
+            maybeIter.reset();
+    }
+
+    bool done() const {
+        return maybeIter.ref().done();
+    }
+
+    Elem get() const {
+        return maybeIter.ref().get();
+    }
+
+    void next() {
+        maybeIter.ref().next();
+    }
+};
+
+// Implementation of the SweepAction interface that calls a function.
+template <typename... Args>
+class SweepActionFunc : public SweepAction<Args...>
+{
+    using Func = IncrementalProgress (*)(Args...);
+
+    Func func;
+
+  public:
+    explicit SweepActionFunc(Func f) : func(f) {}
+    IncrementalProgress run(Args... args) override {
+        return func(args...);
+    }
+    void assertFinished() const override { }
+};
+
+// Implementation of the SweepAction interface that calls a list of actions in
+// sequence.
+template <typename... Args>
+class SweepActionSequence : public SweepAction<Args...>
+{
+    using Action = SweepAction<Args...>;
+    using ActionVector = Vector<UniquePtr<Action>, 0, SystemAllocPolicy>;
+    using Iter = IncrementalIter<ContainerIter<ActionVector>>;
+
+    ActionVector actions;
+    typename Iter::State iterState;
+
+  public:
+    bool init(UniquePtr<Action>* acts, size_t count) {
+        for (size_t i = 0; i < count; i++) {
+            if (!actions.emplaceBack(Move(acts[i])))
+                return false;
+        }
+        return true;
+    }
+
+    IncrementalProgress run(Args... args) override {
+        for (Iter iter(iterState, actions); !iter.done(); iter.next()) {
+            if (iter.get()->run(args...) == NotFinished)
+                return NotFinished;
+        }
+        return Finished;
+    }
+
+    void assertFinished() const override {
+        MOZ_ASSERT(iterState.isNothing());
+        for (const auto& action : actions)
+            action->assertFinished();
+    }
+};
+
+template <typename Iter, typename Init, typename... Args>
+class SweepActionForEach : public SweepAction<Args...>
+{
+    using Elem = decltype(mozilla::DeclVal<Iter>().get());
+    using Action = SweepAction<Args..., Elem>;
+    using IncrIter = IncrementalIter<Iter>;
+
+    Init iterInit;
+    UniquePtr<Action> action;
+    typename IncrIter::State iterState;
+
+  public:
+    SweepActionForEach(const Init& init, UniquePtr<Action> action)
+      : iterInit(init), action(Move(action))
+    {}
+
+    IncrementalProgress run(Args... args) override {
+        for (IncrIter iter(iterState, iterInit); !iter.done(); iter.next()) {
+            if (action->run(args..., iter.get()) == NotFinished)
+                return NotFinished;
+        }
+        return Finished;
+    }
+
+    void assertFinished() const override {
+        MOZ_ASSERT(iterState.isNothing());
+        action->assertFinished();
+    }
+};
+
+// Helper class to remove the last template parameter from the instantiation of
+// a variadic template. For example:
+//
+//   RemoveLastTemplateParameter<Foo<X, Y, Z>>::Type ==> Foo<X, Y>
+//
+// This works by recursively instantiating the Impl template with the contents
+// of the parameter pack so long as there are at least two parameters. The
+// specialization that matches when only one parameter remains discards it and
+// instantiates the target template with parameters previously processed.
+template <typename T>
+class RemoveLastTemplateParameter {};
+
+template <template <typename...> class Target, typename... Args>
+class RemoveLastTemplateParameter<Target<Args...>>
+{
+    template <typename... Ts>
+    struct List {};
+
+    template <typename R, typename... Ts>
+    struct Impl {};
+
+    template <typename... Rs, typename T>
+    struct Impl<List<Rs...>, T>
+    {
+        using Type = Target<Rs...>;
+    };
+
+    template <typename... Rs, typename H, typename T, typename... Ts>
+    struct Impl<List<Rs...>, H, T, Ts...>
+    {
+        using Type = typename Impl<List<Rs..., H>, T, Ts...>::Type;
+    };
+
+  public:
+    using Type = typename Impl<List<>, Args...>::Type;
+};
+
+template <typename... Args>
+static UniquePtr<SweepAction<Args...>>
+SweepFunc(IncrementalProgress (*func)(Args...)) {
+    return MakeUnique<SweepActionFunc<Args...>>(func);
+}
+
+template <typename... Args, typename... Rest>
+static UniquePtr<SweepAction<Args...>>
+SweepSequence(UniquePtr<SweepAction<Args...>> first, Rest... rest)
+{
+    UniquePtr<SweepAction<Args...>> actions[] = { Move(first), Move(rest)... };
+    auto seq = MakeUnique<SweepActionSequence<Args...>>();
+    if (!seq || !seq->init(actions, ArrayLength(actions)))
+        return nullptr;
+
+    return UniquePtr<SweepAction<Args...>>(Move(seq));
+}
+
+template <typename... Args>
+static UniquePtr<typename RemoveLastTemplateParameter<SweepAction<Args...>>::Type>
+SweepForEachZone(JSRuntime* rt, UniquePtr<SweepAction<Args...>> action)
+{
+    if (!action)
+        return nullptr;
+
+    using Action = typename RemoveLastTemplateParameter<
+        SweepActionForEach<GCSweepGroupIter, JSRuntime*, Args...>>::Type;
+    return js::MakeUnique<Action>(rt, Move(action));
+}
+
+template <typename... Args>
+static UniquePtr<typename RemoveLastTemplateParameter<SweepAction<Args...>>::Type>
+SweepForEachAllocKind(AllocKinds kinds, UniquePtr<SweepAction<Args...>> action)
+{
+    if (!action)
+        return nullptr;
+
+    using Action = typename RemoveLastTemplateParameter<
+        SweepActionForEach<ContainerIter<AllocKinds>, AllocKinds, Args...>>::Type;
+    return js::MakeUnique<Action>(kinds, Move(action));
+}
+
+bool
+GCRuntime::initSweepActions()
+{
+    sweepActions.ref() = SweepSequence(
+        SweepFunc(sweepAtomsTable),
+        SweepFunc(sweepWeakCaches),
+        SweepForEachZone(rt,
+            SweepForEachAllocKind(ForegroundObjectFinalizePhase.kinds,
+                SweepFunc(finalizeAllocKind))),
+        SweepForEachZone(rt,
+            SweepSequence(
+                SweepFunc(sweepTypeInformation),
+                SweepFunc(mergeSweptObjectArenas))),
+        SweepForEachZone(rt,
+            SweepForEachAllocKind(IncrementalFinalizePhases[0].kinds,
+                SweepFunc(finalizeAllocKind))),
+        SweepForEachZone(rt,
+            SweepForEachAllocKind(IncrementalFinalizePhases[1].kinds,
+                SweepFunc(finalizeAllocKind))),
+        SweepForEachZone(rt,
+            SweepFunc(sweepShapeTree)));
+
+    static_assert(ArrayLength(IncrementalFinalizePhases) == 2,
+                  "We must have a phase for each element in IncrementalFinalizePhases");
+
+    return sweepActions != nullptr;
 }
 
 IncrementalProgress
 GCRuntime::performSweepActions(SliceBudget& budget, AutoLockForExclusiveAccess& lock)
 {
     AutoSetThreadIsSweeping threadIsSweeping;
 
     gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::SWEEP);
     FreeOp fop(rt);
 
     if (drainMarkStack(budget, gcstats::PhaseKind::SWEEP_MARK) == NotFinished)
         return NotFinished;
 
     for (;;) {
-        for (; sweepActionList < SweepActionListCount;
-             sweepActionList = NextSweepActionList(sweepActionList))
-        {
-            switch (sweepActionList) {
-              case PerSweepGroupActionList: {
-                const auto& actions = PerSweepGroupSweepActions;
-                for (; sweepActionIndex < actions.length(); sweepActionIndex++) {
-                    auto action = actions[sweepActionIndex];
-                    if (action(this, budget) == NotFinished)
-                        return NotFinished;
-                }
-                sweepActionIndex = 0;
-                break;
-              }
-
-              case PerZoneActionList:
-                for (; sweepPhaseIndex < PerZoneSweepPhases.length(); sweepPhaseIndex++) {
-                    const auto& actions = PerZoneSweepPhases[sweepPhaseIndex];
-                    if (!sweepZone)
-                        sweepZone = currentSweepGroup;
-                    for (; sweepZone; sweepZone = sweepZone->nextNodeInGroup()) {
-                        for (; sweepActionIndex < actions.length(); sweepActionIndex++) {
-                            const auto& action = actions[sweepActionIndex];
-                            if (action.func(this, &fop, sweepZone, budget, action.kind) == NotFinished)
-                                return NotFinished;
-                        }
-                        sweepActionIndex = 0;
-                    }
-                    sweepZone = nullptr;
-                }
-                sweepPhaseIndex = 0;
-                break;
-
-              default:
-                MOZ_CRASH("Unexpected sweepActionList value");
-            }
-        }
-        sweepActionList = PerSweepGroupActionList;
+        if (sweepActions->run(this, &fop, budget) == NotFinished)
+           return NotFinished;
 
         endSweepingSweepGroup();
         getNextSweepGroup();
         if (!currentSweepGroup)
             return Finished;
 
         endMarkingSweepGroup();
         beginSweepingSweepGroup();
@@ -7788,45 +7896,29 @@ js::gc::AssertGCThingHasType(js::gc::Cel
     else
         MOZ_ASSERT(MapAllocToTraceKind(cell->asTenured().getAllocKind()) == kind);
 }
 #endif
 
 JS::AutoAssertNoGC::AutoAssertNoGC(JSContext* maybecx)
   : cx_(maybecx ? maybecx : TlsContext.get())
 {
-    cx_->inUnsafeRegion++;
+    if (cx_)
+        cx_->inUnsafeRegion++;
 }
 
 JS::AutoAssertNoGC::~AutoAssertNoGC()
 {
-    MOZ_ASSERT(cx_->inUnsafeRegion > 0);
-    cx_->inUnsafeRegion--;
+    if (cx_) {
+        MOZ_ASSERT(cx_->inUnsafeRegion > 0);
+        cx_->inUnsafeRegion--;
+    }
 }
 
 #ifdef DEBUG
-JS::AutoAssertNoAlloc::AutoAssertNoAlloc(JSContext* cx)
-  : gc(nullptr)
-{
-    disallowAlloc(cx->runtime());
-}
-
-void JS::AutoAssertNoAlloc::disallowAlloc(JSRuntime* rt)
-{
-    MOZ_ASSERT(!gc);
-    gc = &rt->gc;
-    TlsContext.get()->disallowAlloc();
-}
-
-JS::AutoAssertNoAlloc::~AutoAssertNoAlloc()
-{
-    if (gc)
-        TlsContext.get()->allowAlloc();
-}
-
 AutoAssertNoNurseryAlloc::AutoAssertNoNurseryAlloc()
 {
     TlsContext.get()->disallowNurseryAlloc();
 }
 
 AutoAssertNoNurseryAlloc::~AutoAssertNoNurseryAlloc()
 {
     TlsContext.get()->allowNurseryAlloc();
diff --git a/js/src/jsgcinlines.h b/js/src/jsgcinlines.h
--- a/js/src/jsgcinlines.h
+++ b/js/src/jsgcinlines.h
@@ -433,17 +433,16 @@ class GCZonesIter
     operator JS::Zone*() const { return get(); }
     JS::Zone* operator->() const { return get(); }
 };
 
 typedef CompartmentsIterT<GCZonesIter> GCCompartmentsIter;
 
 /* Iterates over all zones in the current sweep group. */
 class GCSweepGroupIter {
-  private:
     JS::Zone* current;
 
   public:
     explicit GCSweepGroupIter(JSRuntime* rt) {
         MOZ_ASSERT(CurrentThreadIsPerformingGC());
         current = rt->gc.getCurrentSweepGroup();
     }
 
diff --git a/js/src/vm/ArrayBufferObject.cpp b/js/src/vm/ArrayBufferObject.cpp
--- a/js/src/vm/ArrayBufferObject.cpp
+++ b/js/src/vm/ArrayBufferObject.cpp
@@ -1610,17 +1610,17 @@ js::UnwrapArrayBufferView(JSObject* obj)
 JS_FRIEND_API(uint32_t)
 JS_GetArrayBufferByteLength(JSObject* obj)
 {
     obj = CheckedUnwrap(obj);
     return obj ? AsArrayBuffer(obj).byteLength() : 0;
 }
 
 JS_FRIEND_API(uint8_t*)
-JS_GetArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     if (!IsArrayBuffer(obj))
         return nullptr;
     *isSharedMemory = false;
     return AsArrayBuffer(obj).dataPointer();
@@ -1827,17 +1827,17 @@ JS_IsMappedArrayBufferObject(JSObject* o
     obj = CheckedUnwrap(obj);
     if (!obj)
         return false;
 
     return obj->is<ArrayBufferObject>() && obj->as<ArrayBufferObject>().isMapped();
 }
 
 JS_FRIEND_API(void*)
-JS_GetArrayBufferViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetArrayBufferViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     if (obj->is<DataViewObject>()) {
         DataViewObject& dv = obj->as<DataViewObject>();
         *isSharedMemory = dv.isSharedMemory();
         return dv.dataPointerEither().unwrap(/*safe - caller sees isSharedMemory flag*/);
diff --git a/js/src/vm/Debugger.cpp b/js/src/vm/Debugger.cpp
--- a/js/src/vm/Debugger.cpp
+++ b/js/src/vm/Debugger.cpp
@@ -27,16 +27,18 @@
 #include "jit/BaselineDebugModeOSR.h"
 #include "jit/BaselineJIT.h"
 #include "js/Date.h"
 #include "js/GCAPI.h"
 #include "js/UbiNodeBreadthFirst.h"
 #include "js/Vector.h"
 #include "proxy/ScriptedProxyHandler.h"
 #include "vm/ArgumentsObject.h"
+#include "vm/AsyncFunction.h"
+#include "vm/AsyncIteration.h"
 #include "vm/DebuggerMemory.h"
 #include "vm/GeckoProfiler.h"
 #include "vm/GeneratorObject.h"
 #include "vm/TraceLogging.h"
 #include "vm/WrapperObject.h"
 #include "wasm/WasmInstance.h"
 
 #include "jsgcinlines.h"
@@ -222,16 +224,44 @@ static const Class DebuggerSource_class 
     JSCLASS_HAS_PRIVATE |
     JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGSOURCE_COUNT),
     &DebuggerSource_classOps
 };
 
 
 /*** Utils ***************************************************************************************/
 
+/*
+ * If fun is an interpreted function, remove any async function/generator
+ * wrapper and return the underlying scripted function. Otherwise, return fun
+ * unchanged.
+ *
+ * Async functions are implemented as native functions wrapped around a scripted
+ * function. JSScripts hold ordinary inner JSFunctions in their object arrays,
+ * and when we need to actually create a JS-visible function object, we build an
+ * ordinary JS closure and apply the async wrapper to it. Async generators are
+ * similar.
+ *
+ * This means that JSFunction::isInterpreted returns false for such functions,
+ * even though their actual code is indeed JavaScript. Debugger should treat
+ * async functions and generators like any other scripted function, so we must
+ * carefully check for them whenever we want inspect a function.
+ */
+
+static JSFunction*
+RemoveAsyncWrapper(JSFunction *fun)
+{
+    if (js::IsWrappedAsyncFunction(fun))
+        fun = js::GetUnwrappedAsyncFunction(fun);
+    else if (js::IsWrappedAsyncGenerator(fun))
+        fun = js::GetUnwrappedAsyncGenerator(fun);
+
+    return fun;
+}
+
 static inline bool
 EnsureFunctionHasScript(JSContext* cx, HandleFunction fun)
 {
     if (fun->isInterpretedLazy()) {
         AutoCompartment ac(cx, fun);
         return !!JSFunction::getOrCreateScript(cx, fun);
     }
     return true;
@@ -8780,38 +8810,39 @@ static bool
 DebuggerFrame_getScript(JSContext* cx, unsigned argc, Value* vp)
 {
     THIS_FRAME(cx, argc, vp, "get script", args, thisobj, frame);
     Debugger* debug = Debugger::fromChildJSObject(thisobj);
 
     RootedObject scriptObject(cx);
     if (frame.isFunctionFrame()) {
         RootedFunction callee(cx, frame.callee());
-        if (callee->isInterpreted()) {
-            RootedScript script(cx, callee->nonLazyScript());
-            scriptObject = debug->wrapScript(cx, script);
-            if (!scriptObject)
-                return false;
-        }
+        MOZ_ASSERT(callee->isInterpreted());
+        RootedScript script(cx, callee->nonLazyScript());
+        scriptObject = debug->wrapScript(cx, script);
+        if (!scriptObject)
+            return false;
     } else if (frame.isWasmDebugFrame()) {
         RootedWasmInstanceObject instance(cx, frame.wasmInstance()->object());
         scriptObject = debug->wrapWasmScript(cx, instance);
         if (!scriptObject)
             return false;
     } else {
         /*
          * We got eval, JS_Evaluate*, or JS_ExecuteScript non-function script
          * frames.
          */
         RootedScript script(cx, frame.script());
         scriptObject = debug->wrapScript(cx, script);
         if (!scriptObject)
             return false;
     }
-    args.rval().setObjectOrNull(scriptObject);
+
+    MOZ_ASSERT(scriptObject);
+    args.rval().setObject(*scriptObject);
     return true;
 }
 
 /* static */ bool
 DebuggerFrame::offsetGetter(JSContext* cx, unsigned argc, Value* vp)
 {
     THIS_DEBUGGER_FRAME(cx, argc, vp, "get offset", args, frame);
 
@@ -9241,17 +9272,17 @@ DebuggerObject::scriptGetter(JSContext* 
 {
     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get script", args, dbg, obj);
 
     if (!obj->is<JSFunction>()) {
         args.rval().setUndefined();
         return true;
     }
 
-    RootedFunction fun(cx, &obj->as<JSFunction>());
+    RootedFunction fun(cx, RemoveAsyncWrapper(&obj->as<JSFunction>()));
     if (!fun->isInterpreted()) {
         args.rval().setUndefined();
         return true;
     }
 
     RootedScript script(cx, GetOrCreateFunctionScript(cx, fun));
     if (!script)
         return false;
@@ -9271,31 +9302,36 @@ DebuggerObject::scriptGetter(JSContext* 
 }
 
 /* static */ bool
 DebuggerObject::environmentGetter(JSContext* cx, unsigned argc, Value* vp)
 {
     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get environment", args, dbg, obj);
 
     /* Don't bother switching compartments just to check obj's type and get its env. */
-    if (!obj->is<JSFunction>() || !obj->as<JSFunction>().isInterpreted()) {
+    if (!obj->is<JSFunction>()) {
+        args.rval().setUndefined();
+        return true;
+    }
+
+    RootedFunction fun(cx, RemoveAsyncWrapper(&obj->as<JSFunction>()));
+    if (!fun->isInterpreted()) {
         args.rval().setUndefined();
         return true;
     }
 
     /* Only hand out environments of debuggee functions. */
-    if (!dbg->observesGlobal(&obj->global())) {
+    if (!dbg->observesGlobal(&fun->global())) {
         args.rval().setNull();
         return true;
     }
 
     Rooted<Env*> env(cx);
     {
-        AutoCompartment ac(cx, obj);
-        RootedFunction fun(cx, &obj->as<JSFunction>());
+        AutoCompartment ac(cx, fun);
         env = GetDebugEnvironmentForFunction(cx, fun);
         if (!env)
             return false;
     }
 
     return dbg->wrapEnvironment(cx, env, args.rval());
 }
 
@@ -10172,17 +10208,17 @@ DebuggerObject::isBoundFunction() const
     return referent()->isBoundFunction();
 }
 
 bool
 DebuggerObject::isArrowFunction() const
 {
     MOZ_ASSERT(isDebuggeeFunction());
 
-    return referent()->as<JSFunction>().isArrow();
+    return RemoveAsyncWrapper(&referent()->as<JSFunction>())->isArrow();
 }
 
 bool
 DebuggerObject::isGlobal() const
 {
     return referent()->is<GlobalObject>();
 }
 
@@ -10280,17 +10316,17 @@ DebuggerObject::promiseTimeToResolution(
 }
 
 /* static */ bool
 DebuggerObject::getParameterNames(JSContext* cx, HandleDebuggerObject object,
                                   MutableHandle<StringVector> result)
 {
     MOZ_ASSERT(object->isDebuggeeFunction());
 
-    RootedFunction referent(cx, &object->referent()->as<JSFunction>());
+    RootedFunction referent(cx, RemoveAsyncWrapper(&object->referent()->as<JSFunction>()));
 
     if (!result.growBy(referent->nargs()))
         return false;
     if (referent->isInterpreted()) {
         RootedScript script(cx, GetOrCreateFunctionScript(cx, referent));
         if (!script)
             return false;
 
diff --git a/js/src/vm/Initialization.cpp b/js/src/vm/Initialization.cpp
--- a/js/src/vm/Initialization.cpp
+++ b/js/src/vm/Initialization.cpp
@@ -101,17 +101,16 @@ JS::detail::InitWithFailureDiagnostic(bo
     js::oom::SetThreadType(js::oom::THREAD_TYPE_COOPERATING);
 #endif
 
     RETURN_IF_FAIL(js::Mutex::Init());
 
     RETURN_IF_FAIL(js::wasm::InitInstanceStaticData());
 
     js::gc::InitMemorySubsystem(); // Ensure gc::SystemPageSize() works.
-    RETURN_IF_FAIL(js::gc::InitializeStaticData());
 
     RETURN_IF_FAIL(js::jit::InitProcessExecutableMemory());
 
     MOZ_ALWAYS_TRUE(js::MemoryProtectionExceptionHandler::install());
 
     RETURN_IF_FAIL(js::jit::InitializeIon());
 
     RETURN_IF_FAIL(js::InitDateTimeState());
diff --git a/js/src/vm/SharedArrayObject.cpp b/js/src/vm/SharedArrayObject.cpp
--- a/js/src/vm/SharedArrayObject.cpp
+++ b/js/src/vm/SharedArrayObject.cpp
@@ -508,16 +508,16 @@ JS_NewSharedArrayBuffer(JSContext* cx, u
 JS_FRIEND_API(bool)
 JS_IsSharedArrayBufferObject(JSObject* obj)
 {
     obj = CheckedUnwrap(obj);
     return obj ? obj->is<SharedArrayBufferObject>() : false;
 }
 
 JS_FRIEND_API(uint8_t*)
-JS_GetSharedArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetSharedArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     *isSharedMemory = true;
     return obj->as<SharedArrayBufferObject>().dataPointerShared().unwrap(/*safe - caller knows*/);
 }
diff --git a/js/src/vm/String.h b/js/src/vm/String.h
--- a/js/src/vm/String.h
+++ b/js/src/vm/String.h
@@ -647,52 +647,52 @@ class JSLinearString : public JSString
     }
 
     MOZ_ALWAYS_INLINE const JS::Latin1Char* rawLatin1Chars() const;
     MOZ_ALWAYS_INLINE const char16_t* rawTwoByteChars() const;
 
   public:
     template<typename CharT>
     MOZ_ALWAYS_INLINE
-    const CharT* nonInlineChars(const JS::AutoCheckCannotGC& nogc) const;
+    const CharT* nonInlineChars(const JS::AutoRequireNoGC& nogc) const;
 
     MOZ_ALWAYS_INLINE
-    const JS::Latin1Char* nonInlineLatin1Chars(const JS::AutoCheckCannotGC& nogc) const {
+    const JS::Latin1Char* nonInlineLatin1Chars(const JS::AutoRequireNoGC& nogc) const {
         MOZ_ASSERT(!isInline());
         MOZ_ASSERT(hasLatin1Chars());
         return d.s.u2.nonInlineCharsLatin1;
     }
 
     MOZ_ALWAYS_INLINE
-    const char16_t* nonInlineTwoByteChars(const JS::AutoCheckCannotGC& nogc) const {
+    const char16_t* nonInlineTwoByteChars(const JS::AutoRequireNoGC& nogc) const {
         MOZ_ASSERT(!isInline());
         MOZ_ASSERT(hasTwoByteChars());
         return d.s.u2.nonInlineCharsTwoByte;
     }
 
     template<typename CharT>
     MOZ_ALWAYS_INLINE
-    const CharT* chars(const JS::AutoCheckCannotGC& nogc) const;
+    const CharT* chars(const JS::AutoRequireNoGC& nogc) const;
 
     MOZ_ALWAYS_INLINE
-    const JS::Latin1Char* latin1Chars(const JS::AutoCheckCannotGC& nogc) const {
+    const JS::Latin1Char* latin1Chars(const JS::AutoRequireNoGC& nogc) const {
         return rawLatin1Chars();
     }
 
     MOZ_ALWAYS_INLINE
-    const char16_t* twoByteChars(const JS::AutoCheckCannotGC& nogc) const {
+    const char16_t* twoByteChars(const JS::AutoRequireNoGC& nogc) const {
         return rawTwoByteChars();
     }
 
-    mozilla::Range<const JS::Latin1Char> latin1Range(const JS::AutoCheckCannotGC& nogc) const {
+    mozilla::Range<const JS::Latin1Char> latin1Range(const JS::AutoRequireNoGC& nogc) const {
         MOZ_ASSERT(JSString::isLinear());
         return mozilla::Range<const JS::Latin1Char>(latin1Chars(nogc), length());
     }
 
-    mozilla::Range<const char16_t> twoByteRange(const JS::AutoCheckCannotGC& nogc) const {
+    mozilla::Range<const char16_t> twoByteRange(const JS::AutoRequireNoGC& nogc) const {
         MOZ_ASSERT(JSString::isLinear());
         return mozilla::Range<const char16_t>(twoByteChars(nogc), length());
     }
 
     MOZ_ALWAYS_INLINE
     char16_t latin1OrTwoByteChar(size_t index) const {
         MOZ_ASSERT(JSString::isLinear());
         MOZ_ASSERT(index < length());
@@ -859,24 +859,24 @@ class JSExtensibleString : public JSFlat
 
 static_assert(sizeof(JSExtensibleString) == sizeof(JSString),
               "string subclasses must be binary-compatible with JSString");
 
 class JSInlineString : public JSFlatString
 {
   public:
     MOZ_ALWAYS_INLINE
-    const JS::Latin1Char* latin1Chars(const JS::AutoCheckCannotGC& nogc) const {
+    const JS::Latin1Char* latin1Chars(const JS::AutoRequireNoGC& nogc) const {
         MOZ_ASSERT(JSString::isInline());
         MOZ_ASSERT(hasLatin1Chars());
         return d.inlineStorageLatin1;
     }
 
     MOZ_ALWAYS_INLINE
-    const char16_t* twoByteChars(const JS::AutoCheckCannotGC& nogc) const {
+    const char16_t* twoByteChars(const JS::AutoRequireNoGC& nogc) const {
         MOZ_ASSERT(JSString::isInline());
         MOZ_ASSERT(hasTwoByteChars());
         return d.inlineStorageTwoByte;
     }
 
     template<typename CharT>
     static bool lengthFits(size_t length);
 
@@ -1419,38 +1419,38 @@ JSString::base() const
 {
     MOZ_ASSERT(hasBase());
     MOZ_ASSERT(!d.s.u3.base->isInline());
     return d.s.u3.base;
 }
 
 template<>
 MOZ_ALWAYS_INLINE const char16_t*
-JSLinearString::nonInlineChars(const JS::AutoCheckCannotGC& nogc) const
+JSLinearString::nonInlineChars(const JS::AutoRequireNoGC& nogc) const
 {
     return nonInlineTwoByteChars(nogc);
 }
 
 template<>
 MOZ_ALWAYS_INLINE const JS::Latin1Char*
-JSLinearString::nonInlineChars(const JS::AutoCheckCannotGC& nogc) const
+JSLinearString::nonInlineChars(const JS::AutoRequireNoGC& nogc) const
 {
     return nonInlineLatin1Chars(nogc);
 }
 
 template<>
 MOZ_ALWAYS_INLINE const char16_t*
-JSLinearString::chars(const JS::AutoCheckCannotGC& nogc) const
+JSLinearString::chars(const JS::AutoRequireNoGC& nogc) const
 {
     return rawTwoByteChars();
 }
 
 template<>
 MOZ_ALWAYS_INLINE const JS::Latin1Char*
-JSLinearString::chars(const JS::AutoCheckCannotGC& nogc) const
+JSLinearString::chars(const JS::AutoRequireNoGC& nogc) const
 {
     return rawLatin1Chars();
 }
 
 template <>
 MOZ_ALWAYS_INLINE bool
 JSRope::copyChars<JS::Latin1Char>(JSContext* cx,
                                   js::ScopedJSFreePtr<JS::Latin1Char>& out) const
diff --git a/js/src/vm/TypedArrayObject.cpp b/js/src/vm/TypedArrayObject.cpp
--- a/js/src/vm/TypedArrayObject.cpp
+++ b/js/src/vm/TypedArrayObject.cpp
@@ -2344,113 +2344,113 @@ JS_GetArrayBufferViewType(JSObject* obj)
     if (obj->is<TypedArrayObject>())
         return obj->as<TypedArrayObject>().type();
     if (obj->is<DataViewObject>())
         return Scalar::MaxTypedArrayViewType;
     MOZ_CRASH("invalid ArrayBufferView type");
 }
 
 JS_FRIEND_API(int8_t*)
-JS_GetInt8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetInt8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();
     MOZ_ASSERT((int32_t) tarr->type() == Scalar::Int8);
     *isSharedMemory = tarr->isSharedMemory();
     return static_cast<int8_t*>(tarr->viewDataEither().unwrap(/*safe - caller sees isShared*/));
 }
 
 JS_FRIEND_API(uint8_t*)
-JS_GetUint8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetUint8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();
     MOZ_ASSERT((int32_t) tarr->type() == Scalar::Uint8);
     *isSharedMemory = tarr->isSharedMemory();
     return static_cast<uint8_t*>(tarr->viewDataEither().unwrap(/*safe - caller sees isSharedMemory*/));
 }
 
 JS_FRIEND_API(uint8_t*)
-JS_GetUint8ClampedArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetUint8ClampedArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();
     MOZ_ASSERT((int32_t) tarr->type() == Scalar::Uint8Clamped);
     *isSharedMemory = tarr->isSharedMemory();
     return static_cast<uint8_t*>(tarr->viewDataEither().unwrap(/*safe - caller sees isSharedMemory*/));
 }
 
 JS_FRIEND_API(int16_t*)
-JS_GetInt16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetInt16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();
     MOZ_ASSERT((int32_t) tarr->type() == Scalar::Int16);
     *isSharedMemory = tarr->isSharedMemory();
     return static_cast<int16_t*>(tarr->viewDataEither().unwrap(/*safe - caller sees isSharedMemory*/));
 }
 
 JS_FRIEND_API(uint16_t*)
-JS_GetUint16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetUint16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();
     MOZ_ASSERT((int32_t) tarr->type() == Scalar::Uint16);
     *isSharedMemory = tarr->isSharedMemory();
     return static_cast<uint16_t*>(tarr->viewDataEither().unwrap(/*safe - caller sees isSharedMemory*/));
 }
 
 JS_FRIEND_API(int32_t*)
-JS_GetInt32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetInt32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();
     MOZ_ASSERT((int32_t) tarr->type() == Scalar::Int32);
     *isSharedMemory = tarr->isSharedMemory();
     return static_cast<int32_t*>(tarr->viewDataEither().unwrap(/*safe - caller sees isSharedMemory*/));
 }
 
 JS_FRIEND_API(uint32_t*)
-JS_GetUint32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetUint32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();
     MOZ_ASSERT((int32_t) tarr->type() == Scalar::Uint32);
     *isSharedMemory = tarr->isSharedMemory();
     return static_cast<uint32_t*>(tarr->viewDataEither().unwrap(/*safe - caller sees isSharedMemory*/));
 }
 
 JS_FRIEND_API(float*)
-JS_GetFloat32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetFloat32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();
     MOZ_ASSERT((int32_t) tarr->type() == Scalar::Float32);
     *isSharedMemory = tarr->isSharedMemory();
     return static_cast<float*>(tarr->viewDataEither().unwrap(/*safe - caller sees isSharedMemory*/));
 }
 
 JS_FRIEND_API(double*)
-JS_GetFloat64ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&)
+JS_GetFloat64ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&)
 {
     obj = CheckedUnwrap(obj);
     if (!obj)
         return nullptr;
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();
     MOZ_ASSERT((int32_t) tarr->type() == Scalar::Float64);
     *isSharedMemory = tarr->isSharedMemory();
     return static_cast<double*>(tarr->viewDataEither().unwrap(/*safe - caller sees isSharedMemory*/));
diff --git a/js/src/wasm/AsmJS.cpp b/js/src/wasm/AsmJS.cpp
--- a/js/src/wasm/AsmJS.cpp
+++ b/js/src/wasm/AsmJS.cpp
@@ -8489,19 +8489,20 @@ struct ScopedCacheEntryOpenedForRead
 
 static JS::AsmJSCacheResult
 StoreAsmJSModuleInCache(AsmJSParser& parser, Module& module, JSContext* cx)
 {
     ModuleCharsForStore moduleChars;
     if (!moduleChars.init(parser))
         return JS::AsmJSCache_InternalError;
 
-    size_t bytecodeSize, compiledSize;
-    module.serializedSize(&bytecodeSize, &compiledSize);
+    size_t bytecodeSize = module.bytecodeSerializedSize();
     MOZ_RELEASE_ASSERT(bytecodeSize == 0);
+
+    size_t compiledSize = module.compiledSerializedSize();
     MOZ_RELEASE_ASSERT(compiledSize <= UINT32_MAX);
 
     size_t serializedSize = sizeof(uint32_t) +
                             compiledSize +
                             moduleChars.serializedSize();
 
     JS::OpenAsmJSCacheEntryForWriteOp open = cx->asmJSCacheOps().openEntryForWrite;
     if (!open)
@@ -8519,17 +8520,17 @@ StoreAsmJSModuleInCache(AsmJSParser& par
     uint8_t* cursor = entry.memory;
 
     // Everything serialized before the Module must not change incompatibly
     // between any two builds (regardless of platform, architecture, ...).
     // (The Module::assumptionsMatch() guard everything in the Module and
     // afterwards.)
     cursor = WriteScalar<uint32_t>(cursor, compiledSize);
 
-    module.serialize(/* bytecodeBegin = */ nullptr, /* bytecodeSize = */ 0, cursor, compiledSize);
+    module.compiledSerialize(cursor, compiledSize);
     cursor += compiledSize;
 
     cursor = moduleChars.serialize(cursor);
 
     MOZ_RELEASE_ASSERT(cursor == entry.memory + serializedSize);
 
     return JS::AsmJSCache_Success;
 }
diff --git a/js/src/wasm/WasmModule.cpp b/js/src/wasm/WasmModule.cpp
--- a/js/src/wasm/WasmModule.cpp
+++ b/js/src/wasm/WasmModule.cpp
@@ -208,75 +208,75 @@ LinkData::deserialize(const uint8_t* cur
 }
 
 size_t
 LinkData::sizeOfExcludingThis(MallocSizeOf mallocSizeOf) const
 {
     return tier_->sizeOfExcludingThis(mallocSizeOf);
 }
 
-/* virtual */ void
-Module::serializedSize(size_t* maybeBytecodeSize, size_t* maybeCompiledSize) const
+/* virtual */ size_t
+Module::bytecodeSerializedSize() const
 {
-    if (maybeBytecodeSize)
-        *maybeBytecodeSize = bytecode_->bytes.length();
-
-    // The compiled debug code must not be saved, set compiled size to 0,
-    // so Module::assumptionsMatch will return false during assumptions
-    // deserialization.
-    if (maybeCompiledSize && metadata().debugEnabled)
-        *maybeCompiledSize = 0;
-
-    if (maybeCompiledSize && !metadata().debugEnabled) {
-        *maybeCompiledSize = assumptions_.serializedSize() +
-                             linkData_.serializedSize() +
-                             SerializedVectorSize(imports_) +
-                             SerializedVectorSize(exports_) +
-                             SerializedPodVectorSize(dataSegments_) +
-                             SerializedVectorSize(elemSegments_) +
-                             code_->serializedSize();
-    }
+    return bytecode_->bytes.length();
 }
 
 /* virtual */ void
-Module::serialize(uint8_t* maybeBytecodeBegin, size_t maybeBytecodeSize,
-                  uint8_t* maybeCompiledBegin, size_t maybeCompiledSize) const
+Module::bytecodeSerialize(uint8_t* bytecodeBegin, size_t bytecodeSize) const
 {
-    MOZ_ASSERT(!!maybeBytecodeBegin == !!maybeBytecodeSize);
-    MOZ_ASSERT(!!maybeCompiledBegin == !!maybeCompiledSize);
+    MOZ_ASSERT(!!bytecodeBegin == !!bytecodeSize);
+
+    // Bytecode deserialization is not guarded by Assumptions and thus must not
+    // change incompatibly between builds. For simplicity, the format of the
+    // bytecode file is a .wasm file which ensures backwards compatibility.
+
+    const Bytes& bytes = bytecode_->bytes;
+    uint8_t* bytecodeEnd = WriteBytes(bytecodeBegin, bytes.begin(), bytes.length());
+    MOZ_RELEASE_ASSERT(bytecodeEnd == bytecodeBegin + bytecodeSize);
+}
 
-    if (maybeBytecodeBegin) {
-        // Bytecode deserialization is not guarded by Assumptions and thus must not
-        // change incompatibly between builds. Thus, for simplicity, the format
-        // of the bytecode file is simply a .wasm file (thus, backwards
-        // compatibility is ensured by backwards compatibility of the wasm
-        // binary format).
+/* virtual */ size_t
+Module::compiledSerializedSize() const
+{
+    // The compiled debug code must not be saved, set compiled size to 0,
+    // so Module::assumptionsMatch will return false during assumptions
+    // deserialization.
+    if (metadata().debugEnabled)
+        return 0;
 
-        const Bytes& bytes = bytecode_->bytes;
-        uint8_t* bytecodeEnd = WriteBytes(maybeBytecodeBegin, bytes.begin(), bytes.length());
-        MOZ_RELEASE_ASSERT(bytecodeEnd == maybeBytecodeBegin + maybeBytecodeSize);
+    return assumptions_.serializedSize() +
+           linkData_.serializedSize() +
+           SerializedVectorSize(imports_) +
+           SerializedVectorSize(exports_) +
+           SerializedPodVectorSize(dataSegments_) +
+           SerializedVectorSize(elemSegments_) +
+           code_->serializedSize();
+}
+
+/* virtual */ void
+Module::compiledSerialize(uint8_t* compiledBegin, size_t compiledSize) const
+{
+    if (metadata().debugEnabled) {
+        MOZ_RELEASE_ASSERT(compiledSize == 0);
+        return;
     }
 
-    MOZ_ASSERT_IF(maybeCompiledBegin && metadata().debugEnabled, maybeCompiledSize == 0);
-
-    if (maybeCompiledBegin && !metadata().debugEnabled) {
-        // Assumption must be serialized at the beginning of the compiled bytes so
-        // that compiledAssumptionsMatch can detect a build-id mismatch before any
-        // other decoding occurs.
+    // Assumption must be serialized at the beginning of the compiled bytes so
+    // that compiledAssumptionsMatch can detect a build-id mismatch before any
+    // other decoding occurs.
 
-        uint8_t* cursor = maybeCompiledBegin;
-        cursor = assumptions_.serialize(cursor);
-        cursor = linkData_.serialize(cursor);
-        cursor = SerializeVector(cursor, imports_);
-        cursor = SerializeVector(cursor, exports_);
-        cursor = SerializePodVector(cursor, dataSegments_);
-        cursor = SerializeVector(cursor, elemSegments_);
-        cursor = code_->serialize(cursor, linkData_);
-        MOZ_RELEASE_ASSERT(cursor == maybeCompiledBegin + maybeCompiledSize);
-    }
+    uint8_t* cursor = compiledBegin;
+    cursor = assumptions_.serialize(cursor);
+    cursor = linkData_.serialize(cursor);
+    cursor = SerializeVector(cursor, imports_);
+    cursor = SerializeVector(cursor, exports_);
+    cursor = SerializePodVector(cursor, dataSegments_);
+    cursor = SerializeVector(cursor, elemSegments_);
+    cursor = code_->serialize(cursor, linkData_);
+    MOZ_RELEASE_ASSERT(cursor == compiledBegin + compiledSize);
 }
 
 /* static */ bool
 Module::assumptionsMatch(const Assumptions& current, const uint8_t* compiledBegin, size_t remain)
 {
     Assumptions cached;
     if (!cached.deserialize(compiledBegin, remain))
         return false;
diff --git a/js/src/wasm/WasmModule.h b/js/src/wasm/WasmModule.h
--- a/js/src/wasm/WasmModule.h
+++ b/js/src/wasm/WasmModule.h
@@ -183,19 +183,21 @@ class Module : public JS::WasmModule
                      HandleWasmTableObject tableImport,
                      HandleWasmMemoryObject memoryImport,
                      const ValVector& globalImports,
                      HandleObject instanceProto,
                      MutableHandleWasmInstanceObject instanceObj) const;
 
     // Structured clone support:
 
-    void serializedSize(size_t* maybeBytecodeSize, size_t* maybeCompiledSize) const override;
-    void serialize(uint8_t* maybeBytecodeBegin, size_t maybeBytecodeSize,
-                   uint8_t* maybeCompiledBegin, size_t maybeCompiledSize) const override;
+    size_t bytecodeSerializedSize() const override;
+    void bytecodeSerialize(uint8_t* bytecodeBegin, size_t bytecodeSize) const override;
+    size_t compiledSerializedSize() const override;
+    void compiledSerialize(uint8_t* compiledBegin, size_t compiledSize) const override;
+
     static bool assumptionsMatch(const Assumptions& current, const uint8_t* compiledBegin,
                                  size_t remain);
     static RefPtr<Module> deserialize(const uint8_t* bytecodeBegin, size_t bytecodeSize,
                                       const uint8_t* compiledBegin, size_t compiledSize,
                                       Metadata* maybeMetadata = nullptr);
     JSObject* createObject(JSContext* cx) override;
 
     // about:memory reporting:
diff --git a/js/xpconnect/loader/ChromeScriptLoader.cpp b/js/xpconnect/loader/ChromeScriptLoader.cpp
--- a/js/xpconnect/loader/ChromeScriptLoader.cpp
+++ b/js/xpconnect/loader/ChromeScriptLoader.cpp
@@ -116,19 +116,17 @@ AsyncScriptCompiler::Start(nsIPrincipal*
 static void
 OffThreadScriptLoaderCallback(void* aToken, void* aCallbackData)
 {
     RefPtr<AsyncScriptCompiler> scriptCompiler = dont_AddRef(
         static_cast<AsyncScriptCompiler*>(aCallbackData));
 
     scriptCompiler->SetToken(aToken);
 
-    SystemGroup::Dispatch("ScriptLoader::FinishCompile",
-                          TaskCategory::Other,
-                          scriptCompiler.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, scriptCompiler.forget());
 }
 
 bool
 AsyncScriptCompiler::StartCompile(JSContext* aCx)
 {
     Rooted<JSObject*> global(aCx, mGlobalObject->GetGlobalJSObject());
 
     if (JS::CanCompileOffThread(aCx, mOptions, mScriptLength)) {
diff --git a/layout/base/PresShell.cpp b/layout/base/PresShell.cpp
--- a/layout/base/PresShell.cpp
+++ b/layout/base/PresShell.cpp
@@ -2023,18 +2023,17 @@ PresShell::ResizeReflowIgnoreOverride(ns
         mAsyncResizeEventTimer->InitWithNamedFuncCallback(AsyncResizeEventCallback,
                                                           this, 15,
                                                           nsITimer::TYPE_ONE_SHOT,
                                                           "AsyncResizeEventCallback");
       }
     } else {
       RefPtr<nsRunnableMethod<PresShell>> event = NewRunnableMethod(
         "PresShell::FireResizeEvent", this, &PresShell::FireResizeEvent);
-      nsresult rv = mDocument->Dispatch("PresShell::FireResizeEvent",
-                                        TaskCategory::Other,
+      nsresult rv = mDocument->Dispatch(TaskCategory::Other,
                                         do_AddRef(event));
       if (NS_SUCCEEDED(rv)) {
         mResizeEvent = Move(event);
         SetNeedStyleFlush();
       }
     }
   }
 
@@ -6221,19 +6220,17 @@ PresShell::ScheduleApproximateFrameVisib
     return;
   }
 
   RefPtr<nsRunnableMethod<PresShell>> event =
     NewRunnableMethod("PresShell::UpdateApproximateFrameVisibility",
                       this,
                       &PresShell::UpdateApproximateFrameVisibility);
   nsresult rv =
-    mDocument->Dispatch("PresShell::UpdateApproximateFrameVisibility",
-                        TaskCategory::Other,
-                        do_AddRef(event));
+    mDocument->Dispatch(TaskCategory::Other, do_AddRef(event));
 
   if (NS_SUCCEEDED(rv)) {
     mUpdateApproximateFrameVisibilityEvent = Move(event);
   }
 }
 
 void
 PresShell::EnsureFrameInApproximatelyVisibleList(nsIFrame* aFrame)
diff --git a/layout/base/ZoomConstraintsClient.cpp b/layout/base/ZoomConstraintsClient.cpp
--- a/layout/base/ZoomConstraintsClient.cpp
+++ b/layout/base/ZoomConstraintsClient.cpp
@@ -158,19 +158,17 @@ ZoomConstraintsClient::Observe(nsISuppor
     // We need to run this later because all the pref change listeners need
     // to execute before we can be guaranteed that gfxPrefs::ForceUserScalable()
     // returns the updated value.
 
     RefPtr<nsRunnableMethod<ZoomConstraintsClient>> event =
       NewRunnableMethod("ZoomConstraintsClient::RefreshZoomConstraints",
                         this,
                         &ZoomConstraintsClient::RefreshZoomConstraints);
-    mDocument->Dispatch("ZoomConstraintsClient::RefreshZoomConstraints",
-                        TaskCategory::Other,
-                        event.forget());
+    mDocument->Dispatch(TaskCategory::Other, event.forget());
   }
   return NS_OK;
 }
 
 void
 ZoomConstraintsClient::ScreenSizeChanged()
 {
   ZCC_LOG("Got a screen-size change notification in %p\n", this);
diff --git a/layout/base/crashtests/363729-1.html b/layout/base/crashtests/363729-1.html
--- a/layout/base/crashtests/363729-1.html
+++ b/layout/base/crashtests/363729-1.html
@@ -1,3 +1,3 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <b onfocus="event.target.setAttribute('tabindex', Math.floor(Math.random()*5)-9)"display: inline-table;position: fixed;overflow: hidden;float: left;direction: ltr;page-break-before: right;page-break-after: always;page-break-inside: inherit; style="display: inline-table;position: fixed;overflow: hidden;float: left;direction: ltr;page-break-before: right;page-break-after: always;page-break-inside: inherit;"><sup rowspan="12"display: table-caption;position: static;overflow: -moz-hidden-unscrollable;float: auto;direction: ltr;page-break-before: avoid;page-break-after: right;page-break-inside: inherit; style="display: table-caption;position: static;overflow: -moz-hidden-unscrollable;float: auto;direction: ltr;page-break-before: avoid;page-break-after: right;page-break-inside: inherit;"><bdo onfocus="event.target.parentNode.removeChild(event.target)"display: table-footer-group;position: absolute;overflow: hidden;float: left;direction: ltr;page-break-before: right;page-break-after: right;page-break-inside: auto; style="display: table-footer-group;position: absolute;overflow: hidden;float: left;direction: ltr;page-break-before: right;page-break-after: right;page-break-inside: auto;"><dir tabindex="12"display: -moz-grid;position: static;overflow: auto;float: left;direction: ltr;page-break-before: avoid;page-break-after: inherit;page-break-inside: inherit; style="display: -moz-grid;position: static;overflow: auto;float: left;direction: ltr;page-break-before: avoid;page-break-after: inherit;page-break-inside: inherit;"><i rowspan="1"display: -moz-stack;position: fixed;overflow: visible;float: right;direction: rtl;page-break-before: right;page-break-after: always;page-break-inside: avoid; style="display: -moz-stack;position: fixed;overflow: visible;float: right;direction: rtl;page-break-before: right;page-break-after: always;page-break-inside: avoid;"><select colspan="1"display: block;position: absolute;overflow: hidden;float: right;direction: auto;page-break-before: auto;page-break-after: avoid;page-break-inside: auto; style="display: block;position: absolute;overflow: hidden;float: right;direction: auto;page-break-before: auto;page-break-after: avoid;page-break-inside: auto;"></abbr></var></u></base></em></button></optgroup></menu></body>
diff --git a/layout/base/crashtests/363729-2.html b/layout/base/crashtests/363729-2.html
--- a/layout/base/crashtests/363729-2.html
+++ b/layout/base/crashtests/363729-2.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Testcase Bug 363729  Crash [@ nsIFrame::GetPositionIgnoringScrolling] on print preview that uses position: fixed</title>
 </head>
 <body>
 This page should not crash on print preview
 <span style="position: fixed; page-break-after: always;"></span>
 <dir>
 <span style="display: inline-table; position: fixed; page-break-after: always;">
diff --git a/layout/base/crashtests/363729-3.html b/layout/base/crashtests/363729-3.html
--- a/layout/base/crashtests/363729-3.html
+++ b/layout/base/crashtests/363729-3.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Testcase Bug 363729  Crash [@ nsIFrame::GetPositionIgnoringScrolling] on print preview that uses position: fixed (Branch version)</title>
 </head>
 <body>
 This page should not crash on print preview
 <span style="page-break-after: always;"></span>
 
 <dir>
diff --git a/layout/base/crashtests/399994-1.html b/layout/base/crashtests/399994-1.html
--- a/layout/base/crashtests/399994-1.html
+++ b/layout/base/crashtests/399994-1.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 </head>
 <body>
 
 <div style="display: table; position: fixed;">
   <div style="display: table-row; page-break-after: always;"></div>
   <div style="display: table-row;"></div>
 </div>
diff --git a/layout/base/crashtests/468645-1.xhtml b/layout/base/crashtests/468645-1.xhtml
--- a/layout/base/crashtests/468645-1.xhtml
+++ b/layout/base/crashtests/468645-1.xhtml
@@ -1,9 +1,9 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 
 <div style="-moz-binding: url(#xbl); display: table-cell;">
 <span style="display: inline-block;">
 <input style="page-break-after: right;"/>
 </span>
 </div>
 
 
diff --git a/layout/base/crashtests/468645-2.xhtml b/layout/base/crashtests/468645-2.xhtml
--- a/layout/base/crashtests/468645-2.xhtml
+++ b/layout/base/crashtests/468645-2.xhtml
@@ -1,9 +1,9 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 
 <div style="-moz-binding:url(#xbl)"/>
 <input style="page-break-after: left;"/>
 
 <bindings xmlns="http://www.mozilla.org/xbl">
 <binding id="xbl" inheritstyle="false">
      <resources>
       <stylesheet src="data:text/css;charset=utf-8,"/>
diff --git a/layout/base/crashtests/468645-3.xhtml b/layout/base/crashtests/468645-3.xhtml
--- a/layout/base/crashtests/468645-3.xhtml
+++ b/layout/base/crashtests/468645-3.xhtml
@@ -1,5 +1,5 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <popup xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"/>
 
 <style>html::before, window::before { content:""; display: table; position: fixed;}</style>
 </html>
diff --git a/layout/base/crashtests/470851-1.xhtml b/layout/base/crashtests/470851-1.xhtml
--- a/layout/base/crashtests/470851-1.xhtml
+++ b/layout/base/crashtests/470851-1.xhtml
@@ -1,9 +1,9 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <thead>
   <tbody style="top: 10%;position: relative;overflow: scroll;">
     <td>
       <tfoot>
         <tr style="page-break-after: left;"></tr>
         <tbody style="line-height: 999px;">m</tbody>
       </tfoot>
       <thead></thead>
diff --git a/layout/base/crashtests/479114-1.html b/layout/base/crashtests/479114-1.html
--- a/layout/base/crashtests/479114-1.html
+++ b/layout/base/crashtests/479114-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="display: table-row">
       <span style="display: block; page-break-before: always"></span>
     </div>
     <div style="display: table-row-group">
       <span style="display: block; page-break-before: always"></span>
     </div>
     <div style="display: table">
diff --git a/layout/base/crashtests/675246-1.xhtml b/layout/base/crashtests/675246-1.xhtml
--- a/layout/base/crashtests/675246-1.xhtml
+++ b/layout/base/crashtests/675246-1.xhtml
@@ -1,8 +1,8 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <style><![CDATA[
  tfoot::after { content: "m"; position: fixed;}
 ]]>
 </style>
 <td></td>
 <tfoot style="page-break-before: always;"></tfoot>
 </html>
diff --git a/layout/base/crashtests/767593-1.html b/layout/base/crashtests/767593-1.html
--- a/layout/base/crashtests/767593-1.html
+++ b/layout/base/crashtests/767593-1.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div><span style="page-break-after: always;"></span><div style="position: fixed;"><span style="display: none;"></span></div>B</div>
 </body>
 </html>
 
diff --git a/layout/base/crashtests/767593-2.html b/layout/base/crashtests/767593-2.html
--- a/layout/base/crashtests/767593-2.html
+++ b/layout/base/crashtests/767593-2.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div><span style="page-break-after: always;"></span><div style="position: fixed;"><span style="display: none;"></span><span style="display: none;"></span></div>B</div>
 </body>
 </html>
 
diff --git a/layout/base/nsDocumentViewer.cpp b/layout/base/nsDocumentViewer.cpp
--- a/layout/base/nsDocumentViewer.cpp
+++ b/layout/base/nsDocumentViewer.cpp
@@ -2244,19 +2244,17 @@ nsDocumentViewer::Show(void)
       shell->UnsuppressPainting();
     }
   }
 
   // Notify observers that a new page has been shown. This will get run
   // from the event loop after we actually draw the page.
   RefPtr<nsDocumentShownDispatcher> event =
     new nsDocumentShownDispatcher(document);
-  document->Dispatch("nsDocumentShownDispatcher",
-                      TaskCategory::Other,
-                      event.forget());
+  document->Dispatch(TaskCategory::Other, event.forget());
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDocumentViewer::Hide(void)
 {
   if (!mAttachedToParent && mWindow) {
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1117,18 +1117,17 @@ NS_IMETHODIMP
 nsPresContext::Observe(nsISupports* aSubject,
                         const char* aTopic,
                         const char16_t* aData)
 {
   if (!nsCRT::strcmp(aTopic, "charset")) {
     auto encoding = Encoding::ForName(NS_LossyConvertUTF16toASCII(aData));
     RefPtr<CharSetChangingRunnable> runnable =
       new CharSetChangingRunnable(this, encoding);
-    return Document()->Dispatch("CharSetChangingRunnable",
-                                TaskCategory::Other,
+    return Document()->Dispatch(TaskCategory::Other,
                                 runnable.forget());
   }
 
   NS_WARNING("unrecognized topic in nsPresContext::Observe");
   return NS_ERROR_FAILURE;
 }
 
 nsPresContext*
@@ -1808,18 +1807,17 @@ nsPresContext::ThemeChanged()
   if (!mPendingThemeChanged) {
     sLookAndFeelChanged = true;
     sThemeChanged = true;
 
     nsCOMPtr<nsIRunnable> ev =
       NewRunnableMethod("nsPresContext::ThemeChangedInternal",
                         this,
                         &nsPresContext::ThemeChangedInternal);
-    nsresult rv = Document()->Dispatch("nsPresContext::ThemeChangedInternal",
-                                       TaskCategory::Other,
+    nsresult rv = Document()->Dispatch(TaskCategory::Other,
                                        ev.forget());
     if (NS_SUCCEEDED(rv)) {
       mPendingThemeChanged = true;
     }
   }
 }
 
 static bool
@@ -1873,18 +1871,17 @@ void
 nsPresContext::SysColorChanged()
 {
   if (!mPendingSysColorChanged) {
     sLookAndFeelChanged = true;
     nsCOMPtr<nsIRunnable> ev =
       NewRunnableMethod("nsPresContext::SysColorChangedInternal",
                         this,
                         &nsPresContext::SysColorChangedInternal);
-    nsresult rv = Document()->Dispatch("nsPresContext::SysColorChangedInternal",
-                                       TaskCategory::Other,
+    nsresult rv = Document()->Dispatch(TaskCategory::Other,
                                        ev.forget());
     if (NS_SUCCEEDED(rv)) {
       mPendingSysColorChanged = true;
     }
   }
 }
 
 void
@@ -1914,19 +1911,17 @@ void
 nsPresContext::UIResolutionChanged()
 {
   if (!mPendingUIResolutionChanged) {
     nsCOMPtr<nsIRunnable> ev =
       NewRunnableMethod("nsPresContext::UIResolutionChangedInternal",
                         this,
                         &nsPresContext::UIResolutionChangedInternal);
     nsresult rv =
-      Document()->Dispatch("nsPresContext::UIResolutionChangedInternal",
-                           TaskCategory::Other,
-                           ev.forget());
+      Document()->Dispatch(TaskCategory::Other, ev.forget());
     if (NS_SUCCEEDED(rv)) {
       mPendingUIResolutionChanged = true;
     }
   }
 }
 
 void
 nsPresContext::UIResolutionChangedSync()
@@ -2161,19 +2156,17 @@ nsPresContext::PostMediaFeatureValuesCha
   // FIXME: We should probably replace this event with use of
   // nsRefreshDriver::AddStyleFlushObserver (except the pres shell would
   // need to track whether it's been added).
   if (!mPendingMediaFeatureValuesChanged && mShell) {
     nsCOMPtr<nsIRunnable> ev =
       NewRunnableMethod("nsPresContext::HandleMediaFeatureValuesChangedEvent",
                         this, &nsPresContext::HandleMediaFeatureValuesChangedEvent);
     nsresult rv =
-      Document()->Dispatch("nsPresContext::HandleMediaFeatureValuesChangedEvent",
-                           TaskCategory::Other,
-                           ev.forget());
+      Document()->Dispatch(TaskCategory::Other, ev.forget());
     if (NS_SUCCEEDED(rv)) {
       mPendingMediaFeatureValuesChanged = true;
       mShell->SetNeedStyleFlush();
     }
   }
 }
 
 void
@@ -2386,19 +2379,17 @@ nsPresContext::RebuildCounterStyles()
   if (mShell) {
     mShell->SetNeedStyleFlush();
   }
   if (!mPostedFlushCounterStyles) {
     nsCOMPtr<nsIRunnable> ev =
       NewRunnableMethod("nsPresContext::HandleRebuildCounterStyles",
                         this, &nsPresContext::HandleRebuildCounterStyles);
     nsresult rv =
-      Document()->Dispatch("nsPresContext::HandleRebuildCounterStyles",
-                           TaskCategory::Other,
-                           ev.forget());
+      Document()->Dispatch(TaskCategory::Other, ev.forget());
     if (NS_SUCCEEDED(rv)) {
       mPostedFlushCounterStyles = true;
     }
   }
 }
 
 void
 nsPresContext::NotifyMissingFonts()
@@ -3435,18 +3426,17 @@ nsRootPresContext::CancelAllDidPaintTime
   mNotifyDidPaintTimers.Clear();
 }
 
 void
 nsRootPresContext::AddWillPaintObserver(nsIRunnable* aRunnable)
 {
   if (!mWillPaintFallbackEvent.IsPending()) {
     mWillPaintFallbackEvent = new RunWillPaintObservers(this);
-    Document()->Dispatch("RunWillPaintObservers",
-                         TaskCategory::Other,
+    Document()->Dispatch(TaskCategory::Other,
                          do_AddRef(mWillPaintFallbackEvent.get()));
   }
   mWillPaintObservers.AppendElement(aRunnable);
 }
 
 /**
  * Run all runnables that need to get called before the next paint.
  */
diff --git a/layout/base/nsRefreshDriver.cpp b/layout/base/nsRefreshDriver.cpp
--- a/layout/base/nsRefreshDriver.cpp
+++ b/layout/base/nsRefreshDriver.cpp
@@ -2137,18 +2137,17 @@ nsRefreshDriver::Thaw()
       // FIXME: This isn't quite right, since our EnsureTimerStarted call
       // updates our mMostRecentRefresh, but the DoRefresh call won't run
       // and notify our observers until we get back to the event loop.
       // Thus MostRecentRefresh() will lie between now and the DoRefresh.
       RefPtr<nsRunnableMethod<nsRefreshDriver>> event = NewRunnableMethod(
         "nsRefreshDriver::DoRefresh", this, &nsRefreshDriver::DoRefresh);
       nsPresContext* pc = GetPresContext();
       if (pc) {
-        pc->Document()->Dispatch("nsRefreshDriver::DoRefresh",
-                                 TaskCategory::Other,
+        pc->Document()->Dispatch(TaskCategory::Other,
                                  event.forget());
         EnsureTimerStarted();
       } else {
         NS_ERROR("Thawing while document is being destroyed");
       }
     }
   }
 }
diff --git a/layout/base/tests/bug558663.html b/layout/base/tests/bug558663.html
--- a/layout/base/tests/bug558663.html
+++ b/layout/base/tests/bug558663.html
@@ -5,17 +5,17 @@ https://bugzilla.mozilla.org/show_bug.cg
 -->
 <head>
   <title>Test for Bug 558663</title>
 </head>
 <body>
 <p><a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=558663">Mozilla Bug 558663</a></p>
 
  <!-- 20x20 of red -->
-<iframe id="iframe" src="data:text/html,<img id='image' border='0' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAAG0lEQVR42mP8z0A%2BYKJA76jmUc2jmkc1U0EzACKcASfOgGoMAAAAAElFTkSuQmCC'>"></iframe>
+<iframe id="iframe" srcdoc="<img id='image' border='0' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAAG0lEQVR42mP8z0A%2BYKJA76jmUc2jmkc1U0EzACKcASfOgGoMAAAAAElFTkSuQmCC'>"></iframe>
 
 <pre id="test">
 <script type="application/javascript">
 
 /** Test for Bug 558663 **/
 var ok = parent.ok;
 var SimpleTest = parent.SimpleTest;
 var compareSnapshots = parent.compareSnapshots;
diff --git a/layout/base/tests/file_bug465448.html b/layout/base/tests/file_bug465448.html
new file mode 100644
--- /dev/null
+++ b/layout/base/tests/file_bug465448.html
@@ -0,0 +1,1 @@
+<body onload='window.opener.loaded()'><div style='height:200px; width:100px;'>
diff --git a/layout/base/tests/file_bug607529-1.html b/layout/base/tests/file_bug607529-1.html
new file mode 100644
--- /dev/null
+++ b/layout/base/tests/file_bug607529-1.html
@@ -0,0 +1,1 @@
+<script>window.onload = function() { opener.postMessage('goback', '*'); }</script>
diff --git a/layout/base/tests/mochitest.ini b/layout/base/tests/mochitest.ini
--- a/layout/base/tests/mochitest.ini
+++ b/layout/base/tests/mochitest.ini
@@ -1,11 +1,12 @@
 [DEFAULT]
 support-files =
   Ahem.ttf
+  file_bug465448.html
   file_bug842853.html
   file_bug842853.sjs
   selection-utils.js
   ../../../dom/plugins/test/mochitest/plugin-utils.js
 
 [test_after_paint_pref.html]
 [test_border_radius_hit_testing.html]
 support-files = border_radius_hit_testing_iframe.html
@@ -57,17 +58,19 @@ support-files = bug558663.html
 [test_bug583889.html]
 support-files =
   bug583889_inner1.html
   bug583889_inner2.html
 [test_bug588174.html]
 [test_bug603550.html]
 skip-if = toolkit == 'android' # Doesn't work on Android
 [test_bug607529.html]
-support-files = file_bug607529.html
+support-files =
+  file_bug607529.html
+  file_bug607529-1.html
 [test_bug629838.html]
 skip-if = toolkit == 'android' # Requires plugin support
 [test_bug644768.html]
 [test_bug646757.html]
 [test_bug667512.html]
 [test_bug677878.html]
 [test_bug687297.html]
 support-files =
@@ -323,15 +326,15 @@ support-files =
 support-files = resize_flush_iframe.html
 [test_scroll_event_ordering.html]
 [test_scroll_selection_into_view.html]
 skip-if = toolkit == 'android' # Bug 1355844
 support-files = scroll_selection_into_view_window.html
 [test_scroll_snapping.html]
 skip-if = toolkit == 'android' || os == 'win' # Bug 1355851, win Bug 1379810
 [test_scroll_snapping_scrollbars.html]
-skip-if = toolkit == 'android' # Bug 1355851
+skip-if = toolkit == 'android' || (os == 'win' && !e10s) # Bug 1355851, bug 1381932
 [test_transformed_scrolling_repaints.html]
 [test_transformed_scrolling_repaints_2.html]
 [test_transformed_scrolling_repaints_3.html]
 support-files = transformed_scrolling_repaints_3_window.html
 
 # *** Please maintain alphabetical ordering when adding new tests ***
diff --git a/layout/base/tests/test_bug465448.xul b/layout/base/tests/test_bug465448.xul
--- a/layout/base/tests/test_bug465448.xul
+++ b/layout/base/tests/test_bug465448.xul
@@ -8,17 +8,17 @@
   xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
   <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>      
   <script type="application/javascript" src="/tests/SimpleTest/EventUtils.js"></script>      
 
 <script><![CDATA[
 SimpleTest.waitForExplicitFinish();
 var loadedCalled = false;
-var win = window.open("data:text/html,<body onload='window.opener.loaded()'><div style='height:200px; width:100px;'>", "_blank", "width=600,height=600");
+var win = window.open("file_bug465448.html", "_blank", "width=600,height=600");
 
 function loaded() {
   if (!loadedCalled) {
     loadedCalled = true;
     return;
   }
   win.sizeToContent();
   win.sizeToContent();
diff --git a/layout/base/tests/test_bug469170.html b/layout/base/tests/test_bug469170.html
--- a/layout/base/tests/test_bug469170.html
+++ b/layout/base/tests/test_bug469170.html
@@ -6,18 +6,17 @@ https://bugzilla.mozilla.org/show_bug.cg
 <head>
   <title>Test for Bug 469170</title>
   <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
 </head>
 <body onload="runTest();">
 <p><a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=469170">Mozilla Bug 469170</a></p>
 
-<iframe id="source" width="50" height="50"
-       src="data:text/html,%3Chtml%3E%3C%2Fhtml%3E"></iframe>
+<iframe id="source" width="50" height="50" srcdoc="<html></html>"></iframe>
 
 <pre id="test">
 <script type="application/javascript">
 
 /** Test for Bug 469170 **/
 
 SimpleTest.waitForExplicitFinish();
 
diff --git a/layout/base/tests/test_bug518777.html b/layout/base/tests/test_bug518777.html
--- a/layout/base/tests/test_bug518777.html
+++ b/layout/base/tests/test_bug518777.html
@@ -30,19 +30,15 @@ https://bugzilla.mozilla.org/show_bug.cg
 
     SimpleTest.finish();
   }
   </script>
 </head>
 <body>
 <p><a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=518777">Mozilla Bug 518777</a></p>
 
-<!--
-iframe source is
-<html><body onload='window.scrollTo(0,99999999); document.documentElement.offsetWidth; window.parent.dotest();' style='background: rgb(0,0,255); width: 100px; height: 50100px;'></body></html>
--->
 <iframe id="source" width="50" height="50"
-       src="data:text/html,%3Chtml%3E%3Cbody%20onload%3D%27window.scrollTo%280%2C99999999%29%3B%20document.documentElement.offsetWidth%3B%20window.parent.dotest%28%29%3B%27%20style%3D%27background%3A%20rgb%280%2C0%2C255%29%3B%20width%3A%20100px%3B%20height%3A%2050100px%3B%27%3E%3C%2Fbody%3E%3C%2Fhtml%3E"></iframe>
+       srcdoc="<html><body onload='window.scrollTo(0,99999999); document.documentElement.offsetWidth; window.parent.dotest();' style='background: rgb(0,0,255); width: 100px; height: 50100px;'></body></html>"></iframe>
 
 <pre id="test">
 </pre>
 </body>
 </html>
diff --git a/layout/base/tests/test_bug607529.html b/layout/base/tests/test_bug607529.html
--- a/layout/base/tests/test_bug607529.html
+++ b/layout/base/tests/test_bug607529.html
@@ -26,17 +26,17 @@ https://bugzilla.mozilla.org/show_bug.cg
 
   /** Test for Bug 607529 **/
   var done = false;
   window.onmessage = function(e) {
     isnot(e.data, "notcached", "Should never end up not being cached");
   
     if (e.data == "loaded" && !doneOneLoad) {
       doneOneLoad = true;
-      w.location = "data:text/html,<script>window.onload = function() { opener.postMessage('goback', '*'); }</" + "script>";
+      w.location = "file_bug607529-1.html";
     }
     else if (e.data == "goback") {
       w.history.back();
     }
     else if (e.data == "revived") {
       w.postMessage("report", "*");
     }
     else if (e.data == "callbackHappened") {
diff --git a/layout/forms/crashtests/1102791.html b/layout/forms/crashtests/1102791.html
--- a/layout/forms/crashtests/1102791.html
+++ b/layout/forms/crashtests/1102791.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print"><head>
+<html class="reftest-paged"><head>
     <meta charset="utf-8">
     <title>Testcase for bug 1102791</title>
     <style type="text/css">
 
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0;
 }
 
diff --git a/layout/forms/crashtests/1182414.html b/layout/forms/crashtests/1182414.html
--- a/layout/forms/crashtests/1182414.html
+++ b/layout/forms/crashtests/1182414.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <meta charset="UTF-8">
 <style type="text/css">
 #menu { position: fixed; left: 0px; top: 0px; }
 </style>
 </head>
 <body>
 	<svg id="canvas" width="2427" height="2295.5" version="1.1" xmlns="http://www.w3.org/2000/svg"></svg>
diff --git a/layout/forms/crashtests/1279354.html b/layout/forms/crashtests/1279354.html
--- a/layout/forms/crashtests/1279354.html
+++ b/layout/forms/crashtests/1279354.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html class="reftest-print"><head>
+<html class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>Testcase for bug 1279354</title>
 </head>
 <body>
 
 <div style="position:fixed"><progress></progress></div>
 1
 <br style="page-break-after: always">
diff --git a/layout/forms/crashtests/578604-1.html b/layout/forms/crashtests/578604-1.html
--- a/layout/forms/crashtests/578604-1.html
+++ b/layout/forms/crashtests/578604-1.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style>
    h2 { page-break-before: always; }
    #reviewer { position: fixed;}
 </style>
 </head>
 
 <body>
diff --git a/layout/forms/crashtests/590302-1.xhtml b/layout/forms/crashtests/590302-1.xhtml
--- a/layout/forms/crashtests/590302-1.xhtml
+++ b/layout/forms/crashtests/590302-1.xhtml
@@ -1,4 +1,4 @@
-<html class="reftest-print" xmlns="http://www.w3.org/1999/xhtml" style=" float: left; white-space: pre; ">
+<html class="reftest-paged" xmlns="http://www.w3.org/1999/xhtml" style=" float: left; white-space: pre; ">
 <div style="page-break-before: always;"></div>
 <textarea style="position: fixed;"></textarea>
 </html>
diff --git a/layout/forms/crashtests/959311.html b/layout/forms/crashtests/959311.html
--- a/layout/forms/crashtests/959311.html
+++ b/layout/forms/crashtests/959311.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <meta charset="utf-8">
 <style type="text/css">
 @page { size:5in 3in; margin:0in; }
 div { height: 2.5in; }
 select { height: 0.5in; display:block; padding:20px; page-break-inside:initial; }
 </style>
 </head>
diff --git a/layout/forms/crashtests/997709-1.html b/layout/forms/crashtests/997709-1.html
--- a/layout/forms/crashtests/997709-1.html
+++ b/layout/forms/crashtests/997709-1.html
@@ -1,5 +1,5 @@
 <!DOCTYPE HTML>
-<html class="reftest-print"><body><div style="position: fixed;">
+<html class="reftest-paged"><body><div style="position: fixed;">
 <div style="page-break-after: always"></div>
 <select style="display:flex; position: fixed;"><option>A</select>
 </div></body></html>
diff --git a/layout/forms/nsTextControlFrame.cpp b/layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp
+++ b/layout/forms/nsTextControlFrame.cpp
@@ -665,18 +665,17 @@ void nsTextControlFrame::SetFocus(bool a
     if (doc) {
       nsIFocusManager* fm = nsFocusManager::GetFocusManager();
       if (fm) {
         fm->GetLastFocusMethod(doc->GetWindow(), &lastFocusMethod);
       }
     }
     if (!(lastFocusMethod & nsIFocusManager::FLAG_BYMOUSE)) {
       RefPtr<ScrollOnFocusEvent> event = new ScrollOnFocusEvent(this);
-      nsresult rv = mContent->OwnerDoc()->Dispatch("ScrollOnFocusEvent",
-                                                   TaskCategory::Other,
+      nsresult rv = mContent->OwnerDoc()->Dispatch(TaskCategory::Other,
                                                    do_AddRef(event));
       if (NS_SUCCEEDED(rv)) {
         mScrollEvent = Move(event);
       }
     }
   }
 
   // tell the caret to use our selection
diff --git a/layout/generic/crashtests/1137723-1.html b/layout/generic/crashtests/1137723-1.html
--- a/layout/generic/crashtests/1137723-1.html
+++ b/layout/generic/crashtests/1137723-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head> 
 	<meta charset="utf-8">
 <title>Testcase bug 1137723</title>
 
 <style>
  .grid-comment{position:fixed;top:100%;}
  a[href]:after{content:" (" attr(href) ")";}
  </style>
diff --git a/layout/generic/crashtests/1137723-2.html b/layout/generic/crashtests/1137723-2.html
--- a/layout/generic/crashtests/1137723-2.html
+++ b/layout/generic/crashtests/1137723-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head> 
 	<meta charset="utf-8">
 <title>Testcase bug 1137723</title>
 
 <style>
  .grid-comment{position:fixed;top:100%;}
  a[href]:after{content:" (" attr(href) ")";}
  </style>
diff --git a/layout/generic/crashtests/255982-1.html b/layout/generic/crashtests/255982-1.html
--- a/layout/generic/crashtests/255982-1.html
+++ b/layout/generic/crashtests/255982-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 </style>
 <div style="width: 60%; float: left; height: 1.6in; ">a float</div>
 <div style="width: 60%; float: left; height: 1.6in; border:1px solid black; ">overlaps page break</div>
 <br />
 <div style="width: 60%; float: left;">3rd float</div>
diff --git a/layout/generic/crashtests/255982-2.html b/layout/generic/crashtests/255982-2.html
--- a/layout/generic/crashtests/255982-2.html
+++ b/layout/generic/crashtests/255982-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div style="width: 60%; float: left; height: 1.6in; ">a float</div>
 <div style="width: 60%; float: left; height: 1.6in; border:1px solid black; ">overlaps page break</div>
 Some text
 <div style="width: 60%; float: left;">3rd float</div>
 <div style="width: 60%; float: left;">4th float</div>
 </body>
 </html>
diff --git a/layout/generic/crashtests/255982-3.html b/layout/generic/crashtests/255982-3.html
--- a/layout/generic/crashtests/255982-3.html
+++ b/layout/generic/crashtests/255982-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div style="width: 60%; float: left; height: 1.6in; ">a float</div>
 <div style="width: 60%; float: left; height: 1.6in; border:1px solid black;">overlaps page break</div>
 Some text
 <div style="width: 60%; float: left;">3rd float</div>
 <div style="width: 60%; float: left;">4th float</div>
 </body>
 </html>
diff --git a/layout/generic/crashtests/255982-4.html b/layout/generic/crashtests/255982-4.html
--- a/layout/generic/crashtests/255982-4.html
+++ b/layout/generic/crashtests/255982-4.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 </style>
 <div style="width: 60%; float: left; height: 1.6in; ">a float</div>
 <div style="width: 60%; float: left; height: 1.6in; border:1px solid black; ">overlaps page break</div>
 This is enough text to trigger a line break.
 <div style="width: 60%; float: left;">3rd float</div>
diff --git a/layout/generic/crashtests/398322-1.html b/layout/generic/crashtests/398322-1.html
--- a/layout/generic/crashtests/398322-1.html
+++ b/layout/generic/crashtests/398322-1.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Testcase bug - Crash [@ nsFrameList::InsertFrame] on print preview with positioned elements and page-break-before</title>
 </head>
 
 <body>
 <div style="position: relative; page-break-before: always;">
   <div style="display: list-item;"></div>
   <div style="position: absolute;">
diff --git a/layout/generic/crashtests/398322-2.html b/layout/generic/crashtests/398322-2.html
--- a/layout/generic/crashtests/398322-2.html
+++ b/layout/generic/crashtests/398322-2.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style>
 q::after { content:"anonymous text"; text-transform: uppercase;}
 </style>
 </head>
 <body>
 <div style="position: absolute; width: 50px; -moz-column-count: 2;">
   <div style="position: absolute;"> <q> </q> </div>
diff --git a/layout/generic/crashtests/480345-1.html b/layout/generic/crashtests/480345-1.html
--- a/layout/generic/crashtests/480345-1.html
+++ b/layout/generic/crashtests/480345-1.html
@@ -1,5 +1,5 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body style="background:url(solidblue.png); position:absolute; height:40in;">
 </body>
 </html>
diff --git a/layout/generic/crashtests/570160.html b/layout/generic/crashtests/570160.html
--- a/layout/generic/crashtests/570160.html
+++ b/layout/generic/crashtests/570160.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
 <title>Testcase for bug 570160</title>
 <!-- distilled from  href="http://www.musicalcriticism.com/concerts/usherhall-rsno-clein-0510.shtml" -->
 
 <style type="text/css">
 
 .manuscript {
diff --git a/layout/generic/crashtests/574958.xhtml b/layout/generic/crashtests/574958.xhtml
--- a/layout/generic/crashtests/574958.xhtml
+++ b/layout/generic/crashtests/574958.xhtml
@@ -1,9 +1,9 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <style>
 tbody::first-letter {float: right; }
 tbody::before { content:"before textbefore textbefore textbefore textbefore textbefore text"; float:right;}>
 </style>
 <th style="direction: rtl;">
 m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m 
 <span style="position: absolute;">
 <tbody style="float: right; page-break-before: right;">m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m </tbody>
diff --git a/layout/generic/crashtests/585598-1.xhtml b/layout/generic/crashtests/585598-1.xhtml
--- a/layout/generic/crashtests/585598-1.xhtml
+++ b/layout/generic/crashtests/585598-1.xhtml
@@ -1,7 +1,7 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <span style="float: left;page-break-before: right;">
 <select style="float: left;">
 </select>
 </span>
 
 </html>
diff --git a/layout/generic/crashtests/595740-1.html b/layout/generic/crashtests/595740-1.html
--- a/layout/generic/crashtests/595740-1.html
+++ b/layout/generic/crashtests/595740-1.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Testcase bug 595740 (crash on print-preview)</title>
 <style type="text/css">
 body { margin:0; font: 0.2in/0.2in serif; }
 </style>
 <div style="height: 1.75in"></div>
 y<br><span style="float: right; width: 1in; height: 2in"></span>z
diff --git a/layout/generic/crashtests/790260-1.html b/layout/generic/crashtests/790260-1.html
--- a/layout/generic/crashtests/790260-1.html
+++ b/layout/generic/crashtests/790260-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div style="float:left">
   <div>
     <img src="about:blank" height="2000">
   </div>
   <div style="float:left">XYZ</div>
 </div>
 <div style="clear:both"></div>
diff --git a/layout/painting/FrameLayerBuilder.cpp b/layout/painting/FrameLayerBuilder.cpp
--- a/layout/painting/FrameLayerBuilder.cpp
+++ b/layout/painting/FrameLayerBuilder.cpp
@@ -5386,16 +5386,33 @@ static void RestrictScaleToMaxLayerSize(
     aScale.width /= scale;
   }
   if (pixelSize.height > maxLayerSize) {
     float scale = (float)pixelSize.height / maxLayerSize;
     scale = gfxUtils::ClampToScaleFactor(scale);
     aScale.height /= scale;
   }
 }
+
+static nsSize
+ComputeDesiredDisplaySizeForAnimation(nsIFrame* aContainerFrame)
+{
+  // Use the size of the nearest widget as the maximum size.  This
+  // is important since it might be a popup that is bigger than the
+  // pres context's size.
+  nsPresContext* presContext = aContainerFrame->PresContext();
+  nsIWidget* widget = aContainerFrame->GetNearestWidget();
+  if (widget) {
+    return LayoutDevicePixel::ToAppUnits(widget->GetClientSize(),
+                                         presContext->AppUnitsPerDevPixel());
+  } else {
+    return presContext->GetVisibleArea().Size();
+  }
+}
+
 static bool
 ChooseScaleAndSetTransform(FrameLayerBuilder* aLayerBuilder,
                            nsDisplayListBuilder* aDisplayListBuilder,
                            nsIFrame* aContainerFrame,
                            nsDisplayItem* aContainerItem,
                            const nsRect& aVisibleRect,
                            const Matrix4x4* aTransform,
                            const ContainerLayerParameters& aIncomingScale,
@@ -5450,30 +5467,17 @@ ChooseScaleAndSetTransform(FrameLayerBui
       !aContainerFrame->Combines3DTransformWithAncestors() &&
       !aContainerFrame->HasPerspective()) {
     // If the container's transform is animated off main thread, fix a suitable scale size
     // for animation
     if (aContainerItem &&
         aContainerItem->GetType() == nsDisplayItem::TYPE_TRANSFORM &&
         EffectCompositor::HasAnimationsForCompositor(
           aContainerFrame, eCSSProperty_transform)) {
-      // Use the size of the nearest widget as the maximum size.  This
-      // is important since it might be a popup that is bigger than the
-      // pres context's size.
-      nsPresContext* presContext = aContainerFrame->PresContext();
-      nsIWidget* widget = aContainerFrame->GetNearestWidget();
-      nsSize displaySize;
-      if (widget) {
-        LayoutDeviceIntSize widgetSize = widget->GetClientSize();
-        int32_t p2a = presContext->AppUnitsPerDevPixel();
-        displaySize.width = NSIntPixelsToAppUnits(widgetSize.width, p2a);
-        displaySize.height = NSIntPixelsToAppUnits(widgetSize.height, p2a);
-      } else {
-        displaySize = presContext->GetVisibleArea().Size();
-      }
+      nsSize displaySize = ComputeDesiredDisplaySizeForAnimation(aContainerFrame);
       // compute scale using the animation on the container (ignoring
       // its ancestors)
       scale = nsLayoutUtils::ComputeSuitableScaleForAnimation(
                 aContainerFrame, aVisibleRect.Size(),
                 displaySize);
       // multiply by the scale inherited from ancestors--we use a uniform
       // scale factor to prevent blurring when the layer is rotated.
       float incomingScale = std::max(aIncomingScale.mXScale, aIncomingScale.mYScale);
@@ -5500,16 +5504,29 @@ ChooseScaleAndSetTransform(FrameLayerBui
           gfxSize oldScale = RoundToFloatPrecision(ThebesMatrix(oldFrameTransform2d).ScaleFactors(true));
           if (oldScale == scale || oldScale == gfxSize(1.0, 1.0)) {
             clamp = false;
           }
         }
         if (clamp) {
           scale.width = gfxUtils::ClampToScaleFactor(scale.width);
           scale.height = gfxUtils::ClampToScaleFactor(scale.height);
+
+          // Limit animated scale factors to not grow excessively beyond the display size.
+          nsSize maxScale(4, 4);
+          if (!aVisibleRect.IsEmpty()) {
+            nsSize displaySize = ComputeDesiredDisplaySizeForAnimation(aContainerFrame);
+            maxScale = Max(maxScale, displaySize / aVisibleRect.Size());
+          }
+          if (scale.width > maxScale.width) {
+            scale.width = gfxUtils::ClampToScaleFactor(maxScale.width, true);
+          }
+          if (scale.height > maxScale.height) {
+            scale.height = gfxUtils::ClampToScaleFactor(maxScale.height, true);
+          }
         }
       } else {
         // XXX Do we need to move nearly-integer values to integers here?
       }
     }
     // If the scale factors are too small, just use 1.0. The content is being
     // scaled out of sight anyway.
     if (fabs(scale.width) < 1e-8 || fabs(scale.height) < 1e-8) {
diff --git a/layout/printing/crashtests/509839-1.html b/layout/printing/crashtests/509839-1.html
--- a/layout/printing/crashtests/509839-1.html
+++ b/layout/printing/crashtests/509839-1.html
@@ -1,9 +1,9 @@
-<html class="reftest-print"><head>
+<html class="reftest-paged"><head>
 <title>Crash [@ nsViewManager::CreateView][@ nsCSSFrameConstructor::AddFrameConstructionItemsInternal] on closing print preview with -moz-transform, position: fixed table displays</title>
 </head><body>
 <div style="position: fixed;">
 <div style="display: table-header-group; -moz-transform: rotate(1deg);">
 <div style="position: relative;"></div>
 <div style="display: table-row;page-break-before: always;"></div>
 </div>
 </body>
diff --git a/layout/printing/crashtests/509839-2.html b/layout/printing/crashtests/509839-2.html
--- a/layout/printing/crashtests/509839-2.html
+++ b/layout/printing/crashtests/509839-2.html
@@ -1,8 +1,8 @@
-<html style="position: fixed; -moz-transform: scale(0.000001);"  class="reftest-print">
+<html style="position: fixed; -moz-transform: scale(0.000001);"  class="reftest-paged">
 <head>
 </head>
 <body>
 <div style="display: table-row;"></div>
 <div style="display: table-row; page-break-before: right;"></div>
 </body>
 </html>
diff --git a/layout/printing/crashtests/576878.xhtml b/layout/printing/crashtests/576878.xhtml
--- a/layout/printing/crashtests/576878.xhtml
+++ b/layout/printing/crashtests/576878.xhtml
@@ -1,9 +1,9 @@
-<html xmlns="http://www.w3.org/1999/xhtml"  xmlns:mathml="http://www.w3.org/1998/Math/MathML"  class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml"  xmlns:mathml="http://www.w3.org/1998/Math/MathML"  class="reftest-paged">
 
 <mathml:mfenced style="position: fixed;">
 <span style="position: inherit; float: right;"><span style="position:fixed;">b</span></span>
 </mathml:mfenced>
 <div style="page-break-before: always; "/>
 
 m
 </html>
diff --git a/layout/printing/crashtests/793844.html b/layout/printing/crashtests/793844.html
--- a/layout/printing/crashtests/793844.html
+++ b/layout/printing/crashtests/793844.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>crash in nsContentList::nsContentList on print preview</title>
 </head><body>
 
 <iframe  onload="window.location.reload()" src="data:text/html,">
 </iframe>
 
 
diff --git a/layout/printing/nsPagePrintTimer.cpp b/layout/printing/nsPagePrintTimer.cpp
--- a/layout/printing/nsPagePrintTimer.cpp
+++ b/layout/printing/nsPagePrintTimer.cpp
@@ -158,17 +158,17 @@ nsPagePrintTimer::Notify(nsITimer *timer
     bool donePrePrint = true;
     if (mPrintEngine) {
       donePrePrint = mPrintEngine->PrePrintPage();
     }
 
     if (donePrePrint && !mWaitingForRemotePrint) {
       StopWatchDogTimer();
       // Pass nullptr here since name already was set in constructor.
-      mDocument->Dispatch(nullptr, TaskCategory::Other, do_AddRef(this));
+      mDocument->Dispatch(TaskCategory::Other, do_AddRef(this));
     } else {
       // Start the watch dog if we're waiting for preprint to ensure that if any
       // mozPrintCallbacks take to long we error out.
       StartWatchDogTimer();
     }
 
   }
   return NS_OK;
diff --git a/layout/printing/nsPrintEngine.cpp b/layout/printing/nsPrintEngine.cpp
--- a/layout/printing/nsPrintEngine.cpp
+++ b/layout/printing/nsPrintEngine.cpp
@@ -3754,18 +3754,17 @@ nsPrintEngine::FirePrintCompletionEvent(
 {
   MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIRunnable> event = new nsPrintCompletionEvent(mDocViewerPrint);
   nsCOMPtr<nsIContentViewer> cv = do_QueryInterface(mDocViewerPrint);
   NS_ENSURE_TRUE_VOID(cv);
   nsCOMPtr<nsIDocument> doc = cv->GetDocument();
   NS_ENSURE_TRUE_VOID(doc);
 
-  NS_ENSURE_SUCCESS_VOID(doc->Dispatch("nsPrintCompletionEvent",
-                                       TaskCategory::Other, event.forget()));
+  NS_ENSURE_SUCCESS_VOID(doc->Dispatch(TaskCategory::Other, event.forget()));
 }
 
 void
 nsPrintEngine::DisconnectPagePrintTimer()
 {
   if (mPagePrintTimer) {
     mPagePrintTimer->Disconnect();
     NS_RELEASE(mPagePrintTimer);
diff --git a/layout/reftests/abs-pos/table-caption-5.html b/layout/reftests/abs-pos/table-caption-5.html
--- a/layout/reftests/abs-pos/table-caption-5.html
+++ b/layout/reftests/abs-pos/table-caption-5.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <head>
     <style>
       @page { size:5in 3in; margin:0.5in; }
       #rel {
         position: relative;
         margin: 2px;
         padding: 0;
       }
diff --git a/layout/reftests/abs-pos/table-cell-8.html b/layout/reftests/abs-pos/table-cell-8.html
--- a/layout/reftests/abs-pos/table-cell-8.html
+++ b/layout/reftests/abs-pos/table-cell-8.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <head>
     <style>
       @page { size:5in 3in; margin:0.5in; }
       #rel {
         position: relative;
         margin: 2px;
         padding: 0;
       }
diff --git a/layout/reftests/abs-pos/table-print-1-ref.html b/layout/reftests/abs-pos/table-print-1-ref.html
--- a/layout/reftests/abs-pos/table-print-1-ref.html
+++ b/layout/reftests/abs-pos/table-print-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <head>
     <style>
       #rel {
         position: relative;
         margin: 2px;
         padding: 0;
       }
       .abs {
diff --git a/layout/reftests/backgrounds/table-background-print-ref.html b/layout/reftests/backgrounds/table-background-print-ref.html
--- a/layout/reftests/backgrounds/table-background-print-ref.html
+++ b/layout/reftests/backgrounds/table-background-print-ref.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <table style="background-image: url('aqua-yellow-32x32.png')">
   <thead style="background-image: url('blue-16x20-green-16x20.png')">
     <tr>
       <td>
         Foo
       </td>
       <td style="background-image: url('yellow-32x32.png')">
diff --git a/layout/reftests/backgrounds/table-background-print.html b/layout/reftests/backgrounds/table-background-print.html
--- a/layout/reftests/backgrounds/table-background-print.html
+++ b/layout/reftests/backgrounds/table-background-print.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <table background="aqua-yellow-32x32.png">
   <thead background="blue-16x20-green-16x20.png">
     <tr>
       <td>
         Foo
       </td>
       <td background="yellow-32x32.png">
diff --git a/layout/reftests/bidi/1161752-5-embed-ref.html b/layout/reftests/bidi/1161752-5-embed-ref.html
--- a/layout/reftests/bidi/1161752-5-embed-ref.html
+++ b/layout/reftests/bidi/1161752-5-embed-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>Testcase for bug 1161752</title>
 <style>
   body,html { margin:0; padding:0; }
   div
     {
       height: 56px;
       width: 100px;
diff --git a/layout/reftests/bidi/1161752-5-embed.html b/layout/reftests/bidi/1161752-5-embed.html
--- a/layout/reftests/bidi/1161752-5-embed.html
+++ b/layout/reftests/bidi/1161752-5-embed.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <meta charset="utf-8">
   <title></title>
 
   <style type="text/css">
 
   html { direction: rtl; }
 
diff --git a/layout/reftests/bugs/200774-1.html b/layout/reftests/bugs/200774-1.html
--- a/layout/reftests/bugs/200774-1.html
+++ b/layout/reftests/bugs/200774-1.html
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" class="reftest-paged">
 
 <head>
 <title>Fixed DIV, Multipe Page Testcase</title>
 <style type="text/css">
 div.header { position: fixed;
 	width: 100%;
 	height: 1.5em;
 	top: 0;
diff --git a/layout/reftests/bugs/231823-1-ref.html b/layout/reftests/bugs/231823-1-ref.html
--- a/layout/reftests/bugs/231823-1-ref.html
+++ b/layout/reftests/bugs/231823-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div style="height:1087px;">
 <div>Location:  </div>
 
 <p>
 We are located at 333 West San Carlos Street, Suite 1650, San Jose.
 Our building has a parking garage, and we will validate your parking.
 After you park, as you are walking out of the parking garage, you will
diff --git a/layout/reftests/bugs/231823-1.html b/layout/reftests/bugs/231823-1.html
--- a/layout/reftests/bugs/231823-1.html
+++ b/layout/reftests/bugs/231823-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <table cellspacing="0" cellpadding="0">
 	<tr>
 		<td rowspan="2" valign="top">
 <div>Location:  </div>
 
 <p>
 We are located at 333 West San Carlos Street, Suite 1650, San Jose.
diff --git a/layout/reftests/bugs/243519-3-ref.html b/layout/reftests/bugs/243519-3-ref.html
--- a/layout/reftests/bugs/243519-3-ref.html
+++ b/layout/reftests/bugs/243519-3-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style>
 body { margin:0; }
 .pos { position:absolute; width:100px; height:100px; }
 </style>
 </head>
 <body>
 <div class="pos" style="top:0; left:60px; border:10px solid yellow;"></div>
diff --git a/layout/reftests/bugs/243519-3.html b/layout/reftests/bugs/243519-3.html
--- a/layout/reftests/bugs/243519-3.html
+++ b/layout/reftests/bugs/243519-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style>
 html { margin:10px; border:20px solid black; padding:30px; }
 body { margin:0; }
 div { position:absolute; width:100px; height:100px; }
 </style>
 </head>
 <body>
diff --git a/layout/reftests/bugs/243519-6-ref.html b/layout/reftests/bugs/243519-6-ref.html
--- a/layout/reftests/bugs/243519-6-ref.html
+++ b/layout/reftests/bugs/243519-6-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style>
 div { margin:10px; border:20px solid black; padding:30px; height:4in; position:absolute; }
 body { margin:0; }
 </style>
 </head>
 <body>
 <div></div>
diff --git a/layout/reftests/bugs/243519-6.html b/layout/reftests/bugs/243519-6.html
--- a/layout/reftests/bugs/243519-6.html
+++ b/layout/reftests/bugs/243519-6.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style>
 html { margin:10px; border:20px solid black; padding:30px; height:4in; position:absolute; }
 body { margin:0; }
 </style>
 </head>
 <body>
 </body>
diff --git a/layout/reftests/bugs/325292-1-ref.html b/layout/reftests/bugs/325292-1-ref.html
--- a/layout/reftests/bugs/325292-1-ref.html
+++ b/layout/reftests/bugs/325292-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <style>
 #second {border-bottom:green 5px solid}
 col {width:100px}
 </style>
 <body>
 <title>visibility collapse + columns + pagination</title>
 
 <table cellspacing="0" style="page-break-after:always" id="first">
diff --git a/layout/reftests/bugs/325292-1.html b/layout/reftests/bugs/325292-1.html
--- a/layout/reftests/bugs/325292-1.html
+++ b/layout/reftests/bugs/325292-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>visibility collapse + columns + pagination</title>
 <style>
 table {border-bottom:green 5px solid}
 col {width:100px}
 </style>
 <body>
 <table cellspacing="0">
 <col><col style="visibility:collapse"><col>
diff --git a/layout/reftests/bugs/379349-3-ref.xhtml b/layout/reftests/bugs/379349-3-ref.xhtml
--- a/layout/reftests/bugs/379349-3-ref.xhtml
+++ b/layout/reftests/bugs/379349-3-ref.xhtml
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
  <head>
   <title>CSS 2.1 Test Suite: Overflow Pagination (Multiple)</title>
   <link rel="author" title="Elika J. Etemad" href="http://fantasai.inkedblade.net/contact"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/visudet.html#the-height-property"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/syndata.html#length-units"/>
   <style type="text/css">
     .overflow {
       border: solid 2pt silver;
diff --git a/layout/reftests/bugs/379349-3a.xhtml b/layout/reftests/bugs/379349-3a.xhtml
--- a/layout/reftests/bugs/379349-3a.xhtml
+++ b/layout/reftests/bugs/379349-3a.xhtml
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
  <head>
   <title>CSS 2.1 Test Suite: Overflow Pagination (Multiple)</title>
   <link rel="author" title="Elika J. Etemad" href="http://fantasai.inkedblade.net/contact"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/visudet.html#the-height-property"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/syndata.html#length-units"/>
   <style type="text/css">
     .container {
       height: 24pt;
diff --git a/layout/reftests/bugs/379349-3b.xhtml b/layout/reftests/bugs/379349-3b.xhtml
--- a/layout/reftests/bugs/379349-3b.xhtml
+++ b/layout/reftests/bugs/379349-3b.xhtml
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
  <head>
   <title>CSS 2.1 Test Suite: Overflow Pagination (Multiple)</title>
   <link rel="author" title="Elika J. Etemad" href="http://fantasai.inkedblade.net/contact"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/visudet.html#the-height-property"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/syndata.html#length-units"/>
   <style type="text/css">
     .container {
       height: 24pt;
diff --git a/layout/reftests/bugs/397428-1-ref.html b/layout/reftests/bugs/397428-1-ref.html
--- a/layout/reftests/bugs/397428-1-ref.html
+++ b/layout/reftests/bugs/397428-1-ref.html
@@ -1,6 +1,6 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
   <div style="page-break-after:always;"></div>
     <br><br>
     Head
 </body></html>
diff --git a/layout/reftests/bugs/397428-1.html b/layout/reftests/bugs/397428-1.html
--- a/layout/reftests/bugs/397428-1.html
+++ b/layout/reftests/bugs/397428-1.html
@@ -1,8 +1,8 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
   <div style="page-break-after:always;"></div>
   <table cellspacing="0" border="0" cellpadding="0"><tbody><tr><td>
     <table cellspacing="0" border="0" cellpadding="0"><tbody><tr><td><br><br></td></tr></tbody></table>
     Head
   </td></tr></tbody></table>
 </body></html>
diff --git a/layout/reftests/bugs/409084-1-ref.html b/layout/reftests/bugs/409084-1-ref.html
--- a/layout/reftests/bugs/409084-1-ref.html
+++ b/layout/reftests/bugs/409084-1-ref.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><style>
     td { vertical-align: top; }
     .break { page-break-before: always; height: 1in }
 </style></head>
 <body>
   <table cellspacing="0" cellpadding="0">
     <tbody>
       <tr><td rowspan="2">line 1<br/>line 2<br/>line 3</td></tr>
diff --git a/layout/reftests/bugs/409084-1a.html b/layout/reftests/bugs/409084-1a.html
--- a/layout/reftests/bugs/409084-1a.html
+++ b/layout/reftests/bugs/409084-1a.html
@@ -1,13 +1,13 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><style>
     td { vertical-align: top; }
     .tall {
-      height: 4in; /* just longer than a reftest-print page. */
+      height: 4in; /* just longer than a reftest-paged page. */
       width:  1in;
       float:  left;
       border: 0px;
     }
 </style></head>
 <body>
   <table cellspacing="0" cellpadding="0">
     <tbody>
diff --git a/layout/reftests/bugs/409084-1b.html b/layout/reftests/bugs/409084-1b.html
--- a/layout/reftests/bugs/409084-1b.html
+++ b/layout/reftests/bugs/409084-1b.html
@@ -1,13 +1,13 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><style>
     td { vertical-align: top; }
     .tall {
-      height: 4in; /* just longer than a reftest-print page. */
+      height: 4in; /* just longer than a reftest-paged page. */
       width:  1in;
       float:  left;
       border: 0px;
     }
 </style></head>
 <body>
   <table cellspacing="0" cellpadding="0">
     <tbody></tbody>
diff --git a/layout/reftests/bugs/409659-1-ref.html b/layout/reftests/bugs/409659-1-ref.html
--- a/layout/reftests/bugs/409659-1-ref.html
+++ b/layout/reftests/bugs/409659-1-ref.html
@@ -1,6 +1,6 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <img src="solidblue.png" style="height: 4in; width: 100px; display: block">
   </body>
 </html>
diff --git a/layout/reftests/bugs/409659-1a.html b/layout/reftests/bugs/409659-1a.html
--- a/layout/reftests/bugs/409659-1a.html
+++ b/layout/reftests/bugs/409659-1a.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <input type="image" src="solidblue.png"
            style="height: 4in; width: 100px; display: block">
   </body>
 </html>
diff --git a/layout/reftests/bugs/409659-1b.html b/layout/reftests/bugs/409659-1b.html
--- a/layout/reftests/bugs/409659-1b.html
+++ b/layout/reftests/bugs/409659-1b.html
@@ -1,6 +1,6 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <img src="solidblue.png" style="height: 2in; width: 100px; display: block">
   </body>
 </html>
diff --git a/layout/reftests/bugs/409659-1c.html b/layout/reftests/bugs/409659-1c.html
--- a/layout/reftests/bugs/409659-1c.html
+++ b/layout/reftests/bugs/409659-1c.html
@@ -1,6 +1,6 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <img src="solidblue.png" style="height: 30in; width: 100px; display: block">
   </body>
 </html>
diff --git a/layout/reftests/bugs/409659-1d.html b/layout/reftests/bugs/409659-1d.html
--- a/layout/reftests/bugs/409659-1d.html
+++ b/layout/reftests/bugs/409659-1d.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <img src="solidblue.png" style="height: 1in; width: 100px; display: block">
     <img src="solidblue.png" style="height: 1in; width: 100px; display: block">
     <img src="solidblue.png" style="height: 1in; width: 100px; display: block">
     <img src="solidblue.png" style="height: 1in; width: 100px; display: block">
   </body>
 </html>
diff --git a/layout/reftests/bugs/411585-1-ref.html b/layout/reftests/bugs/411585-1-ref.html
--- a/layout/reftests/bugs/411585-1-ref.html
+++ b/layout/reftests/bugs/411585-1-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div style="position:absolute; top:0; left:0;">This text should be visible in print preview</div>
 <div style="height:800px;"></div>
 </body>
 </html>
diff --git a/layout/reftests/bugs/411585-1.html b/layout/reftests/bugs/411585-1.html
--- a/layout/reftests/bugs/411585-1.html
+++ b/layout/reftests/bugs/411585-1.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div style="height:800px;"></div>
 <div style="position:absolute; top:0; left:0;">This text should be visible in print preview</div>
 </body>
 </html>
diff --git a/layout/reftests/bugs/411585-2-ref.html b/layout/reftests/bugs/411585-2-ref.html
--- a/layout/reftests/bugs/411585-2-ref.html
+++ b/layout/reftests/bugs/411585-2-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div style="position:absolute; top:0; left:0; width:100px; height:100px; background:black; opacity:0.5;">Hi</div>
 <div style="height:800px;"></div>
 </body>
 </html>
diff --git a/layout/reftests/bugs/411585-2.html b/layout/reftests/bugs/411585-2.html
--- a/layout/reftests/bugs/411585-2.html
+++ b/layout/reftests/bugs/411585-2.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <div style="height:800px;"></div>
 <div style="opacity:0.5;">
   <div style="position:absolute; top:0; left:0; width:100px; height:100px; background:black;">Hi</div>
 </div>
 </body>
 </html>
diff --git a/layout/reftests/bugs/411585-3-ref.html b/layout/reftests/bugs/411585-3-ref.html
--- a/layout/reftests/bugs/411585-3-ref.html
+++ b/layout/reftests/bugs/411585-3-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body style="margin:0">
 <div style="position:absolute; top:0; left:0; width:100px; height:100px; background:black;">Hi</div>
 <div style="height:800px;"></div>
 </body>
 </html>
diff --git a/layout/reftests/bugs/411585-3.html b/layout/reftests/bugs/411585-3.html
--- a/layout/reftests/bugs/411585-3.html
+++ b/layout/reftests/bugs/411585-3.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body style="margin:0">
 <div style="height:800px;"></div>
 <div style="position:absolute; clip:rect(-800px 200px 100px 0px);">
   <div style="position:absolute; top:-800px; left:0; width:100px; height:100px; background:black;">Hi</div>
 </div>
 </body>
 </html>
diff --git a/layout/reftests/bugs/417676-ref.html b/layout/reftests/bugs/417676-ref.html
--- a/layout/reftests/bugs/417676-ref.html
+++ b/layout/reftests/bugs/417676-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Fixed Positioning Test</title>
 <style type="text/css">
   html, body { margin: 0; padding: 0; }
 </style>
 
 <div style="width: 3in; border: solid; font-size: 16px;">
 This box must be repeated at this same position on the first, second, and third pages.
 </div>
diff --git a/layout/reftests/bugs/417676.html b/layout/reftests/bugs/417676.html
--- a/layout/reftests/bugs/417676.html
+++ b/layout/reftests/bugs/417676.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Fixed Positioning Test</title>
 
 <div style="position: fixed; left: 0; top: 0; width: 3in; border: solid; font-size: 16px;">
 This box must be repeated at this same position on the first, second, and third pages.
 </div>
 
 <p style="width: 0; height: 5in;">
\ No newline at end of file
diff --git a/layout/reftests/bugs/421710-1.html b/layout/reftests/bugs/421710-1.html
--- a/layout/reftests/bugs/421710-1.html
+++ b/layout/reftests/bugs/421710-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style>
 #spContainer {
 clear: both;
 float: left !important;
 margin:0 !important;
 padding: 0 0 0 22px !important;
 min-width: 980px;
diff --git a/layout/reftests/bugs/422249-1-ref.html b/layout/reftests/bugs/422249-1-ref.html
--- a/layout/reftests/bugs/422249-1-ref.html
+++ b/layout/reftests/bugs/422249-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><style>
  .tall { 
    border: 1px solid black;
    line-height: 20px;
  }
 </style></head>
 <body style="margin:0">
   <table class="tall" cellspacing="0" cellpadding="0"><td valign="top">
diff --git a/layout/reftests/bugs/422249-1.html b/layout/reftests/bugs/422249-1.html
--- a/layout/reftests/bugs/422249-1.html
+++ b/layout/reftests/bugs/422249-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><style>
  .tall { 
    border: 1px solid black;
    height: 2002px;
    line-height: 20px;
  }
 </style></head>
 <body style="margin:0">
diff --git a/layout/reftests/bugs/422678-1-ref.html b/layout/reftests/bugs/422678-1-ref.html
--- a/layout/reftests/bugs/422678-1-ref.html
+++ b/layout/reftests/bugs/422678-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <table border="1">
   <tbody>
     <tr>
       <td style="background:yellow;"><div style="height:800px;">Hello</div></td>
     </tr>
   </tbody>
 </table> 
diff --git a/layout/reftests/bugs/422678-1.html b/layout/reftests/bugs/422678-1.html
--- a/layout/reftests/bugs/422678-1.html
+++ b/layout/reftests/bugs/422678-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <table border="1">
   <tbody>
     <tr>
       <td style="background:yellow; height:800px;" valign="top">Hello</td>
     </tr>
   </tbody>
 </table> 
diff --git a/layout/reftests/bugs/427017-1.xhtml b/layout/reftests/bugs/427017-1.xhtml
--- a/layout/reftests/bugs/427017-1.xhtml
+++ b/layout/reftests/bugs/427017-1.xhtml
@@ -1,9 +1,9 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <body>
 <div style="position: absolute; border: 5px solid black;">
   <div style="position: fixed; page-break-before: left;"/>
   <div style="display: table-header-group; page-break-after: right;">
     <div style="position: absolute;">
       <div style="position: fixed;"/>
     </div>
   </div>
diff --git a/layout/reftests/bugs/467444-1-ref.html b/layout/reftests/bugs/467444-1-ref.html
--- a/layout/reftests/bugs/467444-1-ref.html
+++ b/layout/reftests/bugs/467444-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print"><head>
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged"><head>
 <style>
 div.spacer {
   height: 5px;
   width:  10px;
 }
 img, td.spacer {
   height: 140px;
   width:  30px;
diff --git a/layout/reftests/bugs/467444-1.html b/layout/reftests/bugs/467444-1.html
--- a/layout/reftests/bugs/467444-1.html
+++ b/layout/reftests/bugs/467444-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print"><head>
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged"><head>
 <style>
 div.spacer {
   height: 5px;
   width:  10px;
 }
 img, td.spacer {
   height: 140px;
   width:  30px;
diff --git a/layout/reftests/bugs/531200-1-ref.html b/layout/reftests/bugs/531200-1-ref.html
--- a/layout/reftests/bugs/531200-1-ref.html
+++ b/layout/reftests/bugs/531200-1-ref.html
@@ -1,9 +1,9 @@
-<html  class="reftest-print">
+<html  class="reftest-paged">
 <head>
 <title>push rowspan on to next page if it can't be splitted</title>
 <style>
 img {
   width: 10px;
   height: 30px;
 }
 </style>
diff --git a/layout/reftests/bugs/531200-1.html b/layout/reftests/bugs/531200-1.html
--- a/layout/reftests/bugs/531200-1.html
+++ b/layout/reftests/bugs/531200-1.html
@@ -1,9 +1,9 @@
-<html  class="reftest-print">
+<html  class="reftest-paged">
 <head>
 <title>push rowspan on to next page if it can't be splitted</title>
 <style>
 img {
   width: 10px;
   height: 30px;
 }
 </style>
diff --git a/layout/reftests/bugs/563584-1-ref.html b/layout/reftests/bugs/563584-1-ref.html
--- a/layout/reftests/bugs/563584-1-ref.html
+++ b/layout/reftests/bugs/563584-1-ref.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Bug 563584, reftest-print version of original testcase</title>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
diff --git a/layout/reftests/bugs/563584-1.html b/layout/reftests/bugs/563584-1.html
--- a/layout/reftests/bugs/563584-1.html
+++ b/layout/reftests/bugs/563584-1.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Bug 563584, reftest-print version of original testcase</title>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
diff --git a/layout/reftests/bugs/563584-10-ref.html b/layout/reftests/bugs/563584-10-ref.html
--- a/layout/reftests/bugs/563584-10-ref.html
+++ b/layout/reftests/bugs/563584-10-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test that nsFloatManager::ClearFloats calls ClearContinues</title>
 <body style="margin: 0">
 <div style="background: aqua; height: 1in; width: 1in"></div>
 <div style="page-break-before: always; background: fuchsia; height: 1.5in; width: 1in"></div>
 <div style="height: 0.25in; background: yellow; width: 1in"></div>
diff --git a/layout/reftests/bugs/563584-10a.html b/layout/reftests/bugs/563584-10a.html
--- a/layout/reftests/bugs/563584-10a.html
+++ b/layout/reftests/bugs/563584-10a.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test that nsFloatManager::ClearFloats calls ClearContinues</title>
 <body style="margin: 0">
 <div style="float: left;">
   <div>
     <div style="display:inline-block; vertical-align: top; background: aqua; height: 1in; width: 1in"></div>
   </div>
   <div>
     <div style="display:inline-block; vertical-align: top; background: fuchsia; height: 1.5in; width: 1in"></div>
diff --git a/layout/reftests/bugs/563584-10b.html b/layout/reftests/bugs/563584-10b.html
--- a/layout/reftests/bugs/563584-10b.html
+++ b/layout/reftests/bugs/563584-10b.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test that nsFloatManager::ClearFloats calls ClearContinues</title>
 <body style="margin: 0">
 <div style="float: left;">
   <div>
     <div style="display:inline-block; vertical-align: top; background: aqua; height: 1in; width: 1in"></div>
   </div>
   <div>
     <div style="display:inline-block; vertical-align: top; background: fuchsia; height: 1.5in; width: 1in"></div>
diff --git a/layout/reftests/bugs/563584-11-ref.html b/layout/reftests/bugs/563584-11-ref.html
--- a/layout/reftests/bugs/563584-11-ref.html
+++ b/layout/reftests/bugs/563584-11-ref.html
@@ -1,6 +1,6 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test that mIsTopOfPage is not set when clearing</title>
 <body style="margin: 0">
 <div style="background: aqua; height: 1in; width: 1in"></div>
 <div style="background: fuchsia; height: 1.5in; width: 1in; page-break-before: always"></div>
diff --git a/layout/reftests/bugs/563584-11.html b/layout/reftests/bugs/563584-11.html
--- a/layout/reftests/bugs/563584-11.html
+++ b/layout/reftests/bugs/563584-11.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test that mIsTopOfPage is not set when clearing</title>
 <body style="margin: 0">
 <div style="float: left; background: aqua; height: 1in; width: 1in"></div>
 <div style="clear: left">
   <div style="display:inline-block; vertical-align: top; background: fuchsia; height: 1.5in; width: 1in"></div>
 </div>
diff --git a/layout/reftests/bugs/563584-2-ref.html b/layout/reftests/bugs/563584-2-ref.html
--- a/layout/reftests/bugs/563584-2-ref.html
+++ b/layout/reftests/bugs/563584-2-ref.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Bug 563584, reftest-print version of original testcase, with anchor points</title>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
diff --git a/layout/reftests/bugs/563584-2.html b/layout/reftests/bugs/563584-2.html
--- a/layout/reftests/bugs/563584-2.html
+++ b/layout/reftests/bugs/563584-2.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Bug 563584, reftest-print version of original testcase, with anchor points</title>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
diff --git a/layout/reftests/bugs/563584-3-ref.html b/layout/reftests/bugs/563584-3-ref.html
--- a/layout/reftests/bugs/563584-3-ref.html
+++ b/layout/reftests/bugs/563584-3-ref.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Bug 563584, variant split over three pages</title>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
diff --git a/layout/reftests/bugs/563584-3.html b/layout/reftests/bugs/563584-3.html
--- a/layout/reftests/bugs/563584-3.html
+++ b/layout/reftests/bugs/563584-3.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Bug 563584, variant split over three pages</title>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
diff --git a/layout/reftests/bugs/563584-4-ref.html b/layout/reftests/bugs/563584-4-ref.html
--- a/layout/reftests/bugs/563584-4-ref.html
+++ b/layout/reftests/bugs/563584-4-ref.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Bug 563584, variant split over three pages, with anchor points</title>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
diff --git a/layout/reftests/bugs/563584-4.html b/layout/reftests/bugs/563584-4.html
--- a/layout/reftests/bugs/563584-4.html
+++ b/layout/reftests/bugs/563584-4.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <title>Bug 563584, variant split over three pages, with anchor points</title>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
diff --git a/layout/reftests/bugs/563584-5-ref.html b/layout/reftests/bugs/563584-5-ref.html
--- a/layout/reftests/bugs/563584-5-ref.html
+++ b/layout/reftests/bugs/563584-5-ref.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for handling of float that is reflowed and then entirely pushed</title>
 <body style="margin: 0">
 <div style="background: blue; height: 1.75in"></div>
 <div style="page-break-before: always; background: yellow; padding-top: 1in; width: 3in">
   <div>hello</div>
 </div>
diff --git a/layout/reftests/bugs/563584-5.html b/layout/reftests/bugs/563584-5.html
--- a/layout/reftests/bugs/563584-5.html
+++ b/layout/reftests/bugs/563584-5.html
@@ -1,9 +1,9 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for handling of float that is reflowed and then entirely pushed</title>
 <body style="margin: 0">
 <div style="background: blue; height: 1.75in"></div>
 <div style="float: left; background: yellow; width: 3in">
   <span style="display:inline-block; height: 1in; width: 1in; vertical-align: top"></span>
   <div>hello</div>
 </div>
diff --git a/layout/reftests/bugs/563584-6-printing-ref.html b/layout/reftests/bugs/563584-6-printing-ref.html
--- a/layout/reftests/bugs/563584-6-printing-ref.html
+++ b/layout/reftests/bugs/563584-6-printing-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Testcase for float breaking (reference)</title>
 <body style="margin: 0">
 <div style="width: 3.5in; height: 0.5in; background: blue"></div>
 <div>
   <div style="display: inline-block; vertical-align: top; height: 1in; width: 1in; background: aqua"></div
   ><div style="display: inline-block; vertical-align: top; height: 1in; width: 2in; background: fuchsia"></div>
 </div>
 <div>
diff --git a/layout/reftests/bugs/563584-6-printing.html b/layout/reftests/bugs/563584-6-printing.html
--- a/layout/reftests/bugs/563584-6-printing.html
+++ b/layout/reftests/bugs/563584-6-printing.html
@@ -1,9 +1,9 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Testcase for float breaking</title>
 <body style="margin: 0">
 <div style="float: left; width: 3.5in; height: 0.5in; background: blue"></div>
 <div style="float: left; width: 1in; height: 1in; background: aqua"></div>
 <!-- test to see where this float goes -->
 <div style="float: left; width: 2in; height: 1.75in; background: fuchsia"></div>
 
diff --git a/layout/reftests/bugs/563584-7-ref.html b/layout/reftests/bugs/563584-7-ref.html
--- a/layout/reftests/bugs/563584-7-ref.html
+++ b/layout/reftests/bugs/563584-7-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body style="margin: 0">
 <div>
   <div style="display: inline-block; background: yellow; width: 1in; height: 1in; vertical-align: top"></div
   ><div style="display: inline-block; background: aqua; width: 2in; height: 1in; vertical-align: top"></div>
 </div>
 <div>
   <div style="display: inline-block; width: 1in; height: 1in; vertical-align: top"></div
   ><div style="display: inline-block; background: aqua; width: 2in; height: 1in; vertical-align: top"></div>
diff --git a/layout/reftests/bugs/563584-7.html b/layout/reftests/bugs/563584-7.html
--- a/layout/reftests/bugs/563584-7.html
+++ b/layout/reftests/bugs/563584-7.html
@@ -1,5 +1,5 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body style="margin: 0">
 <div style="float: left; background: yellow; width: 1in; height: 1in"></div>
 <div style="float: left; background: aqua; width: 2in; height: 4in"></div>
diff --git a/layout/reftests/bugs/563584-8a-ref.html b/layout/reftests/bugs/563584-8a-ref.html
--- a/layout/reftests/bugs/563584-8a-ref.html
+++ b/layout/reftests/bugs/563584-8a-ref.html
@@ -1,6 +1,6 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for setting and handling of mIsTopOfPage on floats</title>
 <body style="margin: 0">
 <div style="height: 2in; width: 1in; background: aqua"></div>
 <div style="height: 1in; width: 1in; background: yellow; page-break-before: always"></div>
diff --git a/layout/reftests/bugs/563584-8a.html b/layout/reftests/bugs/563584-8a.html
--- a/layout/reftests/bugs/563584-8a.html
+++ b/layout/reftests/bugs/563584-8a.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for setting and handling of mIsTopOfPage on floats</title>
 <body style="margin: 0">
 <div style="float: left">
   <div><div style="display:inline-block; vertical-align: top; height: 3in; width: 1in; background: aqua"></div></div>
   <div><div style="display:inline-block; vertical-align: top; height: 1in; width: 1in; background: yellow"></div></div>
 </div>
diff --git a/layout/reftests/bugs/563584-8b-ref.html b/layout/reftests/bugs/563584-8b-ref.html
--- a/layout/reftests/bugs/563584-8b-ref.html
+++ b/layout/reftests/bugs/563584-8b-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for setting and handling of mIsTopOfPage on floats</title>
 <body style="margin: 0">
 <div>
   <div style="display:inline-block; vertical-align: top; height: 1in; width: 1in; background: fuchsia"></div
   ><div style="display:inline-block; vertical-align: top; height: 2in; width: 1in; background: aqua"></div>
 </div>
 <div style="page-break-before:always">
   <!-- FIXME: uncomment this when bug 511551 is fixed
diff --git a/layout/reftests/bugs/563584-8b.html b/layout/reftests/bugs/563584-8b.html
--- a/layout/reftests/bugs/563584-8b.html
+++ b/layout/reftests/bugs/563584-8b.html
@@ -1,9 +1,9 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for setting and handling of mIsTopOfPage on floats</title>
 <body style="margin: 0">
 <div style="float: left; height: 1in; width: 1in; background: fuchsia"></div>
 <div style="float: left">
   <div><div style="display:inline-block; vertical-align: top; height: 3in; width: 1in; background: aqua"></div></div>
   <div><div style="display:inline-block; vertical-align: top; height: 1in; width: 1in; background: yellow"></div></div>
 </div>
diff --git a/layout/reftests/bugs/563584-8c-ref.html b/layout/reftests/bugs/563584-8c-ref.html
--- a/layout/reftests/bugs/563584-8c-ref.html
+++ b/layout/reftests/bugs/563584-8c-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for setting and handling of mIsTopOfPage on floats</title>
 <body style="margin: 0">
 <div style="height: 2in"></div>
 <div style="height: 2in; width: 1in; background: aqua; page-break-before: always"></div>
 <div style="height: 1in; width: 1in; background: yellow; page-break-before: always"></div>
diff --git a/layout/reftests/bugs/563584-8c.html b/layout/reftests/bugs/563584-8c.html
--- a/layout/reftests/bugs/563584-8c.html
+++ b/layout/reftests/bugs/563584-8c.html
@@ -1,9 +1,9 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for setting and handling of mIsTopOfPage on floats</title>
 <body style="margin: 0">
 <div style="height: 1in"></div>
 <div style="float: left">
   <div><div style="display:inline-block; vertical-align: top; height: 3in; width: 1in; background: aqua"></div></div>
   <div><div style="display:inline-block; vertical-align: top; height: 1in; width: 1in; background: yellow"></div></div>
 </div>
diff --git a/layout/reftests/bugs/563584-8d-ref.html b/layout/reftests/bugs/563584-8d-ref.html
--- a/layout/reftests/bugs/563584-8d-ref.html
+++ b/layout/reftests/bugs/563584-8d-ref.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for setting and handling of mIsTopOfPage on floats</title>
 <body style="margin: 0">
 <div style="height: 1in"></div>
 <div style="height: 1in; width: 1in; background: fuchsia"></div>
 <div style="height: 2in; width: 1in; background: aqua; page-break-before: always"></div>
 <div style="height: 1in; width: 1in; background: yellow; page-break-before: always"></div>
diff --git a/layout/reftests/bugs/563584-8d.html b/layout/reftests/bugs/563584-8d.html
--- a/layout/reftests/bugs/563584-8d.html
+++ b/layout/reftests/bugs/563584-8d.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Test for setting and handling of mIsTopOfPage on floats</title>
 <body style="margin: 0">
 <div style="height: 1in"></div>
 <div style="float: left; height: 1in; width: 1in; background: fuchsia"></div>
 <div style="float: left">
   <div><div style="display:inline-block; vertical-align: top; height: 3in; width: 1in; background: aqua"></div></div>
   <div><div style="display:inline-block; vertical-align: top; height: 1in; width: 1in; background: yellow"></div></div>
 </div>
diff --git a/layout/reftests/bugs/582037-2-ref.html b/layout/reftests/bugs/582037-2-ref.html
--- a/layout/reftests/bugs/582037-2-ref.html
+++ b/layout/reftests/bugs/582037-2-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="margin: 0; padding: 0; border: none">
+<html class="reftest-paged" style="margin: 0; padding: 0; border: none">
   <body style="margin: 0; padding: 0; border: none">
     <div style="width: 2in; height: 2in; background: green;">
     </div>
   </body>
 </html>
diff --git a/layout/reftests/bugs/582037-2a.html b/layout/reftests/bugs/582037-2a.html
--- a/layout/reftests/bugs/582037-2a.html
+++ b/layout/reftests/bugs/582037-2a.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html>
 <!-- This test assumes that the document is 2in tall by 4in wide. -->
 <html style="margin: 0; padding: 0; border: none; overflow: hidden"
-      class="reftest-print">
+      class="reftest-paged">
   <body style="margin: 0; padding: 0; border: none">
     <div style="position: fixed; height: 100%; background: green">
       <img src="solidblue.png" style="height: 100%; visibility: hidden;">
     </div>
   </body>
 </html>
 
diff --git a/layout/reftests/bugs/582037-2b.html b/layout/reftests/bugs/582037-2b.html
--- a/layout/reftests/bugs/582037-2b.html
+++ b/layout/reftests/bugs/582037-2b.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html>
 <!-- This test assumes that the document is 2in tall by 4in wide. -->
 <html style="margin: 0; padding: 0; border: none; height: 100%; overflow: hidden"
-      class="reftest-print">
+      class="reftest-paged">
   <body style="margin: 0; padding: 0; border: none; height: 100%">
     <div style="float: left; height: 100%; background: green">
       <img src="solidblue.png" style="height: 100%; visibility: hidden;">
     </div>
   </body>
 </html>
 
diff --git a/layout/reftests/bugs/585598-2-ref.xhtml b/layout/reftests/bugs/585598-2-ref.xhtml
--- a/layout/reftests/bugs/585598-2-ref.xhtml
+++ b/layout/reftests/bugs/585598-2-ref.xhtml
@@ -1,6 +1,6 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <div style="page-break-before: always;">
 <select style="display:block">
 </select>
 </div>
 </html>
diff --git a/layout/reftests/bugs/585598-2.xhtml b/layout/reftests/bugs/585598-2.xhtml
--- a/layout/reftests/bugs/585598-2.xhtml
+++ b/layout/reftests/bugs/585598-2.xhtml
@@ -1,6 +1,6 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <span style="float: left;page-break-before: always;">
 <select style="float: left;">
 </select>
 </span>
 </html>
diff --git a/layout/reftests/bugs/609272-1-ref.html b/layout/reftests/bugs/609272-1-ref.html
--- a/layout/reftests/bugs/609272-1-ref.html
+++ b/layout/reftests/bugs/609272-1-ref.html
@@ -1,4 +1,4 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   This text should show up
 </html>
diff --git a/layout/reftests/bugs/609272-1.html b/layout/reftests/bugs/609272-1.html
--- a/layout/reftests/bugs/609272-1.html
+++ b/layout/reftests/bugs/609272-1.html
@@ -1,4 +1,4 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="height: 0; overflow: hidden">
+<html class="reftest-paged" style="height: 0; overflow: hidden">
   This text should show up
 </html>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -1042,17 +1042,17 @@ random-if(gtkWidget) == 424074-1-ref2.xu
 == 424465-1.html 424465-1-ref.html
 == 424631-1.html 424631-1-ref.html
 == 424710-1.html 424710-1-ref.html
 fuzzy-if(skiaContent,1,160000) == 424766-1.html 424766-1-ref.html
 == 425972-1.html 425972-1-ref.html
 == 425972-2.html 425972-2-ref.html
 != 425972-1.html 425972-2.html
 == 426629-1.html 426629-1-ref.html
-asserts(3) asserts-if(styloVsGecko,6) != 427017-1.xhtml about:blank # crash test (needs reftest-print). existing assertions are bug 457400.
+asserts(3) asserts-if(styloVsGecko,6) != 427017-1.xhtml about:blank # crash test (needs reftest-paged). existing assertions are bug 457400.
 == 427129-scrollframe.html 427129-ref.html
 == 427129-table.html 427129-ref.html
 == 427129-image.html 427129-ref.html
 == 427129-table-caption.html 427129-table-caption-ref.html
 fuzzy-if(skiaContent,1,60) == 427370-1.html 427370-1-ref.html
 == 427730-1.html 427730-1-ref.html
 == 428278.html 428278-ref.html
 == 428423-1a.html 428423-1-ref.html
diff --git a/layout/reftests/css-animations/print-no-animations-notref.html b/layout/reftests/css-animations/print-no-animations-notref.html
--- a/layout/reftests/css-animations/print-no-animations-notref.html
+++ b/layout/reftests/css-animations/print-no-animations-notref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Static CSS animation</title>
 <style>
 
 p {
   color: blue;
 }
 
 </style>
diff --git a/layout/reftests/css-animations/print-no-animations-ref.html b/layout/reftests/css-animations/print-no-animations-ref.html
--- a/layout/reftests/css-animations/print-no-animations-ref.html
+++ b/layout/reftests/css-animations/print-no-animations-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Static CSS animation</title>
 <style>
 
 p {
   color: olive;
 }
 
 </style>
diff --git a/layout/reftests/css-animations/print-no-animations.html b/layout/reftests/css-animations/print-no-animations.html
--- a/layout/reftests/css-animations/print-no-animations.html
+++ b/layout/reftests/css-animations/print-no-animations.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Static CSS animation</title>
 <style>
 
 @keyframes a {
   from, to { color: blue }
 }
 
 p {
diff --git a/layout/reftests/css-animations/reftest.list b/layout/reftests/css-animations/reftest.list
--- a/layout/reftests/css-animations/reftest.list
+++ b/layout/reftests/css-animations/reftest.list
@@ -1,12 +1,12 @@
 == screen-animations.html screen-animations-ref.html
 != screen-animations.html screen-animations-notref.html
-skip-if(stylo||styloVsGecko) fails-if(!stylo&&!styloVsGecko) == print-no-animations.html print-no-animations-ref.html # reftest harness doesn't actually make pres context non-dynamic for reftest-print tests. Bug 1374154 for stylo
-skip-if(stylo||styloVsGecko) fails-if(!stylo&&!styloVsGecko) != print-no-animations.html print-no-animations-notref.html # reftest harness doesn't actually make pres context non-dynamic for reftest-print tests. Bug 1374154 for stylo
+skip-if(stylo||styloVsGecko) fails-if(!stylo&&!styloVsGecko) == print-no-animations.html print-no-animations-ref.html # reftest harness doesn't actually make pres context non-dynamic for reftest-paged tests. Bug 1374154 for stylo
+skip-if(stylo||styloVsGecko) fails-if(!stylo&&!styloVsGecko) != print-no-animations.html print-no-animations-notref.html # reftest harness doesn't actually make pres context non-dynamic for reftest-paged tests. Bug 1374154 for stylo
 == animate-opacity.html animate-opacity-ref.html
 == animate-preserves3d.html animate-preserves3d-ref.html
 == in-visibility-hidden-animation.html in-visibility-hidden-animation-ref.html
 == in-visibility-hidden-animation-pseudo-element.html in-visibility-hidden-animation-pseudo-element-ref.html
 == partially-out-of-view-animation.html partially-out-of-view-animation-ref.html
 == animate-display-table-opacity.html animate-display-table-opacity-ref.html
 # We need to run 100% opacity test case when OMTA is disabled to check that the animation creates a stacking context even if the animation is not running on the compositor
 test-pref(layers.offmainthreadcomposition.async-animations,false) == stacking-context-opacity-1-animation.html stacking-context-animation-ref.html
diff --git a/layout/reftests/css-grid/grid-fragmentation-010-ref.html b/layout/reftests/css-grid/grid-fragmentation-010-ref.html
--- a/layout/reftests/css-grid/grid-fragmentation-010-ref.html
+++ b/layout/reftests/css-grid/grid-fragmentation-010-ref.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>Reference: Fragmentation in print context of height:auto grid, not top-of-page</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0;
 }
diff --git a/layout/reftests/css-grid/grid-fragmentation-010.html b/layout/reftests/css-grid/grid-fragmentation-010.html
--- a/layout/reftests/css-grid/grid-fragmentation-010.html
+++ b/layout/reftests/css-grid/grid-fragmentation-010.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>CSS Grid Test: Fragmentation in print context of height:auto grid, not top-of-page</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <link rel="help" href="https://drafts.csswg.org/css-grid/#pagination">
   <link rel="match" href="grid-fragmentation-010-ref.html">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/layout/reftests/css-grid/grid-fragmentation-011-ref.html b/layout/reftests/css-grid/grid-fragmentation-011-ref.html
--- a/layout/reftests/css-grid/grid-fragmentation-011-ref.html
+++ b/layout/reftests/css-grid/grid-fragmentation-011-ref.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>Reference: Fragmentation in print context of height:auto grid with first grid row at top-of-page</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0;
 }
diff --git a/layout/reftests/css-grid/grid-fragmentation-011.html b/layout/reftests/css-grid/grid-fragmentation-011.html
--- a/layout/reftests/css-grid/grid-fragmentation-011.html
+++ b/layout/reftests/css-grid/grid-fragmentation-011.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>CSS Grid Test: Fragmentation in print context of height:auto grid with first grid row at top-of-page</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <link rel="help" href="https://drafts.csswg.org/css-grid/#pagination">
   <link rel="match" href="grid-fragmentation-011-ref.html">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/layout/reftests/css-grid/grid-fragmentation-012-ref.html b/layout/reftests/css-grid/grid-fragmentation-012-ref.html
--- a/layout/reftests/css-grid/grid-fragmentation-012-ref.html
+++ b/layout/reftests/css-grid/grid-fragmentation-012-ref.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>Reference: Fragmentation in print context of height:auto grid, not top-of-page, forced breaks</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0;
 }
diff --git a/layout/reftests/css-grid/grid-fragmentation-012.html b/layout/reftests/css-grid/grid-fragmentation-012.html
--- a/layout/reftests/css-grid/grid-fragmentation-012.html
+++ b/layout/reftests/css-grid/grid-fragmentation-012.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>CSS Grid Test: Fragmentation in print context of height:auto grid, not top-of-page, forced breaks</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <link rel="help" href="https://drafts.csswg.org/css-grid/#pagination">
   <link rel="match" href="grid-fragmentation-012-ref.html">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/layout/reftests/css-grid/grid-fragmentation-013-ref.html b/layout/reftests/css-grid/grid-fragmentation-013-ref.html
--- a/layout/reftests/css-grid/grid-fragmentation-013-ref.html
+++ b/layout/reftests/css-grid/grid-fragmentation-013-ref.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>Reference: Fragmentation in print context of height:auto grid, item break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0;
 }
diff --git a/layout/reftests/css-grid/grid-fragmentation-013.html b/layout/reftests/css-grid/grid-fragmentation-013.html
--- a/layout/reftests/css-grid/grid-fragmentation-013.html
+++ b/layout/reftests/css-grid/grid-fragmentation-013.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>CSS Grid Test: Fragmentation in print context of height:auto grid, item break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <link rel="help" href="https://drafts.csswg.org/css-grid/#pagination">
   <link rel="match" href="grid-fragmentation-013-ref.html">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/layout/reftests/css-grid/grid-fragmentation-014-ref.html b/layout/reftests/css-grid/grid-fragmentation-014-ref.html
--- a/layout/reftests/css-grid/grid-fragmentation-014-ref.html
+++ b/layout/reftests/css-grid/grid-fragmentation-014-ref.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>Reference: Fragmentation in print context of height:auto grid, item break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0;
 }
diff --git a/layout/reftests/css-grid/grid-fragmentation-014.html b/layout/reftests/css-grid/grid-fragmentation-014.html
--- a/layout/reftests/css-grid/grid-fragmentation-014.html
+++ b/layout/reftests/css-grid/grid-fragmentation-014.html
@@ -1,14 +1,14 @@
 <!DOCTYPE HTML>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html lang="en-US" class="reftest-print"><head>
+<html lang="en-US" class="reftest-paged"><head>
   <meta charset="utf-8">
   <title>CSS Grid Test: Fragmentation in print context of height:auto grid, item break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1144096">
   <link rel="help" href="https://drafts.csswg.org/css-grid/#pagination">
   <link rel="match" href="grid-fragmentation-014-ref.html">
   <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/layout/reftests/css-import/445415-2-ref.xhtml b/layout/reftests/css-import/445415-2-ref.xhtml
--- a/layout/reftests/css-import/445415-2-ref.xhtml
+++ b/layout/reftests/css-import/445415-2-ref.xhtml
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
 
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 
 <body>
 <div style="color: cyan">cyan</div>
 <div style="color: blue">blue</div>
 <div style="color: yellow">yellow</div>
 </body>
 
 </html>
diff --git a/layout/reftests/css-import/445415-2a.xhtml b/layout/reftests/css-import/445415-2a.xhtml
--- a/layout/reftests/css-import/445415-2a.xhtml
+++ b/layout/reftests/css-import/445415-2a.xhtml
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
 
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 
 <head>
     <link rel="stylesheet" type="text/css" href="other-outermost-sheet.css"
           media="print" />
     <link rel="stylesheet" type="text/css" href="outermost-sheet.css"
           media="screen" />
 </head>
 
diff --git a/layout/reftests/css-import/445415-2b.xhtml b/layout/reftests/css-import/445415-2b.xhtml
--- a/layout/reftests/css-import/445415-2b.xhtml
+++ b/layout/reftests/css-import/445415-2b.xhtml
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
 
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 
 <head>
     <link rel="stylesheet" type="text/css" href="outermost-sheet.css"
           media="screen" />
     <link rel="stylesheet" type="text/css" href="other-outermost-sheet.css"
           media="print" />
 </head>
 
diff --git a/layout/reftests/css-mediaqueries/mq_print-ref.xhtml b/layout/reftests/css-mediaqueries/mq_print-ref.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print-ref.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print-ref.xhtml
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
 
 
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - print mode test - Reference</title>
   <style><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     p.y { color: aqua; }
     p.n { color: yellow; }
   ]]></style>
 </head>
diff --git a/layout/reftests/css-mediaqueries/mq_print_aspectratio.xhtml b/layout/reftests/css-mediaqueries/mq_print_aspectratio.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_aspectratio.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_aspectratio.xhtml
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - aspect-ratio</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
     /* not sure if the 3/5 will work as aspect ratio is width/height */
diff --git a/layout/reftests/css-mediaqueries/mq_print_deviceaspectratio.xhtml b/layout/reftests/css-mediaqueries/mq_print_deviceaspectratio.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_deviceaspectratio.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_deviceaspectratio.xhtml
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - Device-aspect-ratio</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
     /* not sure if the 3/5 will work as aspect ratio is width/height */
diff --git a/layout/reftests/css-mediaqueries/mq_print_deviceheight.xhtml b/layout/reftests/css-mediaqueries/mq_print_deviceheight.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_deviceheight.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_deviceheight.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - device-height</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the height to 3inches/216pt/76mm in the reftest-print class*/
+    /* we set the height to 3inches/216pt/76mm in the reftest-paged class*/
     @media (device-height: 3in) { .c { color: aqua; } }    /* y */
     @media (device-height: 216pt) { .d { color: aqua; } }  /* y */
     @media (device-height: 76.2mm) { .e { color: aqua; } }  /* y */
 
     @media print and (device-height: 3in) { .f {color: aqua; } }  /* y */
     @media print and (device-height: 216pt) { .g {color: aqua; } }/* y */
     @media print and (device-height: 76.2mm) { .h {color: aqua; } }/* y */
 
diff --git a/layout/reftests/css-mediaqueries/mq_print_devicewidth.xhtml b/layout/reftests/css-mediaqueries/mq_print_devicewidth.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_devicewidth.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_devicewidth.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - device-width</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the width to 5 inches/360pt/127mm in the reftest-print class*/
+    /* we set the width to 5 inches/360pt/127mm in the reftest-paged class*/
     @media (device-width: 5in) { .c { color: aqua; } }    /* y */
     @media (device-width: 360pt) { .d { color: aqua; } }  /* y */
     @media (device-width: 127mm) { .e { color: aqua; } }  /* y */
 
     @media print and (device-width: 5in) { .f {color: aqua; } }  /* y */
     @media print and (device-width: 360pt) { .g {color: aqua; } }/* y */
     @media print and (device-width: 127mm) { .h {color: aqua; } }/* y */
 
diff --git a/layout/reftests/css-mediaqueries/mq_print_height.xhtml b/layout/reftests/css-mediaqueries/mq_print_height.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_height.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_height.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - height</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the height to 3 inches/216pt/76mm in the reftest-print class*/
+    /* we set the height to 3 inches/216pt/76mm in the reftest-paged class*/
     @media (height: 3in) { .c { color: aqua; } }    /* y */
     @media (height: 216pt) { .d { color: aqua; } }  /* y */
     @media (height: 76.2mm) { .e { color: aqua; } }  /* y */
 
     @media print and (height: 3in) { .f {color: aqua; } }  /* y */
     @media print and (height: 216pt) { .g {color: aqua; } }/* y */
     @media print and (height: 76.2mm) { .h {color: aqua; } }/* y */
 
diff --git a/layout/reftests/css-mediaqueries/mq_print_maxheight.xhtml b/layout/reftests/css-mediaqueries/mq_print_maxheight.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_maxheight.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_maxheight.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - max-height</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the height to 3 inches/216pt/76mm in the reftest-print class*/
+    /* we set the height to 3 inches/216pt/76mm in the reftest-paged class*/
     @media (max-height: 3in) { .c { color: aqua; } }    /* y */
     @media (max-height: 216pt) { .d { color: aqua; } }  /* y */ 
     @media (max-height: 76.2mm) { .e { color: aqua; } }  /* y */
 
     @media print and (max-height: 3in) { .f {color: aqua; } }  /* y */ 
     @media print and (max-height: 216pt) { .g {color: aqua; } }/* y */
     @media print and (max-height: 76.2mm) { .h {color: aqua; } }/* y */
 
diff --git a/layout/reftests/css-mediaqueries/mq_print_maxheight_updown.xhtml b/layout/reftests/css-mediaqueries/mq_print_maxheight_updown.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_maxheight_updown.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_maxheight_updown.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - max-height</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the height to 3 inches/216pt/76mm in the reftest-print class*/
+    /* we set the height to 3 inches/216pt/76mm in the reftest-paged class*/
     /* test values greater than */
     @media (max-height: 11in) { .c { color: aqua; } }    /* y */
     @media (max-height: 1100pt) { .d { color: aqua; } }  /* y */ 
     @media (max-height: 110mm) { .e { color: aqua; } }  /* y */
 
     @media print and (max-height: 11in) { .f {color: aqua; } }  /* y */ 
     @media print and (max-height: 1100pt) { .g {color: aqua; } }/* y */
     @media print and (max-height: 110mm) { .h {color: aqua; } }/* y */
diff --git a/layout/reftests/css-mediaqueries/mq_print_maxwidth.xhtml b/layout/reftests/css-mediaqueries/mq_print_maxwidth.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_maxwidth.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_maxwidth.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - max-width</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the width to 5 inches/360pt/127mm in the reftest-print class*/
+    /* we set the width to 5 inches/360pt/127mm in the reftest-paged class*/
     @media (max-width: 5in) { .c { color: aqua; } }    /* y */
     @media (max-width: 360pt) { .d { color: aqua; } }  /* y */ 
     @media (max-width: 127mm) { .e { color: aqua; } }  /* y */
 
     @media print and (max-width: 5in) { .f {color: aqua; } }  /* y */ 
     @media print and (max-width: 360pt) { .g {color: aqua; } }/* y */
     @media print and (max-width: 127mm) { .h {color: aqua; } }/* y */
 
diff --git a/layout/reftests/css-mediaqueries/mq_print_maxwidth_updown.xhtml b/layout/reftests/css-mediaqueries/mq_print_maxwidth_updown.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_maxwidth_updown.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_maxwidth_updown.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - max-width</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the width to 5 inches/360pt/127mm in the reftest-print class*/
+    /* we set the width to 5 inches/360pt/127mm in the reftest-paged class*/
     /* test values great than */
     @media (max-width: 31in) { .c { color: aqua; } }    /* y */
     @media (max-width: 3141pt) { .d { color: aqua; } }  /* y */ 
     @media (max-width: 314mm) { .e { color: aqua; } }  /* y */
 
     @media print and (max-width: 31in) { .f {color: aqua; } }  /* y */ 
     @media print and (max-width: 3141pt) { .g {color: aqua; } }/* y */
     @media print and (max-width: 314mm) { .h {color: aqua; } }/* y */
diff --git a/layout/reftests/css-mediaqueries/mq_print_minheight.xhtml b/layout/reftests/css-mediaqueries/mq_print_minheight.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_minheight.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_minheight.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - min-height</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the height to 3 inches/216pt/76.2mm in the reftest-print class*/
+    /* we set the height to 3 inches/216pt/76.2mm in the reftest-paged class*/
     @media (min-height: 3in) { .c { color: aqua; } }    /* y */
     @media (min-height: 216pt) { .d { color: aqua; } }  /* y */ 
     @media (min-height: 76.2mm) { .e { color: aqua; } }  /* y */
 
     @media print and (min-height: 3in) { .f {color: aqua; } }  /* y */ 
     @media print and (min-height: 216pt) { .g {color: aqua; } }/* y */
     @media print and (min-height: 76.2mm) { .h {color: aqua; } }/* y */
 
diff --git a/layout/reftests/css-mediaqueries/mq_print_minheight_updown.xhtml b/layout/reftests/css-mediaqueries/mq_print_minheight_updown.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_minheight_updown.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_minheight_updown.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - min-height</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the height to 3 inches/216pt/76.2mm in the reftest-print class*/
+    /* we set the height to 3 inches/216pt/76.2mm in the reftest-paged class*/
     /* test less than set value */
     @media (min-height: 1.57in) { .c { color: aqua; } }    /* y */
     @media (min-height: 157pt) { .d { color: aqua; } }  /* y */ 
     @media (min-height: 31.4mm) { .e { color: aqua; } }  /* y */
 
     @media print and (min-height: 1.57in) { .f {color: aqua; } }  /* y */ 
     @media print and (min-height: 157pt) { .g {color: aqua; } }/* y */
     @media print and (min-height: 31.4mm) { .h {color: aqua; } }/* y */
diff --git a/layout/reftests/css-mediaqueries/mq_print_minwidth.xhtml b/layout/reftests/css-mediaqueries/mq_print_minwidth.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_minwidth.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_minwidth.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - min-width</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the width to 5 inches/360pt/127mm in the reftest-print class*/
+    /* we set the width to 5 inches/360pt/127mm in the reftest-paged class*/
     @media (min-width: 5in) { .c { color: aqua; } }    /* y */
     @media (min-width: 360pt) { .d { color: aqua; } }  /* y */ 
     @media (min-width: 127mm) { .e { color: aqua; } }  /* y */
 
     @media print and (min-width: 5in) { .f {color: aqua; } }  /* y */ 
     @media print and (min-width: 360pt) { .g {color: aqua; } }/* y */
     @media print and (min-width: 127mm) { .h {color: aqua; } }/* y */
 
diff --git a/layout/reftests/css-mediaqueries/mq_print_minwidth_updown.xhtml b/layout/reftests/css-mediaqueries/mq_print_minwidth_updown.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_minwidth_updown.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_minwidth_updown.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - min-width</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the width to 5 inches/360pt/127mm in the reftest-print class*/
+    /* we set the width to 5 inches/360pt/127mm in the reftest-paged class*/
     /* test values less than set */
     @media (min-width: 3.14in) { .c { color: aqua; } }    /* y */
     @media (min-width: 314pt) { .d { color: aqua; } }  /* y */ 
     @media (min-width: 31.4mm) { .e { color: aqua; } }  /* y */
 
     @media print and (min-width: 3.14in) { .f {color: aqua; } }  /* y */ 
     @media print and (min-width: 314pt) { .g {color: aqua; } }/* y */
     @media print and (min-width: 31.4mm) { .h {color: aqua; } }/* y */
diff --git a/layout/reftests/css-mediaqueries/mq_print_orientation-ref.xhtml b/layout/reftests/css-mediaqueries/mq_print_orientation-ref.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_orientation-ref.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_orientation-ref.xhtml
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
 
 
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - print mode test - orientation</title>
   <style><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     p.y { color: aqua; }
     p.n { color: yellow; }
   ]]></style>
 </head>
diff --git a/layout/reftests/css-mediaqueries/mq_print_orientation.xhtml b/layout/reftests/css-mediaqueries/mq_print_orientation.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_orientation.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_orientation.xhtml
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - orientation</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
     /* Print reftests are 5/3, which is landscape. */
diff --git a/layout/reftests/css-mediaqueries/mq_print_width.xhtml b/layout/reftests/css-mediaqueries/mq_print_width.xhtml
--- a/layout/reftests/css-mediaqueries/mq_print_width.xhtml
+++ b/layout/reftests/css-mediaqueries/mq_print_width.xhtml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="iso-8859-1" ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <head>
   <title>Media Query - Print mode test - Width</title>
   <style type="text/css"><![CDATA[
     p {height: 10px; width: 100px; color: yellow; }
     @media print { .a { color: aqua; } }
     @media screen { .b { color: aqua; } }
 
-    /* we set the width to 5 inches/360pt/127mm in the reftest-print class*/
+    /* we set the width to 5 inches/360pt/127mm in the reftest-paged class*/
     @media (width: 5in) { .c { color: aqua; } }    /* y */
     @media (width: 360pt) { .d { color: aqua; } }  /* y */
     @media (width: 127mm) { .e { color: aqua; } }  /* y */
 
     @media print and (width: 5in) { .f {color: aqua; } }  /* y */
     @media print and (width: 360pt) { .g {color: aqua; } }/* y */
     @media print and (width: 127mm) { .h {color: aqua; } }/* y */
 
diff --git a/layout/reftests/details-summary/details-page-break-after-1.html b/layout/reftests/details-summary/details-page-break-after-1.html
--- a/layout/reftests/details-summary/details-page-break-after-1.html
+++ b/layout/reftests/details-summary/details-page-break-after-1.html
@@ -1,13 +1,13 @@
 <!DOCTYPE html>
 <!-- Any copyright is dedicated to the Public Domain.
    - http://creativecommons.org/publicdomain/zero/1.0/ -->
 
-<html class="reftest-print">
+<html class="reftest-paged">
   <style>
   summary::-moz-list-bullet {
     /* Hide the triangle for comparing with div in reftest. */
     list-style-type: none;
   }
   </style>
   <body>
     <details open>
diff --git a/layout/reftests/details-summary/details-page-break-after-2.html b/layout/reftests/details-summary/details-page-break-after-2.html
--- a/layout/reftests/details-summary/details-page-break-after-2.html
+++ b/layout/reftests/details-summary/details-page-break-after-2.html
@@ -1,13 +1,13 @@
 <!DOCTYPE html>
 <!-- Any copyright is dedicated to the Public Domain.
    - http://creativecommons.org/publicdomain/zero/1.0/ -->
 
-<html class="reftest-print">
+<html class="reftest-paged">
   <style>
   summary::-moz-list-bullet {
     /* Hide the triangle for comparing with div in reftest. */
     list-style-type: none;
   }
   </style>
   <body>
     <details open>
diff --git a/layout/reftests/details-summary/details-page-break-before-1.html b/layout/reftests/details-summary/details-page-break-before-1.html
--- a/layout/reftests/details-summary/details-page-break-before-1.html
+++ b/layout/reftests/details-summary/details-page-break-before-1.html
@@ -1,13 +1,13 @@
 <!DOCTYPE html>
 <!-- Any copyright is dedicated to the Public Domain.
    - http://creativecommons.org/publicdomain/zero/1.0/ -->
 
-<html class="reftest-print">
+<html class="reftest-paged">
   <style>
   summary::-moz-list-bullet {
     /* Hide the triangle for comparing with div in reftest. */
     list-style-type: none;
   }
   </style>
   <body>
     <details open>
diff --git a/layout/reftests/details-summary/details-page-break-before-2.html b/layout/reftests/details-summary/details-page-break-before-2.html
--- a/layout/reftests/details-summary/details-page-break-before-2.html
+++ b/layout/reftests/details-summary/details-page-break-before-2.html
@@ -1,13 +1,13 @@
 <!DOCTYPE html>
 <!-- Any copyright is dedicated to the Public Domain.
    - http://creativecommons.org/publicdomain/zero/1.0/ -->
 
-<html class="reftest-print">
+<html class="reftest-paged">
   <style>
   summary::-moz-list-bullet {
     /* Hide the triangle for comparing with div in reftest. */
     list-style-type: none;
   }
   </style>
   <body>
     <details open>
diff --git a/layout/reftests/details-summary/details-two-pages.html b/layout/reftests/details-summary/details-two-pages.html
--- a/layout/reftests/details-summary/details-two-pages.html
+++ b/layout/reftests/details-summary/details-two-pages.html
@@ -1,12 +1,12 @@
 <!DOCTYPE html>
 <!-- Any copyright is dedicated to the Public Domain.
    - http://creativecommons.org/publicdomain/zero/1.0/ -->
 
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div>
       <div style="page-break-after: always;">Summary</div>
       <p>This is the details.</p>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/image/image-object-fit-with-background-2-ref.html b/layout/reftests/image/image-object-fit-with-background-2-ref.html
--- a/layout/reftests/image/image-object-fit-with-background-2-ref.html
+++ b/layout/reftests/image/image-object-fit-with-background-2-ref.html
@@ -1,14 +1,14 @@
 <!DOCTYPE html>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html class="reftest-print">
+<html class="reftest-paged">
   <head>
     <meta charset="utf-8">
     <style type="text/css">
       .fakeBackground {
         background: salmon;
         height: 3in;
         width: 32px;
       }
diff --git a/layout/reftests/image/image-object-fit-with-background-2.html b/layout/reftests/image/image-object-fit-with-background-2.html
--- a/layout/reftests/image/image-object-fit-with-background-2.html
+++ b/layout/reftests/image/image-object-fit-with-background-2.html
@@ -7,27 +7,27 @@
      This testcase ensures that we paint the background around an opaque image,
      when the image is kept from filling the container via 'object-fit' (and
      the img element is fragmented). This is an interesting case because, by
      default, images fill their container, which means we can often optimize
      away the background completely. BUT, if "object-fit" prevents the image
      from filling its container, we can't optimize away the background; it need
      to be painted in the uncovered area.
 -->
-<html class="reftest-print">
+<html class="reftest-paged">
   <head>
     <meta charset="utf-8">
     <style type="text/css">
       img.test {
         background: salmon;
         object-fit: none;
         width: 32px;
         /* We make the height 6in larger than the image's intrinsic height,
          * which gives us the following happy results:
-         *  (1) the <img> will split over several 3in tall reftest-print cards
+         *  (1) the <img> will split over several 3in tall reftest-paged cards
          *      (so, we get to test fragmentation).
          *  (2) the image pixels end up on the second fragment (not the first),
          *      so we get to test image-data painting on later fragments.
          *  (3) the reference case can easily match us using a simple img
          *      with 3in-tall divs before & after it.
          */
         height: calc(32px + 6in);
         display: block; /* Required for fragmentation */
diff --git a/layout/reftests/image/image-object-position-with-background-2-ref.html b/layout/reftests/image/image-object-position-with-background-2-ref.html
--- a/layout/reftests/image/image-object-position-with-background-2-ref.html
+++ b/layout/reftests/image/image-object-position-with-background-2-ref.html
@@ -1,14 +1,14 @@
 <!DOCTYPE html>
 <!--
      Any copyright is dedicated to the Public Domain.
      http://creativecommons.org/publicdomain/zero/1.0/
 -->
-<html class="reftest-print">
+<html class="reftest-paged">
   <head>
     <meta charset="utf-8">
     <style type="text/css">
       img.test {
         background: salmon;
         padding-left: 10px;
         padding-top: 20px;
         width: 22px;
diff --git a/layout/reftests/image/image-object-position-with-background-2.html b/layout/reftests/image/image-object-position-with-background-2.html
--- a/layout/reftests/image/image-object-position-with-background-2.html
+++ b/layout/reftests/image/image-object-position-with-background-2.html
@@ -7,17 +7,17 @@
      This testcase ensures that we paint the background around an opaque image,
      when the image is offset from the container via 'object-position' (and
      the img element is fragmented). This is an interesting case because, by
      default, images fill their container, which means we can often optimize
      away the background completely. BUT, if "object-position" offsets the
      image from its container's content-box, we can't optimize away the
      background; it need to be painted in the uncovered area.
 -->
-<html class="reftest-print">
+<html class="reftest-paged">
   <head>
     <meta charset="utf-8">
     <style type="text/css">
       img.test {
         background: salmon;
         object-position: 10px 20px;
         width: 32px;
         height: 5in;
diff --git a/layout/reftests/pagination/abspos-breaking-000.ref.xhtml b/layout/reftests/pagination/abspos-breaking-000.ref.xhtml
--- a/layout/reftests/pagination/abspos-breaking-000.ref.xhtml
+++ b/layout/reftests/pagination/abspos-breaking-000.ref.xhtml
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
  <head>
   <title>AbsPos Pagination</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       padding-top: 1in;
       line-height: 1;
       font-size: 0.25in;
diff --git a/layout/reftests/pagination/abspos-breaking-000.xhtml b/layout/reftests/pagination/abspos-breaking-000.xhtml
--- a/layout/reftests/pagination/abspos-breaking-000.xhtml
+++ b/layout/reftests/pagination/abspos-breaking-000.xhtml
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
  <head>
   <title>AbsPos Pagination</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       position: absolute;
       top: 1in;
       line-height: 1;
diff --git a/layout/reftests/pagination/abspos-breaking-001.xhtml b/layout/reftests/pagination/abspos-breaking-001.xhtml
--- a/layout/reftests/pagination/abspos-breaking-001.xhtml
+++ b/layout/reftests/pagination/abspos-breaking-001.xhtml
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
  <head>
   <title>AbsPos Pagination</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       position: absolute;
       margin-top: 0.5in;
       padding-top: 0.5in;
diff --git a/layout/reftests/pagination/abspos-breaking-002.xhtml b/layout/reftests/pagination/abspos-breaking-002.xhtml
--- a/layout/reftests/pagination/abspos-breaking-002.xhtml
+++ b/layout/reftests/pagination/abspos-breaking-002.xhtml
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
  <head>
   <title>AbsPos Pagination</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       position: absolute;
       margin-top: 0.3in;
       padding-top: 0.3in;
diff --git a/layout/reftests/pagination/abspos-breaking-003-ref.html b/layout/reftests/pagination/abspos-breaking-003-ref.html
--- a/layout/reftests/pagination/abspos-breaking-003-ref.html
+++ b/layout/reftests/pagination/abspos-breaking-003-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect()</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     div {
       position: absolute;
       top: 50%;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-003.html b/layout/reftests/pagination/abspos-breaking-003.html
--- a/layout/reftests/pagination/abspos-breaking-003.html
+++ b/layout/reftests/pagination/abspos-breaking-003.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect()</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       position: absolute;
       top: 50%;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-004-ref.html b/layout/reftests/pagination/abspos-breaking-004-ref.html
--- a/layout/reftests/pagination/abspos-breaking-004-ref.html
+++ b/layout/reftests/pagination/abspos-breaking-004-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect()</title>
   <style type="text/css">
     html, body { margin: 0; padding: 0; }
     div {
       position: absolute;
       top: 120px;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-004.html b/layout/reftests/pagination/abspos-breaking-004.html
--- a/layout/reftests/pagination/abspos-breaking-004.html
+++ b/layout/reftests/pagination/abspos-breaking-004.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect()</title>
   <style type="text/css">
     html, body { margin: 0; padding: 0; }
     div {
       position: absolute;
       top: 120px;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-005-ref.html b/layout/reftests/pagination/abspos-breaking-005-ref.html
--- a/layout/reftests/pagination/abspos-breaking-005-ref.html
+++ b/layout/reftests/pagination/abspos-breaking-005-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect()</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     div {
       position: absolute;
       top: 100px;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-005.html b/layout/reftests/pagination/abspos-breaking-005.html
--- a/layout/reftests/pagination/abspos-breaking-005.html
+++ b/layout/reftests/pagination/abspos-breaking-005.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect()</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       position: absolute;
       top: 100px;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-006-ref.html b/layout/reftests/pagination/abspos-breaking-006-ref.html
--- a/layout/reftests/pagination/abspos-breaking-006-ref.html
+++ b/layout/reftests/pagination/abspos-breaking-006-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect()</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     div {
       position: absolute;
       top: 50%;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-006.html b/layout/reftests/pagination/abspos-breaking-006.html
--- a/layout/reftests/pagination/abspos-breaking-006.html
+++ b/layout/reftests/pagination/abspos-breaking-006.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect()</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       position: absolute;
       top: 50%;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-007-ref.html b/layout/reftests/pagination/abspos-breaking-007-ref.html
--- a/layout/reftests/pagination/abspos-breaking-007-ref.html
+++ b/layout/reftests/pagination/abspos-breaking-007-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect() and box-decoration-break:clone</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     #test {
       box-decoration-break:clone;
     }
     div {
diff --git a/layout/reftests/pagination/abspos-breaking-007.html b/layout/reftests/pagination/abspos-breaking-007.html
--- a/layout/reftests/pagination/abspos-breaking-007.html
+++ b/layout/reftests/pagination/abspos-breaking-007.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect() and box-decoration-break:clone</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       box-decoration-break: clone;
       position: absolute;
       top: 120px;
diff --git a/layout/reftests/pagination/abspos-breaking-008-ref.html b/layout/reftests/pagination/abspos-breaking-008-ref.html
--- a/layout/reftests/pagination/abspos-breaking-008-ref.html
+++ b/layout/reftests/pagination/abspos-breaking-008-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect() and box-decoration-break:clone</title>
   <style type="text/css">
     html, body { margin: 0; padding: 0; }
     div {
       position: absolute;
       top: 120px;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-008.html b/layout/reftests/pagination/abspos-breaking-008.html
--- a/layout/reftests/pagination/abspos-breaking-008.html
+++ b/layout/reftests/pagination/abspos-breaking-008.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect() and box-decoration-break:clone</title>
   <style type="text/css">
     html, body { margin: 0; padding: 0; }
     div {
       box-decoration-break: clone;
       position: absolute;
       top: 120px;
diff --git a/layout/reftests/pagination/abspos-breaking-009-ref.html b/layout/reftests/pagination/abspos-breaking-009-ref.html
--- a/layout/reftests/pagination/abspos-breaking-009-ref.html
+++ b/layout/reftests/pagination/abspos-breaking-009-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect() and box-decoration-break:clone</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     div {
       position: absolute;
       top: 100px;
       border: 10px solid blue;
diff --git a/layout/reftests/pagination/abspos-breaking-009.html b/layout/reftests/pagination/abspos-breaking-009.html
--- a/layout/reftests/pagination/abspos-breaking-009.html
+++ b/layout/reftests/pagination/abspos-breaking-009.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect() and box-decoration-break:clone</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       box-decoration-break: clone;
       position: absolute;
       top: 100px;
diff --git a/layout/reftests/pagination/abspos-breaking-010-ref.html b/layout/reftests/pagination/abspos-breaking-010-ref.html
--- a/layout/reftests/pagination/abspos-breaking-010-ref.html
+++ b/layout/reftests/pagination/abspos-breaking-010-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect() and box-decoration-break:clone</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     .b {
       page-break-before: always;
     }
     div {
diff --git a/layout/reftests/pagination/abspos-breaking-010.html b/layout/reftests/pagination/abspos-breaking-010.html
--- a/layout/reftests/pagination/abspos-breaking-010.html
+++ b/layout/reftests/pagination/abspos-breaking-010.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
  <head>
   <title>AbsPos Pagination, with clip:rect() and box-decoration-break:clone</title>
   <style type="text/css">
     html, body, pre { margin: 0; padding: 0; }
     pre {
       box-decoration-break: clone;
       position: absolute;
       top: 50%;
diff --git a/layout/reftests/pagination/abspos-breaking-011-ref.html b/layout/reftests/pagination/abspos-breaking-011-ref.html
--- a/layout/reftests/pagination/abspos-breaking-011-ref.html
+++ b/layout/reftests/pagination/abspos-breaking-011-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body style="margin:0">
 <div style="position:absolute; top:0; left:0; width:100px; height:100px; background:black;">Hi</div>
 <div style="height:1in;"></div>
 </body>
 </html>
diff --git a/layout/reftests/pagination/abspos-breaking-011.html b/layout/reftests/pagination/abspos-breaking-011.html
--- a/layout/reftests/pagination/abspos-breaking-011.html
+++ b/layout/reftests/pagination/abspos-breaking-011.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body style="margin:0">
 <div style="height:1in;"></div>
 <div style="position:absolute; clip:rect(-1in 200px 100px 0px);">
   <div style="position:absolute; top:-1in; left:0; width:100px; height:100px; background:black;">Hi</div>
 </div>
 </body>
 </html>
diff --git a/layout/reftests/pagination/abspos-overflow-01.ref.xhtml b/layout/reftests/pagination/abspos-overflow-01.ref.xhtml
--- a/layout/reftests/pagination/abspos-overflow-01.ref.xhtml
+++ b/layout/reftests/pagination/abspos-overflow-01.ref.xhtml
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
  <head>
   <title>Multi-column Layout: AbsPos Pagination (Interlaced)</title>
   <link rel="author" title="Elika J. Etemad" href="http://fantasai.inkedblade.net/contact"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/visudet.html#the-height-property"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/syndata.html#length-units"/>
   <style type="text/css">
     /* If the reftest print size change, this needs to change too. */
     html, body, p {
diff --git a/layout/reftests/pagination/abspos-overflow-01.xhtml b/layout/reftests/pagination/abspos-overflow-01.xhtml
--- a/layout/reftests/pagination/abspos-overflow-01.xhtml
+++ b/layout/reftests/pagination/abspos-overflow-01.xhtml
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
  <head>
   <title>Multi-column Layout: AbsPos Pagination (Interlaced)</title>
   <link rel="author" title="Elika J. Etemad" href="http://fantasai.inkedblade.net/contact"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/visudet.html#the-height-property"/>
   <link rel="help" href="http://www.w3.org/TR/CSS21/syndata.html#length-units"/>
   <style type="text/css">
     /* If the reftest print size change, this needs to change too. */
     html, body {
diff --git a/layout/reftests/pagination/blank.html b/layout/reftests/pagination/blank.html
--- a/layout/reftests/pagination/blank.html
+++ b/layout/reftests/pagination/blank.html
@@ -1,1 +1,1 @@
-<!DOCTYPE html><html class="reftest-print"><style>html{font-size:12pt}</style>
+<!DOCTYPE html><html class="reftest-paged"><style>html{font-size:12pt}</style>
diff --git a/layout/reftests/pagination/combobox-page-break-inside-ref.html b/layout/reftests/pagination/combobox-page-break-inside-ref.html
--- a/layout/reftests/pagination/combobox-page-break-inside-ref.html
+++ b/layout/reftests/pagination/combobox-page-break-inside-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <meta charset="utf-8">
 <style type="text/css">
 @page { size:5in 3in; margin:0in; }
 div { height: 0in; }
 select { height: 0.5in; display:block; padding:20px; page-break-before:always; }
 </style>
 </head>
diff --git a/layout/reftests/pagination/combobox-page-break-inside.html b/layout/reftests/pagination/combobox-page-break-inside.html
--- a/layout/reftests/pagination/combobox-page-break-inside.html
+++ b/layout/reftests/pagination/combobox-page-break-inside.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <meta charset="utf-8">
 <style type="text/css">
 @page { size:5in 3in; margin:0in; }
 div { height: 2.5in; }
 select { height: 0.5in; display:block; padding:20px; page-break-inside:avoid; }
 </style>
 </head>
diff --git a/layout/reftests/pagination/float-clear-000-print.html b/layout/reftests/pagination/float-clear-000-print.html
--- a/layout/reftests/pagination/float-clear-000-print.html
+++ b/layout/reftests/pagination/float-clear-000-print.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <style type="text/css">
 html, body {
   margin: 0;
   padding: 0;
   height: 100%;
 }
 
 .float {
diff --git a/layout/reftests/pagination/float-clear-000-print.ref.html b/layout/reftests/pagination/float-clear-000-print.ref.html
--- a/layout/reftests/pagination/float-clear-000-print.ref.html
+++ b/layout/reftests/pagination/float-clear-000-print.ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <style type="text/css">
 html, body {
   margin: 0;
   padding: 0;
   height: 100%;
 }
 
 .container {
diff --git a/layout/reftests/pagination/float-clear-001-print.html b/layout/reftests/pagination/float-clear-001-print.html
--- a/layout/reftests/pagination/float-clear-001-print.html
+++ b/layout/reftests/pagination/float-clear-001-print.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <style type="text/css">
 html, body {
   margin: 0;
   padding: 0;
   height: 100%;
 }
 
 .float {
diff --git a/layout/reftests/pagination/float-clear-002-print.html b/layout/reftests/pagination/float-clear-002-print.html
--- a/layout/reftests/pagination/float-clear-002-print.html
+++ b/layout/reftests/pagination/float-clear-002-print.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <style type="text/css">
 html, body {
   margin: 0;
   padding: 0;
   height: 100%;
 }
 
 .float {
diff --git a/layout/reftests/pagination/float-clear-003-print.html b/layout/reftests/pagination/float-clear-003-print.html
--- a/layout/reftests/pagination/float-clear-003-print.html
+++ b/layout/reftests/pagination/float-clear-003-print.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <style type="text/css">
 html, body {
   margin: 0;
   padding: 0;
   height: 100%;
 }
 
 .step {
diff --git a/layout/reftests/pagination/row-page-break-after-always-1.html b/layout/reftests/pagination/row-page-break-after-always-1.html
--- a/layout/reftests/pagination/row-page-break-after-always-1.html
+++ b/layout/reftests/pagination/row-page-break-after-always-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table >
 <tbody>
diff --git a/layout/reftests/pagination/row-page-break-after-always-2.html b/layout/reftests/pagination/row-page-break-after-always-2.html
--- a/layout/reftests/pagination/row-page-break-after-always-2.html
+++ b/layout/reftests/pagination/row-page-break-after-always-2.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table >
 <tbody>
diff --git a/layout/reftests/pagination/rowgroup-page-break-after-always-1.html b/layout/reftests/pagination/rowgroup-page-break-after-always-1.html
--- a/layout/reftests/pagination/rowgroup-page-break-after-always-1.html
+++ b/layout/reftests/pagination/rowgroup-page-break-after-always-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody style="page-break-after:always">
diff --git a/layout/reftests/pagination/rowgroup-tfoot-page-break-after-always-1.html b/layout/reftests/pagination/rowgroup-tfoot-page-break-after-always-1.html
--- a/layout/reftests/pagination/rowgroup-tfoot-page-break-after-always-1.html
+++ b/layout/reftests/pagination/rowgroup-tfoot-page-break-after-always-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tfoot><tr><td><div class="spacer"></div></td></tr></tfoot>
diff --git a/layout/reftests/pagination/rowgroup-thead-page-break-after-always-1.html b/layout/reftests/pagination/rowgroup-thead-page-break-after-always-1.html
--- a/layout/reftests/pagination/rowgroup-thead-page-break-after-always-1.html
+++ b/layout/reftests/pagination/rowgroup-thead-page-break-after-always-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <thead><tr><td><div class="spacer"></div></td></tr></thead>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-1-ref.html b/layout/reftests/pagination/table-caption-splitaftercaption-1-ref.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-1-ref.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-1-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height: 1in; width: 0.5in; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 </style>
 </head>
 <body>
 <div class=filler></div>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-1.html b/layout/reftests/pagination/table-caption-splitaftercaption-1.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-1.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height: 1in; width: 0.5in; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 </style>
 </head>
 <body>
 <div class=filler></div>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-10.html b/layout/reftests/pagination/table-caption-splitaftercaption-10.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-10.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-10.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height:5px; width: 50px; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 20px;border:thin solid green;}
 caption {margin-top: 5px; margin-bottom:5px; caption-side:top-outside}
 table {margin-top: 5px; margin-bottom:5px}
 </style>
 </head>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-11.html b/layout/reftests/pagination/table-caption-splitaftercaption-11.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-11.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-11.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height:5px; width: 50px; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 20px;border:thin solid green;}
 caption {margin-top: 5px; margin-bottom:5px; caption-side:bottom-outside}
 table {margin-top: 5px; margin-bottom:5px}
 </style>
 </head>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-2-ref.html b/layout/reftests/pagination/table-caption-splitaftercaption-2-ref.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-2-ref.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-2-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height: 0.5in; width: 0.5in; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 </style>
 </head>
 <body>
 <div class=filler></div>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-2.html b/layout/reftests/pagination/table-caption-splitaftercaption-2.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-2.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-2.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height: 0.5in; width: 0.5in; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 </style>
 </head>
 <body>
 <div class=filler></div>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-3-ref.html b/layout/reftests/pagination/table-caption-splitaftercaption-3-ref.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-3-ref.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-3-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.1in; margin-bottom:0.2in}
 </style>
 </head>
 <body>
 
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-3.html b/layout/reftests/pagination/table-caption-splitaftercaption-3.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-3.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-3.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.1in; margin-bottom:0.2in}
 </style>
 </head>
 <body>
 
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-4-ref.html b/layout/reftests/pagination/table-caption-splitaftercaption-4-ref.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-4-ref.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-4-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.15in; margin-bottom:0.15in}
 table {margin-top: 0.15in; margin-bottom:0.15in}
 </style>
 </head>
 <body>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-4.html b/layout/reftests/pagination/table-caption-splitaftercaption-4.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-4.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-4.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.15in; margin-bottom:0.15in}
 table {margin-top: 0.15in; margin-bottom:0.15in}
 </style>
 </head>
 <body>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-5-ref.html b/layout/reftests/pagination/table-caption-splitaftercaption-5-ref.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-5-ref.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-5-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.15in; margin-bottom:0.15in; caption-side:bottom}
 table {margin-top: 0.15in; margin-bottom:0.15in}
 </style>
 </head>
 <body>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-5.html b/layout/reftests/pagination/table-caption-splitaftercaption-5.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-5.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-5.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.15in; margin-bottom:0.15in; caption-side:bottom}
 table {margin-top: 0.15in; margin-bottom:0.15in}
 </style>
 </head>
 <body>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-6-ref.html b/layout/reftests/pagination/table-caption-splitaftercaption-6-ref.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-6-ref.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-6-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.1in; margin-bottom:0.3in; caption-side:top-outside}
 table {margin-top: 0.1in; margin-bottom:0.1in}
 </style>
 </head>
 <body>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-6.html b/layout/reftests/pagination/table-caption-splitaftercaption-6.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-6.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-6.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.1in; margin-bottom:0.3in; caption-side:top-outside}
 table {margin-top: 0.1in; margin-bottom:0.1in}
 </style>
 </head>
 <body>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-7-ref.html b/layout/reftests/pagination/table-caption-splitaftercaption-7-ref.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-7-ref.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-7-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.1in; margin-bottom:0.3in; caption-side:bottom-outside}
 table {margin-top: 0.1in; margin-bottom:0.1in}
 </style>
 </head>
 <body>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-7.html b/layout/reftests/pagination/table-caption-splitaftercaption-7.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-7.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-7.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 0px; width: 0px; padding: 0.2in;border:thin solid green;}
 caption {margin-top: 0.1in; margin-bottom:0.3in; caption-side:bottom-outside}
 table {margin-top: 0.1in; margin-bottom:0.1in}
 </style>
 </head>
 <body>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-8.html b/layout/reftests/pagination/table-caption-splitaftercaption-8.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-8.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-8.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height:5px; width: 50px; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 20px;border:thin solid green;}
 tfoot div {border-color:orange;}
 caption {margin-top: 5px; margin-bottom:5px; caption-side:top}
 table {margin-top: 5px; margin-bottom:5px}
 </style>
diff --git a/layout/reftests/pagination/table-caption-splitaftercaption-9.html b/layout/reftests/pagination/table-caption-splitaftercaption-9.html
--- a/layout/reftests/pagination/table-caption-splitaftercaption-9.html
+++ b/layout/reftests/pagination/table-caption-splitaftercaption-9.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height:5px; width: 50px; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 20px;border:thin solid green;}
 caption {margin-top: 5px; margin-bottom:5px; caption-side:bottom}
 table {margin-top: 5px; margin-bottom:5px}
 tfoot div.spacer {border-color:orange;}
 tbody div.spacer{border-width: 4px}	
diff --git a/layout/reftests/pagination/table-caption-splitrowgroup-1-ref.html b/layout/reftests/pagination/table-caption-splitrowgroup-1-ref.html
--- a/layout/reftests/pagination/table-caption-splitrowgroup-1-ref.html
+++ b/layout/reftests/pagination/table-caption-splitrowgroup-1-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height: 80px; width: 50px; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 20px;border:thin solid green;}
 </style>
 </head>
 <body>
 <div class=filler></div>
diff --git a/layout/reftests/pagination/table-caption-splitrowgroup-1.html b/layout/reftests/pagination/table-caption-splitrowgroup-1.html
--- a/layout/reftests/pagination/table-caption-splitrowgroup-1.html
+++ b/layout/reftests/pagination/table-caption-splitrowgroup-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height: 80px; width: 50px; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 20px;border:thin solid green;}
 </style>
 </head>
 <body>
 <div class=filler></div>
diff --git a/layout/reftests/pagination/table-nested-1308876-1-ref.html b/layout/reftests/pagination/table-nested-1308876-1-ref.html
--- a/layout/reftests/pagination/table-nested-1308876-1-ref.html
+++ b/layout/reftests/pagination/table-nested-1308876-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
+<html class="reftest-paged">
 <!--
 This reference matches our current rendering, which isn't necessarily
 correct, but I'd at least like to know about it if it changes, given how
 little test coverage of this we currently have.
 -->
 <style>
 html, body { margin: 0; padding: 0; }
 </style>
diff --git a/layout/reftests/pagination/table-nested-1308876-1.xhtml b/layout/reftests/pagination/table-nested-1308876-1.xhtml
--- a/layout/reftests/pagination/table-nested-1308876-1.xhtml
+++ b/layout/reftests/pagination/table-nested-1308876-1.xhtml
@@ -1,9 +1,9 @@
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged">
 <!--
 Reduced from layout/base/crashtests/470851-1.xhtml and turned into a reftest.
 -->
 <table style="background: black">
 <tbody>
 <tr>
 <td style="background: yellow">
   <table>
diff --git a/layout/reftests/pagination/table-page-break-after-always-1.html b/layout/reftests/pagination/table-page-break-after-always-1.html
--- a/layout/reftests/pagination/table-page-break-after-always-1.html
+++ b/layout/reftests/pagination/table-page-break-after-always-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table style="page-break-after:always">
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-after-left-1.html b/layout/reftests/pagination/table-page-break-after-left-1.html
--- a/layout/reftests/pagination/table-page-break-after-left-1.html
+++ b/layout/reftests/pagination/table-page-break-after-left-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table style="page-break-after:right">
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-after-right-1.html b/layout/reftests/pagination/table-page-break-after-right-1.html
--- a/layout/reftests/pagination/table-page-break-after-right-1.html
+++ b/layout/reftests/pagination/table-page-break-after-right-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table style="page-break-after:right">
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-before-always-1-ref.html b/layout/reftests/pagination/table-page-break-before-always-1-ref.html
--- a/layout/reftests/pagination/table-page-break-before-always-1-ref.html
+++ b/layout/reftests/pagination/table-page-break-before-always-1-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-before-always-1.html b/layout/reftests/pagination/table-page-break-before-always-1.html
--- a/layout/reftests/pagination/table-page-break-before-always-1.html
+++ b/layout/reftests/pagination/table-page-break-before-always-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-before-auto-1-ref.html b/layout/reftests/pagination/table-page-break-before-auto-1-ref.html
--- a/layout/reftests/pagination/table-page-break-before-auto-1-ref.html
+++ b/layout/reftests/pagination/table-page-break-before-auto-1-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-before-auto-1.html b/layout/reftests/pagination/table-page-break-before-auto-1.html
--- a/layout/reftests/pagination/table-page-break-before-auto-1.html
+++ b/layout/reftests/pagination/table-page-break-before-auto-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-before-auto-2-ref.html b/layout/reftests/pagination/table-page-break-before-auto-2-ref.html
--- a/layout/reftests/pagination/table-page-break-before-auto-2-ref.html
+++ b/layout/reftests/pagination/table-page-break-before-auto-2-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-before-auto-2.html b/layout/reftests/pagination/table-page-break-before-auto-2.html
--- a/layout/reftests/pagination/table-page-break-before-auto-2.html
+++ b/layout/reftests/pagination/table-page-break-before-auto-2.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-before-auto-3-ref.html b/layout/reftests/pagination/table-page-break-before-auto-3-ref.html
--- a/layout/reftests/pagination/table-page-break-before-auto-3-ref.html
+++ b/layout/reftests/pagination/table-page-break-before-auto-3-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <thead><tr><td><div class="spacer"></div></td></tr></thead>
diff --git a/layout/reftests/pagination/table-page-break-before-avoid-1.html b/layout/reftests/pagination/table-page-break-before-avoid-1.html
--- a/layout/reftests/pagination/table-page-break-before-avoid-1.html
+++ b/layout/reftests/pagination/table-page-break-before-avoid-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-before-left-1.html b/layout/reftests/pagination/table-page-break-before-left-1.html
--- a/layout/reftests/pagination/table-page-break-before-left-1.html
+++ b/layout/reftests/pagination/table-page-break-before-left-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody>
diff --git a/layout/reftests/pagination/table-page-break-before-right-1.html b/layout/reftests/pagination/table-page-break-before-right-1.html
--- a/layout/reftests/pagination/table-page-break-before-right-1.html
+++ b/layout/reftests/pagination/table-page-break-before-right-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table>
 <tbody>
diff --git a/layout/reftests/pagination/table-tfoot-thead-1-ref.html b/layout/reftests/pagination/table-tfoot-thead-1-ref.html
--- a/layout/reftests/pagination/table-tfoot-thead-1-ref.html
+++ b/layout/reftests/pagination/table-tfoot-thead-1-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height:5px; width: 50px; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 5px;border:thin solid green;}
 tfoot div.spacer {border-color:orange;
 height: 10px}
 tbody div.spacer{border-width: 4px}
 thead div.spacer{height: 140px}
diff --git a/layout/reftests/pagination/table-tfoot-thead-1.html b/layout/reftests/pagination/table-tfoot-thead-1.html
--- a/layout/reftests/pagination/table-tfoot-thead-1.html
+++ b/layout/reftests/pagination/table-tfoot-thead-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
     "http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.filler {height:5px; width: 50px; border:thin solid blue;}
 div.spacer { height: 0px; width: 0px; padding: 5px;border:thin solid green;}
 tfoot div.spacer {border-color:orange;
 height: 10px}
 tbody div.spacer{border-width: 4px}
 thead div.spacer{height: 140px}
diff --git a/layout/reftests/pagination/table_internal_pagebreak-1.html b/layout/reftests/pagination/table_internal_pagebreak-1.html
--- a/layout/reftests/pagination/table_internal_pagebreak-1.html
+++ b/layout/reftests/pagination/table_internal_pagebreak-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 	"http://www.w3.org/TR/html4/strict.dtd">
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
 <style type="text/css">
 div.spacer { height: 50px; width: 50px; border:thin solid green;}
 </style>
 </head>
 <body>
 <table><tr><td>
 <table>
diff --git a/layout/reftests/printing/1108104-ref.html b/layout/reftests/printing/1108104-ref.html
--- a/layout/reftests/printing/1108104-ref.html
+++ b/layout/reftests/printing/1108104-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <meta charset="utf-8">
   <style type="text/css" media="all">
 @font-face {
   font-family: 'dvsm';
   font-style: normal;
   font-weight: 200;
   src: url(../fonts/DejaVuSansMono.woff) format('truetype');
diff --git a/layout/reftests/printing/1108104.html b/layout/reftests/printing/1108104.html
--- a/layout/reftests/printing/1108104.html
+++ b/layout/reftests/printing/1108104.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <meta charset="utf-8">
   <style type="text/css" media="all">
 @font-face {
   font-family: 'dvsm';
   font-style: normal;
   font-weight: 200;
   src: url(../fonts/DejaVuSansMono.woff) format('truetype');
diff --git a/layout/reftests/printing/115199-1-ref.html b/layout/reftests/printing/115199-1-ref.html
--- a/layout/reftests/printing/115199-1-ref.html
+++ b/layout/reftests/printing/115199-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <style>
     * {
       margin: 0;
       padding: 0;
     }
     body {
       margin: 0.1in 0.1in;
diff --git a/layout/reftests/printing/115199-1.html b/layout/reftests/printing/115199-1.html
--- a/layout/reftests/printing/115199-1.html
+++ b/layout/reftests/printing/115199-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <style>
     @page {
       /*
        * Default page margins are .5in and the reference file adds .1inch margin
        * to the body hence we do .6in to match this.
        */
       margin: 0.6in;
diff --git a/layout/reftests/printing/115199-2-ref.html b/layout/reftests/printing/115199-2-ref.html
--- a/layout/reftests/printing/115199-2-ref.html
+++ b/layout/reftests/printing/115199-2-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <style>
     * {
       margin: 0;
       padding: 0;
     }
     div {
       width: 100%;
diff --git a/layout/reftests/printing/115199-2a.html b/layout/reftests/printing/115199-2a.html
--- a/layout/reftests/printing/115199-2a.html
+++ b/layout/reftests/printing/115199-2a.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <style>
     @page {
       /*
        * Test a margin that causes the page to have zero width.
        */
       margin: 0 2.5in;
     }
diff --git a/layout/reftests/printing/115199-2b.html b/layout/reftests/printing/115199-2b.html
--- a/layout/reftests/printing/115199-2b.html
+++ b/layout/reftests/printing/115199-2b.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <style>
     @page {
       /*
        * Test huge margins, they should be reset back the default margin size.
        */
       margin: 10in;
     }
diff --git a/layout/reftests/printing/1166147-ref.html b/layout/reftests/printing/1166147-ref.html
--- a/layout/reftests/printing/1166147-ref.html
+++ b/layout/reftests/printing/1166147-ref.html
@@ -22,14 +22,14 @@ 3. Considering a margin of 0.5in on each
 
 Similarly, the size for the test case printable area is calculated, only
 considering a vertical-rl writing mode.
 
 It is important to note here that when printing this test outside of the test
 harness, the background color will not show since we omit printing and
 previewing of background colors by default via the browser printing path.
 -->
-<html class="reftest-print">
+<html class="reftest-paged">
   <body style="margin:0;">
     <div style="background: teal; width:4in; height:6in;">
     </div>
   </body>
 </html>
\ No newline at end of file
diff --git a/layout/reftests/printing/1166147.html b/layout/reftests/printing/1166147.html
--- a/layout/reftests/printing/1166147.html
+++ b/layout/reftests/printing/1166147.html
@@ -23,14 +23,14 @@ 3. Considering a margin of 0.5in on each
 
 Similarly, the size for the reference printable area is calculated, only
 considering a horizontal-tb writing mode.
 
 It is important to note here that when printing this test outside of the test
 harness, the background color will not show since we omit printing and
 previewing of background colors by default via the browser printing path.
 -->
-<html class="reftest-print" style="writing-mode: vertical-rl;">
+<html class="reftest-paged" style="writing-mode: vertical-rl;">
   <body style="margin:0;">
     <div style="background: teal; width:12in; height:2in;">
     </div>
   </body>
 </html>
\ No newline at end of file
diff --git a/layout/reftests/printing/129941-1-ref.html b/layout/reftests/printing/129941-1-ref.html
--- a/layout/reftests/printing/129941-1-ref.html
+++ b/layout/reftests/printing/129941-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="margin: 0; padding: 0">
+<html class="reftest-paged" style="margin: 0; padding: 0">
   <body style="margin: 0; padding: 0">
     <div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green; border-bottom: none"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/129941-1a.html b/layout/reftests/printing/129941-1a.html
--- a/layout/reftests/printing/129941-1a.html
+++ b/layout/reftests/printing/129941-1a.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="margin: 0; padding: 0;">
+<html class="reftest-paged" style="margin: 0; padding: 0;">
   <body style="margin: 0; padding: 0;">
     <div style="overflow: scroll; height: 5in;">
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/129941-1b.html b/layout/reftests/printing/129941-1b.html
--- a/layout/reftests/printing/129941-1b.html
+++ b/layout/reftests/printing/129941-1b.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="margin: 0; padding: 0;">
+<html class="reftest-paged" style="margin: 0; padding: 0;">
   <body style="margin: 0; padding: 0;">
     <div style="overflow: -moz-hidden-unscrollable; height: 5in;">
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/129941-1c.html b/layout/reftests/printing/129941-1c.html
--- a/layout/reftests/printing/129941-1c.html
+++ b/layout/reftests/printing/129941-1c.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="margin: 0; padding: 0; overflow: hidden">
+<html class="reftest-paged" style="margin: 0; padding: 0; overflow: hidden">
   <body style="margin: 0; padding: 0; overflow: scroll; height: 5in">
     <div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/129941-1d.html b/layout/reftests/printing/129941-1d.html
--- a/layout/reftests/printing/129941-1d.html
+++ b/layout/reftests/printing/129941-1d.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="margin: 0; padding: 0; overflow: hidden">
+<html class="reftest-paged" style="margin: 0; padding: 0; overflow: hidden">
   <body style="margin: 0; padding: 0; overflow: -moz-hidden-unscrollable; height: 5in;">
     <div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/129941-1e.html b/layout/reftests/printing/129941-1e.html
--- a/layout/reftests/printing/129941-1e.html
+++ b/layout/reftests/printing/129941-1e.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="margin: 0; padding: 0;">
+<html class="reftest-paged" style="margin: 0; padding: 0;">
   <body style="margin: 0; padding: 0; overflow: -moz-hidden-unscrollable; height: 5in;">
     <div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/1321803-1-ref.html b/layout/reftests/printing/1321803-1-ref.html
--- a/layout/reftests/printing/1321803-1-ref.html
+++ b/layout/reftests/printing/1321803-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="margin: 0; padding: 0">
+<html class="reftest-paged" style="margin: 0; padding: 0">
   <body style="margin: 0; padding: 0">
     <div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green;"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/1321803-1a.html b/layout/reftests/printing/1321803-1a.html
--- a/layout/reftests/printing/1321803-1a.html
+++ b/layout/reftests/printing/1321803-1a.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print" style="margin: 0; padding: 0;">
+<html class="reftest-paged" style="margin: 0; padding: 0;">
   <body style="margin: 0; padding: 0; overflow: scroll; height: 5in">
     <div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
       <div style="height: 1.25in; border: 0.25in solid green"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/272830-1-ref.html b/layout/reftests/printing/272830-1-ref.html
--- a/layout/reftests/printing/272830-1-ref.html
+++ b/layout/reftests/printing/272830-1-ref.html
@@ -1,9 +1,9 @@
-<!DOCTYPE html><html class="reftest-print"><style>html{font-size:12pt}</style>
+<!DOCTYPE html><html class="reftest-paged"><style>html{font-size:12pt}</style>
 <table>
  <tr><td>xxxxxxxxxxxxxxxxxxx</td></tr>
  <tr><td>xxxxxxxxxxxxxxxxxxx</td></tr>
  <tr><td>xxxxxxxxxxxxxxxxxxx</td></tr>
  <tr><td>xxxxxxxxxxxxxxxxxxx</td></tr>
  <tr><td>xxxxxxxxxxxxxxxxxxx</td></tr>
  <tr><td>xxxxxxxxxxxxxxxxxxx</td></tr>
  <tr><td>xxxxxxxxxxxxxxxxxxx</td></tr>
diff --git a/layout/reftests/printing/272830-1.html b/layout/reftests/printing/272830-1.html
--- a/layout/reftests/printing/272830-1.html
+++ b/layout/reftests/printing/272830-1.html
@@ -1,9 +1,9 @@
-<!DOCTYPE html><html class="reftest-print"><style>html{font-size:12pt}</style>
+<!DOCTYPE html><html class="reftest-paged"><style>html{font-size:12pt}</style>
 <table>
  <tbody><tr><td>xxxxxxxxxxxxxxxxxxx</td></tr></tbody>
  <tbody><tr><td>xxxxxxxxxxxxxxxxxxx</td></tr></tbody>
  <tbody><tr><td>xxxxxxxxxxxxxxxxxxx</td></tr></tbody>
  <tbody><tr><td>xxxxxxxxxxxxxxxxxxx</td></tr></tbody>
  <tbody><tr><td>xxxxxxxxxxxxxxxxxxx</td></tr></tbody>
  <tbody><tr><td>xxxxxxxxxxxxxxxxxxx</td></tr></tbody>
  <tbody><tr><td>xxxxxxxxxxxxxxxxxxx</td></tr></tbody>
diff --git a/layout/reftests/printing/318022-1-ref.html b/layout/reftests/printing/318022-1-ref.html
--- a/layout/reftests/printing/318022-1-ref.html
+++ b/layout/reftests/printing/318022-1-ref.html
@@ -1,9 +1,9 @@
-<!DOCTYPE html><html class="reftest-print">
+<!DOCTYPE html><html class="reftest-paged">
 <head>
 <style type="text/css" media="all">
 html{font-size:12pt}
 #c {page-break-before:always;}
 </style>
 </head>
 <body>
 <div>Line 1</div>
diff --git a/layout/reftests/printing/318022-1.html b/layout/reftests/printing/318022-1.html
--- a/layout/reftests/printing/318022-1.html
+++ b/layout/reftests/printing/318022-1.html
@@ -1,9 +1,9 @@
-<!DOCTYPE html><html class="reftest-print">
+<!DOCTYPE html><html class="reftest-paged">
 <head>
 <style type="text/css" media="all">
 html{font-size:12pt}
 #a {float:left;}
 #b {clear:both;}
 #c {page-break-before:always;}
 </style>
 </head>
diff --git a/layout/reftests/printing/381497-f.html b/layout/reftests/printing/381497-f.html
--- a/layout/reftests/printing/381497-f.html
+++ b/layout/reftests/printing/381497-f.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Height test</title>
 
 <div style="top: 0; left: 0; right: 0; position: fixed; height: 100%; border-left: 2em blue solid;">
 The left border of this box must span the entire page content area.
 This box must be repeated on the second page.
 </div>
 
 <p style="page-break-before: always;">...
diff --git a/layout/reftests/printing/381497-n.html b/layout/reftests/printing/381497-n.html
--- a/layout/reftests/printing/381497-n.html
+++ b/layout/reftests/printing/381497-n.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
-<html class="reftest-print">
+<html class="reftest-paged">
 <title>Height test</title>
 <style type="text/css">
   html, body { height: 100%; margin: 0; padding: 0;}
 </style>
 
 
 <div style="height: 100%; border-left: 2em blue solid;">
 The left border of this box must span the entire page content area.
diff --git a/layout/reftests/printing/403669-1-ref.html b/layout/reftests/printing/403669-1-ref.html
--- a/layout/reftests/printing/403669-1-ref.html
+++ b/layout/reftests/printing/403669-1-ref.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
  <table cellspacing="0" cellpadding="0"
         width="1px">
   <tr><td>
    a a a a a a a a a a a a a a
    a a a a a a a a a a a a a a
   </td></tr>
  </table>
diff --git a/layout/reftests/printing/403669-1.html b/layout/reftests/printing/403669-1.html
--- a/layout/reftests/printing/403669-1.html
+++ b/layout/reftests/printing/403669-1.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
  <table cellspacing="0" cellpadding="0"
         height="100px" 
         width="1px">
   <tr><td>
    a a a a a a a a a a a a a a
    a a a a a a a a a a a a a a
   </td></tr>
diff --git a/layout/reftests/printing/577450-1-ref.html b/layout/reftests/printing/577450-1-ref.html
--- a/layout/reftests/printing/577450-1-ref.html
+++ b/layout/reftests/printing/577450-1-ref.html
@@ -1,8 +1,8 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="position: fixed; color: green; font-size: 2em">Big green text</div>
     <!-- force two pages -->
     <div style="height: 3in; width: 2in"></div>
   </body>
 </html>
diff --git a/layout/reftests/printing/577450-1.html b/layout/reftests/printing/577450-1.html
--- a/layout/reftests/printing/577450-1.html
+++ b/layout/reftests/printing/577450-1.html
@@ -1,8 +1,8 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body style="color: green; font-size: 2em">
     <div style="position: fixed">Big green text</div>
     <!-- force two pages -->
     <div style="height: 3in; width: 2in"></div>
   </body>
 </html>
diff --git a/layout/reftests/printing/609227-1-ref.html b/layout/reftests/printing/609227-1-ref.html
--- a/layout/reftests/printing/609227-1-ref.html
+++ b/layout/reftests/printing/609227-1-ref.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html>
 <html style="overflow: hidden; height: 100%; margin: 0; padding:0"
-      class="reftest-print">
+      class="reftest-paged">
   <body style="overflow: hidden; height: 100%; margin: 0; padding:0">
     <!-- Hidden overflow on the inline-block to put its baseline at its bottom
          edge, as in the original issue in bug 609227 -->
     <div style="height: 100%; display: inline-block; overflow: hidden">
       Some text
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/609227-1.html b/layout/reftests/printing/609227-1.html
--- a/layout/reftests/printing/609227-1.html
+++ b/layout/reftests/printing/609227-1.html
@@ -1,11 +1,11 @@
 <!DOCTYPE html>
 <html style="overflow: hidden; height: 100%; margin: 0; padding: 0"
-      class="reftest-print">
+      class="reftest-paged">
   <body style="overflow: hidden; height: 100%; margin: 0; padding:0">
     <div></div>
     <!-- Hidden overflow on the inline-block to put its baseline at its bottom
          edge, as in the original issue in bug 609227 -->
     <div style="height: 100%; display: inline-block; overflow: hidden">
       Some text
     </div>
   </body>
diff --git a/layout/reftests/printing/609227-2-ref.html b/layout/reftests/printing/609227-2-ref.html
--- a/layout/reftests/printing/609227-2-ref.html
+++ b/layout/reftests/printing/609227-2-ref.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="page-break-before: always">
       <div style="display: inline-block; width: 1in; height: 1in">
         Should be on second page
       </div>
     </div>
 </html>
diff --git a/layout/reftests/printing/609227-2a.html b/layout/reftests/printing/609227-2a.html
--- a/layout/reftests/printing/609227-2a.html
+++ b/layout/reftests/printing/609227-2a.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div>
       <div style="float: left; width: 3.5in; height: 1.5in;"></div>
     </div>
     <div>
       <div style="display: inline-block; width: 1in; height: 1in">
         Should be on second page
       </div>
diff --git a/layout/reftests/printing/609227-2b.html b/layout/reftests/printing/609227-2b.html
--- a/layout/reftests/printing/609227-2b.html
+++ b/layout/reftests/printing/609227-2b.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <!-- Key: no whitespace between float and inline-block -->
     <div>
       <div style="float: left; width: 3.5in;
                   height: 1.5in;"></div></div><div><div
              style="display: inline-block; width: 1in; height: 1in">
         Should be on second page
       </div>
diff --git a/layout/reftests/printing/626395-1-ref.html b/layout/reftests/printing/626395-1-ref.html
--- a/layout/reftests/printing/626395-1-ref.html
+++ b/layout/reftests/printing/626395-1-ref.html
@@ -1,8 +1,8 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="overflow: hidden; height: 3in">
     </div>
     Some text
   </body>
 </html>
diff --git a/layout/reftests/printing/626395-1a.html b/layout/reftests/printing/626395-1a.html
--- a/layout/reftests/printing/626395-1a.html
+++ b/layout/reftests/printing/626395-1a.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="overflow: hidden; height: 3in;">
       <div style="height: 10in;"></div>
     </div>
     Some text
   </body>
 </html>
diff --git a/layout/reftests/printing/626395-1b.html b/layout/reftests/printing/626395-1b.html
--- a/layout/reftests/printing/626395-1b.html
+++ b/layout/reftests/printing/626395-1b.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="overflow: -moz-hidden-unscrollable; height: 3in;">
       <div style="height: 10in;"></div>
     </div>
     Some text
   </body>
 </html>
diff --git a/layout/reftests/printing/626395-2-ref.html b/layout/reftests/printing/626395-2-ref.html
--- a/layout/reftests/printing/626395-2-ref.html
+++ b/layout/reftests/printing/626395-2-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="overflow: hidden; height: 3in">
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/626395-2a.html b/layout/reftests/printing/626395-2a.html
--- a/layout/reftests/printing/626395-2a.html
+++ b/layout/reftests/printing/626395-2a.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="overflow: hidden; height: 3in;
                 padding-bottom: 0.5in; margin-bottom: 5in">
       <div style="height: 10in;"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/626395-2b.html b/layout/reftests/printing/626395-2b.html
--- a/layout/reftests/printing/626395-2b.html
+++ b/layout/reftests/printing/626395-2b.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="overflow: -moz-hidden-unscrollable; height: 3in;
                 padding-bottom: 0.5in; margin-bottom: 5in">
       <div style="height: 10in;"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/626395-2c.html b/layout/reftests/printing/626395-2c.html
--- a/layout/reftests/printing/626395-2c.html
+++ b/layout/reftests/printing/626395-2c.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="overflow: hidden; height: 1in;
                 padding-bottom: 1in; border-bottom: 1in solid transparent">
       <div style="height: 10in;"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/626395-2d.html b/layout/reftests/printing/626395-2d.html
--- a/layout/reftests/printing/626395-2d.html
+++ b/layout/reftests/printing/626395-2d.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
   <body>
     <div style="overflow: -moz-hidden-unscrollable; height: 1in;
                 padding-bottom: 1in; border-bottom: 1in solid transparent">
       <div style="height: 10in;"></div>
     </div>
   </body>
 </html>
diff --git a/layout/reftests/printing/652178-1-ref.html b/layout/reftests/printing/652178-1-ref.html
--- a/layout/reftests/printing/652178-1-ref.html
+++ b/layout/reftests/printing/652178-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
   Something
   <div>
     <div style="width: 60%; float: left; border: 5px solid green;">
       This should print on page 1
     </div>
 
     <!-- This just needs to be taller than a page -->
diff --git a/layout/reftests/printing/652178-1-ref2.html b/layout/reftests/printing/652178-1-ref2.html
--- a/layout/reftests/printing/652178-1-ref2.html
+++ b/layout/reftests/printing/652178-1-ref2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
   Something
   <div style="height: 0">
     <div style="width: 60%; border: 5px solid green;">
       This should print on page 1
     </div>
   </div>
 
diff --git a/layout/reftests/printing/652178-1.html b/layout/reftests/printing/652178-1.html
--- a/layout/reftests/printing/652178-1.html
+++ b/layout/reftests/printing/652178-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
   Something
   <div>
     <div style="width: 60%; float: left; border: 5px solid green;">
       This should print on page 1
     </div>
 
     <!-- This just needs to be taller than a page -->
diff --git a/layout/reftests/printing/745025-1-ref.html b/layout/reftests/printing/745025-1-ref.html
--- a/layout/reftests/printing/745025-1-ref.html
+++ b/layout/reftests/printing/745025-1-ref.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 
 </head>
 <body>
 <!-- A 10x10 red image --><img style="-moz-transform: perspective(1px)" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAFElEQVQYlWP4z8DwnxjMMKqQvgoBksPHOVp9kXEAAAAASUVORK5CYII=">
 </body>
 </html>
diff --git a/layout/reftests/printing/745025-1.html b/layout/reftests/printing/745025-1.html
--- a/layout/reftests/printing/745025-1.html
+++ b/layout/reftests/printing/745025-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-wait reftest-print">
+<html class="reftest-wait reftest-paged">
 <body>
 <canvas id="canvas" width="10" height="10"></canvas>
 <script>
 var canvas = document.getElementById('canvas');
 canvas.mozPrintCallback = function(obj) {
   setTimeout(function() {
     var ctx = obj.context;
     ctx.fillStyle = 'rgb(255, 0, 0)';
diff --git a/layout/reftests/printing/820496-1-ref.html b/layout/reftests/printing/820496-1-ref.html
--- a/layout/reftests/printing/820496-1-ref.html
+++ b/layout/reftests/printing/820496-1-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body style="margin:0">
   <div style="height:10000px; background:blue;">
   <div style="height:5000px; width:50%; background:yellow;">
 </body>
 </html>
diff --git a/layout/reftests/printing/820496-1.html b/layout/reftests/printing/820496-1.html
--- a/layout/reftests/printing/820496-1.html
+++ b/layout/reftests/printing/820496-1.html
@@ -1,6 +1,6 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <body style="margin:0; height:10000px; background:blue;">
   <div style="height:5000px; width:50%; background:yellow;">
 </body>
 </html>
diff --git a/layout/reftests/printing/960822-ref.html b/layout/reftests/printing/960822-ref.html
--- a/layout/reftests/printing/960822-ref.html
+++ b/layout/reftests/printing/960822-ref.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><meta charset="utf-8"></head>
 <body>
 <div style="width:100in; border:solid blue;">line</div>
 </body>
 </html>
diff --git a/layout/reftests/printing/960822.html b/layout/reftests/printing/960822.html
--- a/layout/reftests/printing/960822.html
+++ b/layout/reftests/printing/960822.html
@@ -1,7 +1,7 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><meta charset="utf-8"></head>
 <body>
 <div style="width:30in; border:solid blue;">line</div>
 </body>
 </html>
diff --git a/layout/reftests/printing/966419-1-ref.html b/layout/reftests/printing/966419-1-ref.html
--- a/layout/reftests/printing/966419-1-ref.html
+++ b/layout/reftests/printing/966419-1-ref.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><meta charset="utf-8"></head>
 <body>
 <div style="width:8in; border:solid blue">line</div>
 <div style="page-break-before:always"></div>
 <div style="width:1in;height:1em"></div>
 </body>
 </html>
diff --git a/layout/reftests/printing/966419-1.html b/layout/reftests/printing/966419-1.html
--- a/layout/reftests/printing/966419-1.html
+++ b/layout/reftests/printing/966419-1.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><meta charset="utf-8"></head>
 <body>
 <div style="width:8in; border:solid blue">line</div>
 <div style="page-break-before:always"></div>
 <div style="width:6in;height:1em"></div>
 </body>
 </html>
diff --git a/layout/reftests/printing/966419-2-ref.html b/layout/reftests/printing/966419-2-ref.html
--- a/layout/reftests/printing/966419-2-ref.html
+++ b/layout/reftests/printing/966419-2-ref.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><meta charset="utf-8"></head>
 <body>
 <div style="width:1in;height:1em"></div>
 <div style="page-break-before:always"></div>
 <div style="width:8in; border:solid blue">line</div>
 </body>
 </html>
diff --git a/layout/reftests/printing/966419-2.html b/layout/reftests/printing/966419-2.html
--- a/layout/reftests/printing/966419-2.html
+++ b/layout/reftests/printing/966419-2.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><meta charset="utf-8"></head>
 <body>
 <div style="width:6in;height:1em"></div>
 <div style="page-break-before:always"></div>
 <div style="width:8in; border:solid blue">line</div>
 </body>
 </html>
diff --git a/layout/reftests/printing/blank.html b/layout/reftests/printing/blank.html
--- a/layout/reftests/printing/blank.html
+++ b/layout/reftests/printing/blank.html
@@ -1,1 +1,1 @@
-<!DOCTYPE html><html class="reftest-print"><style>html{font-size:12pt}</style>
+<!DOCTYPE html><html class="reftest-paged"><style>html{font-size:12pt}</style>
diff --git a/layout/reftests/printing/test-async-print.html b/layout/reftests/printing/test-async-print.html
--- a/layout/reftests/printing/test-async-print.html
+++ b/layout/reftests/printing/test-async-print.html
@@ -1,15 +1,15 @@
-<!DOCTYPE html><html class="reftest-wait reftest-print"><style>html{font-size:12pt}</style>
+<!DOCTYPE html><html class="reftest-wait reftest-paged"><style>html{font-size:12pt}</style>
 <head>
   <script type="text/javascript">
 
     window.onload = function (){ 
                       setTimeout(function() {
-                                   document.documentElement.className = "reftest-print";},
+                                   document.documentElement.className = "reftest-paged";},
                                  1000);
                     }
   </script>
 </head>
 <body>
 <table>
  <tbody><tr><td>xxxxxxxxxxxxxxxxxxx</td></tr></tbody>
  <tbody><tr><td>xxxxxxxxxxxxxxxxxxx</td></tr></tbody>
diff --git a/layout/reftests/reftest-sanity/page-height-2.1in.html b/layout/reftests/reftest-sanity/page-height-2.1in.html
--- a/layout/reftests/reftest-sanity/page-height-2.1in.html
+++ b/layout/reftests/reftest-sanity/page-height-2.1in.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
-<title>Test that reftest-print page content height is 2 inches (3 inch page, half inch margins)</title>
+<html class="reftest-paged">
+<title>Test that reftest-paged page content height is 2 inches (3 inch page, half inch margins)</title>
 <style>
 body { margin: 0 }
 div { height: 2.1in; }
 </style>
 <div>hello</div>
diff --git a/layout/reftests/reftest-sanity/page-height-2in.html b/layout/reftests/reftest-sanity/page-height-2in.html
--- a/layout/reftests/reftest-sanity/page-height-2in.html
+++ b/layout/reftests/reftest-sanity/page-height-2in.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
-<title>Test that reftest-print page content height is 2 inches (3 inch page, half inch margins)</title>
+<html class="reftest-paged">
+<title>Test that reftest-paged page content height is 2 inches (3 inch page, half inch margins)</title>
 <style>
 body { margin: 0 }
 div { height: 2in; }
 </style>
 <div>hello</div>
diff --git a/layout/reftests/reftest-sanity/page-height-forcebreak.html b/layout/reftests/reftest-sanity/page-height-forcebreak.html
--- a/layout/reftests/reftest-sanity/page-height-forcebreak.html
+++ b/layout/reftests/reftest-sanity/page-height-forcebreak.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
-<title>Test that reftest-print page content height is 2 inches (3 inch page, half inch margins)</title>
+<html class="reftest-paged">
+<title>Test that reftest-paged page content height is 2 inches (3 inch page, half inch margins)</title>
 <style>
 body { margin: 0 }
 </style>
 <div>hello</div>
 <div style="page-break-before: always">&nbsp;</div>
diff --git a/layout/reftests/reftest-sanity/page-height-nobreak.html b/layout/reftests/reftest-sanity/page-height-nobreak.html
--- a/layout/reftests/reftest-sanity/page-height-nobreak.html
+++ b/layout/reftests/reftest-sanity/page-height-nobreak.html
@@ -1,7 +1,7 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
-<title>Test that reftest-print page content height is 2 inches (3 inch page, half inch margins)</title>
+<html class="reftest-paged">
+<title>Test that reftest-paged page content height is 2 inches (3 inch page, half inch margins)</title>
 <style>
 body { margin: 0 }
 </style>
 <div>hello</div>
diff --git a/layout/reftests/reftest-sanity/page-width-3.9in.html b/layout/reftests/reftest-sanity/page-width-3.9in.html
--- a/layout/reftests/reftest-sanity/page-width-3.9in.html
+++ b/layout/reftests/reftest-sanity/page-width-3.9in.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
-<title>Test that reftest-print page content width is 4 inches (5 inch page, half inch margins)</title>
+<html class="reftest-paged">
+<title>Test that reftest-paged page content width is 4 inches (5 inch page, half inch margins)</title>
 <style>
 body { margin: 0 }
 div { background: blue; color: white; width: 3.9in; }
 </style>
 <div>hello</div>
diff --git a/layout/reftests/reftest-sanity/page-width-4.1in.html b/layout/reftests/reftest-sanity/page-width-4.1in.html
--- a/layout/reftests/reftest-sanity/page-width-4.1in.html
+++ b/layout/reftests/reftest-sanity/page-width-4.1in.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
-<title>Test that reftest-print page content width is 4 inches (5 inch page, half inch margins)</title>
+<html class="reftest-paged">
+<title>Test that reftest-paged page content width is 4 inches (5 inch page, half inch margins)</title>
 <style>
 body { margin: 0 }
 div { background: blue; color: white; width: 4.1in; }
 </style>
 <div>hello</div>
diff --git a/layout/reftests/reftest-sanity/page-width-4in.html b/layout/reftests/reftest-sanity/page-width-4in.html
--- a/layout/reftests/reftest-sanity/page-width-4in.html
+++ b/layout/reftests/reftest-sanity/page-width-4in.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
-<title>Test that reftest-print page content width is 4 inches (5 inch page, half inch margins)</title>
+<html class="reftest-paged">
+<title>Test that reftest-paged page content width is 4 inches (5 inch page, half inch margins)</title>
 <style>
 body { margin: 0 }
 div { background: blue; color: white; width: 4in; }
 </style>
 <div>hello</div>
diff --git a/layout/reftests/reftest-sanity/page-width-auto.html b/layout/reftests/reftest-sanity/page-width-auto.html
--- a/layout/reftests/reftest-sanity/page-width-auto.html
+++ b/layout/reftests/reftest-sanity/page-width-auto.html
@@ -1,8 +1,8 @@
 <!DOCTYPE HTML>
-<html class="reftest-print">
-<title>Test that reftest-print page content width is 4 inches (5 inch page, half inch margins)</title>
+<html class="reftest-paged">
+<title>Test that reftest-paged page content width is 4 inches (5 inch page, half inch margins)</title>
 <style>
 body { margin: 0 }
 div { background: blue; color: white; }
 </style>
 <div>hello</div>
diff --git a/layout/reftests/table-overflow/963441-ref.html b/layout/reftests/table-overflow/963441-ref.html
--- a/layout/reftests/table-overflow/963441-ref.html
+++ b/layout/reftests/table-overflow/963441-ref.html
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><meta charset="utf-8"></head>
 <body>
   <div style="height:3in">Tall div. (Scroll to end.)</div>
   <div>IS THIS TEXT VISIBLE IN PRINT PREVIEW?</div>
   <div>[clear:left]</div>
 </body>
 </html>
diff --git a/layout/reftests/table-overflow/963441.html b/layout/reftests/table-overflow/963441.html
--- a/layout/reftests/table-overflow/963441.html
+++ b/layout/reftests/table-overflow/963441.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head><meta charset="utf-8"></head>
 <body>
   <div style="float: left">
     <table cellpadding=0 cellspacing=0>
       <tr>
         <td>
           <div style="height:3in">Tall div. (Scroll to end.)</div>
           <div>IS THIS TEXT VISIBLE IN PRINT PREVIEW?</div>
diff --git a/layout/reftests/table-overflow/table-row-pagination-ref.html b/layout/reftests/table-overflow/table-row-pagination-ref.html
--- a/layout/reftests/table-overflow/table-row-pagination-ref.html
+++ b/layout/reftests/table-overflow/table-row-pagination-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print"><head>
+<html class="reftest-paged"><head>
     <meta charset="utf-8">
     <title>Testing row split</title>
     <style type="text/css">
 
         html,body {
             color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
         }
 	
diff --git a/layout/reftests/table-overflow/table-row-pagination.html b/layout/reftests/table-overflow/table-row-pagination.html
--- a/layout/reftests/table-overflow/table-row-pagination.html
+++ b/layout/reftests/table-overflow/table-row-pagination.html
@@ -1,10 +1,10 @@
 <!DOCTYPE HTML>
-<html class="reftest-print"><head>
+<html class="reftest-paged"><head>
     <meta charset="utf-8">
     <title>Testing row split</title>
     <style type="text/css">
 
         html,body {
             color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
         }
 	
diff --git a/layout/reftests/unicode/unicode-media-query-media-type.html b/layout/reftests/unicode/unicode-media-query-media-type.html
--- a/layout/reftests/unicode/unicode-media-query-media-type.html
+++ b/layout/reftests/unicode/unicode-media-query-media-type.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>Unicode tests - media query - media type selector</title>
   <style>
     @media prnt {
     p { color: red }
     }
   </style>
diff --git a/layout/reftests/unicode/unicode-media-query-query.html b/layout/reftests/unicode/unicode-media-query-query.html
--- a/layout/reftests/unicode/unicode-media-query-query.html
+++ b/layout/reftests/unicode/unicode-media-query-query.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>Unicode tests - media query - media query text</title>
   <style>
     @media print and (mn-wdth: 5in) { p {color: red; } }
   </style>
 </head>
 
diff --git a/layout/reftests/unicode/unicode-ref-print.html b/layout/reftests/unicode/unicode-ref-print.html
--- a/layout/reftests/unicode/unicode-ref-print.html
+++ b/layout/reftests/unicode/unicode-ref-print.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>Unicode tests - media query - reference</title>
 </head>
 
 <body>
   <div><p lang="hi"></p></div>
 </body>
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-1.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-1.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-1.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-10.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-10.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-10.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-10.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-11.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-11.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-11.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-11.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-12.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-12.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-12.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-12.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-13.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-13.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-13.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-13.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-8-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-14-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-14-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-14-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-14-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .test { page-break-before:always; height:1.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-14.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-14.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-14.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-14.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-14-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-15-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-15-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-15-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-15-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .test { page-break-before:always; height:2.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-15.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-15.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-15.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-15.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-15-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-2.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-2.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-2.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-3.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-3.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-3.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-4.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-4.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-4.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-4.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-5.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-5.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-5.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-5.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-6.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-6.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-6.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-6.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-7.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-7.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-7.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-7.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-8-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-8-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-8-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-8-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-8.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-8.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-8.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-8.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-8-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-9.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-9.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-9.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-9.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-block-page-break-inside-avoid-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .test { page-break-after:always; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-1.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-1.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-1.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-2-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-2-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-2-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-2-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .test { float:left; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-2.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-2.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-2.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-2-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-3.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-3.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-3.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-4.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-4.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-4.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-4.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-5-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-5-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-5-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-5-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
         html,body {
             color:black; background-color:white; font-size:16px; padding:0; margin:0;
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-5.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-5.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-5.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-5.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-6-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-6-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-6-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-6-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-6.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-6.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-6.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-6.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-6-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-7-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-7-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-7-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-7-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
 }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-7.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-7.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-7.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-7.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-7-ref.html">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-8-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-8-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-8-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-8-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
 }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-8.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-8.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-8.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-8.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-8-ref.html">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-9-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-9-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-9-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-9-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
 }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-9.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-9.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-9.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-9.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-9-ref.html">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-inline-page-break-inside-avoid-1-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-inline-page-break-inside-avoid-1-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-inline-page-break-inside-avoid-1-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-inline-page-break-inside-avoid-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-inline-page-break-inside-avoid-1.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-inline-page-break-inside-avoid-1.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-inline-page-break-inside-avoid-1.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-inline-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-inline-page-break-inside-avoid-1-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-row-page-break-inside-avoid-1.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-row-page-break-inside-avoid-1.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-row-page-break-inside-avoid-1.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-row-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-row-page-break-inside-avoid-2.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-row-page-break-inside-avoid-2.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-row-page-break-inside-avoid-2.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-row-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-1.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-1.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-1.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-2.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-2.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-2.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-3.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-3.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-3.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-4-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 thead { page-break-after:always; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-6.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-6.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-6.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-6.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .bb { page-break-before:always; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-7-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-8-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-1.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-1.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-1.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-2-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-2-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-2-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-2-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-2.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-2.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-2.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-2-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-3-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-3-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-3-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-3-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-3.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-3.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-3.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-3-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-4-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-4-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-4-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-4-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 table { display:inline-table; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-4.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-4.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-4.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-4.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-4-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-5-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-5-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-5-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-5-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-5.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-5.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-5.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-5.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-6-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-6-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-6-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-6-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 </style>
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-6.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-6.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-6.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-6.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-6-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-7-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-7-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-7-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-7-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 div { page-break-after: always; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-7.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-7.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-7.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-7.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-7-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-8.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-8.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-8.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-8.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-6-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-ref.html b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-ref.html
--- a/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-ref.html
+++ b/layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-table-page-break-inside-avoid-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/layout/reftests/w3c-css/submitted/multicol3/multicol-height-002.xht b/layout/reftests/w3c-css/submitted/multicol3/multicol-height-002.xht
--- a/layout/reftests/w3c-css/submitted/multicol3/multicol-height-002.xht
+++ b/layout/reftests/w3c-css/submitted/multicol3/multicol-height-002.xht
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml">
- <head class="reftest-print">
+ <head class="reftest-paged">
   <title>CSS Test: Percentage Computed Height on Multicol Child (Definite Multicol Height)</title>
   <link rel="author" title="Elika J. Etemad" href="http://fantasai.inkedblade.net/contact" />
   <link rel="help" href="http://www.w3.org/TR/css3-multicol/#the-multi-column-model" />
   <link rel="help" href="http://www.w3.org/TR/CSS21/visudet.html#the-height-property"/>
   <meta name="flags" content="" />
   <meta name="assert" content="Percentage heights with a multi-column element are relative to the computed height of the multicolumn box, and this works even when the multi-column element is paginated." />
   <link rel="match" href="reference/multicol-height-002.xht" />
   <style type="text/css"><![CDATA[
diff --git a/layout/reftests/w3c-css/submitted/multicol3/reference/multicol-height-002.xht b/layout/reftests/w3c-css/submitted/multicol3/reference/multicol-height-002.xht
--- a/layout/reftests/w3c-css/submitted/multicol3/reference/multicol-height-002.xht
+++ b/layout/reftests/w3c-css/submitted/multicol3/reference/multicol-height-002.xht
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml">
- <head class="reftest-print">
+ <head class="reftest-paged">
   <title>CSS Reftest Reference</title>
   <link rel="author" title="Elika J. Etemad" href="http://fantasai.inkedblade.net/contact" />
   <style type="text/css"><![CDATA[
     html, body { height: 100%; }
     * { margin: 0; }
     div {
       border: double blue 12px;
       height: 150%;
diff --git a/layout/style/ErrorReporter.cpp b/layout/style/ErrorReporter.cpp
--- a/layout/style/ErrorReporter.cpp
+++ b/layout/style/ErrorReporter.cpp
@@ -160,18 +160,17 @@ ErrorReporter::ErrorReporter(const Servo
 ErrorReporter::~ErrorReporter()
 {
   // Schedule deferred cleanup for cached data. We want to strike a
   // balance between performance and memory usage, so we only allow
   // short-term caching.
   if (sSpecCache && sSpecCache->IsInUse() && !sSpecCache->IsPending()) {
     nsCOMPtr<nsIRunnable> runnable(sSpecCache);
     nsresult rv =
-      SystemGroup::Dispatch("ShortTermURISpecCache", TaskCategory::Other,
-                            runnable.forget());
+      SystemGroup::Dispatch(TaskCategory::Other, runnable.forget());
     if (NS_FAILED(rv)) {
       // Peform the "deferred" cleanup immediately if the dispatch fails.
       sSpecCache->Run();
     } else {
       sSpecCache->SetPending();
     }
   }
 }
diff --git a/layout/style/FontFaceSet.cpp b/layout/style/FontFaceSet.cpp
--- a/layout/style/FontFaceSet.cpp
+++ b/layout/style/FontFaceSet.cpp
@@ -1516,18 +1516,17 @@ FontFaceSet::DispatchCheckLoadingFinishe
     set->AppendTask(PostTraversalTask::DispatchFontFaceSetCheckLoadingFinishedAfterDelay(this));
     return;
   }
 
   nsCOMPtr<nsIRunnable> checkTask =
     NewRunnableMethod("dom::FontFaceSet::CheckLoadingFinishedAfterDelay",
                       this,
                       &FontFaceSet::CheckLoadingFinishedAfterDelay);
-  mDocument->Dispatch("FontFaceSet::CheckLoadingFinishedAfterDelay",
-                      TaskCategory::Other, checkTask.forget());
+  mDocument->Dispatch(TaskCategory::Other, checkTask.forget());
 }
 
 void
 FontFaceSet::DidRefresh()
 {
   CheckLoadingFinished();
 }
 
diff --git a/layout/style/Loader.cpp b/layout/style/Loader.cpp
--- a/layout/style/Loader.cpp
+++ b/layout/style/Loader.cpp
@@ -2471,24 +2471,21 @@ Loader::PostLoadEvent(nsIURI* aURI,
 
   if (!mPostedEvents.AppendElement(evt)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   nsresult rv;
   RefPtr<SheetLoadData> runnable(evt);
   if (mDocument) {
-    rv = mDocument->Dispatch("SheetLoadData", TaskCategory::Other,
-                             runnable.forget());
+    rv = mDocument->Dispatch(TaskCategory::Other, runnable.forget());
   } else if (mDocGroup) {
-    rv = mDocGroup->Dispatch("SheetLoadData", TaskCategory::Other,
-                             runnable.forget());
+    rv = mDocGroup->Dispatch(TaskCategory::Other, runnable.forget());
   } else {
-    rv = SystemGroup::Dispatch("SheetLoadData", TaskCategory::Other,
-                               runnable.forget());
+    rv = SystemGroup::Dispatch(TaskCategory::Other, runnable.forget());
   }
 
   if (NS_FAILED(rv)) {
     NS_WARNING("failed to dispatch stylesheet load event");
     mPostedEvents.RemoveElement(evt);
   } else {
     // We'll unblock onload when we handle the event.
     if (mDocument) {
diff --git a/layout/style/PostTraversalTask.h b/layout/style/PostTraversalTask.h
--- a/layout/style/PostTraversalTask.h
+++ b/layout/style/PostTraversalTask.h
@@ -2,16 +2,18 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_PostTraversalTask_h
 #define mozilla_PostTraversalTask_h
 
+#include "nscore.h"
+
 /* a task to be performed immediately after a Servo traversal */
 
 namespace mozilla {
 namespace dom {
 class FontFace;
 class FontFaceSet;
 } // namespace dom
 } // namespace mozilla
diff --git a/layout/style/nsRuleProcessorData.h b/layout/style/nsRuleProcessorData.h
--- a/layout/style/nsRuleProcessorData.h
+++ b/layout/style/nsRuleProcessorData.h
@@ -68,22 +68,31 @@ class MOZ_STACK_CLASS AncestorFilter {
   // size, so let's do that.  We get a false positive rate of 1% or
   // less even with several hundred things in the filter.  Note that
   // we allocate the filter lazily, because not all tree match
   // contexts can use one effectively.
   typedef mozilla::BloomFilter<12, nsIAtom> Filter;
   nsAutoPtr<Filter> mFilter;
 
   // Stack of indices to pop to.  These are indices into mHashes.
-  nsTArray<uint32_t> mPopTargets;
+  // 16 is chosen because it's enough to avoid most allocations for the
+  // Speedometer 2 benchmark, and also it covers many cases in some casual
+  // local browsing tests performed.  Higher values in the range of tens
+  // were observed while testing through local browsing but they were rare.
+  AutoTArray<uint32_t, 16> mPopTargets;
 
   // List of hashes; this is what we pop using mPopTargets.  We store
   // hashes of our ancestor element tag names, ids, and classes in
   // here.
-  nsTArray<uint32_t> mHashes;
+  // 50 is chosen to be the same as the preallocated buffer size used in
+  // TreeMatchContext::InitAncestors().  This value seems to be large
+  // enough for Speedometer 2, although some casual testing browsing real
+  // sites suggested they can easily require values much larger (in the
+  // range of hundreds.)
+  AutoTArray<uint32_t, 50> mHashes;
 
   // A debug-only stack of Elements for use in assertions
 #ifdef DEBUG
   nsTArray<mozilla::dom::Element*> mElements;
 #endif
 };
 
 /**
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -2037,18 +2037,17 @@ nsStyleImageRequest::~nsStyleImageReques
         new StyleImageRequestCleanupTask(mModeFlags,
                                          mRequestProxy.forget(),
                                          mImageValue.forget(),
                                          mImageTracker.forget());
     if (NS_IsMainThread()) {
       task->Run();
     } else {
       if (mDocGroup) {
-        mDocGroup->Dispatch("StyleImageRequestCleanupTask",
-                            TaskCategory::Other, task.forget());
+        mDocGroup->Dispatch(TaskCategory::Other, task.forget());
       } else {
         // if Resolve was not called at some point, mDocGroup is not set.
         NS_DispatchToMainThread(task.forget());
       }
     }
   }
 
   MOZ_ASSERT(!mRequestProxy);
diff --git a/layout/tables/crashtests/1027611-1.html b/layout/tables/crashtests/1027611-1.html
--- a/layout/tables/crashtests/1027611-1.html
+++ b/layout/tables/crashtests/1027611-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
   <style>
     thead {
       position: relative;
     }
     tr {
       height: 60px;
     }
diff --git a/layout/tables/crashtests/347367.html b/layout/tables/crashtests/347367.html
--- a/layout/tables/crashtests/347367.html
+++ b/layout/tables/crashtests/347367.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print"><head>
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-paged"><head>
 <title>Testcase bug 347367 - crash when print preview is opened on a certain file styled with meda=print [@ BasicTableLayoutStrategy::CalcPctAdjTableWidth]</title>
 <style>
 div.page
 {
  float:left;
  clear:both;
 }
 
diff --git a/layout/tables/crashtests/362275.html b/layout/tables/crashtests/362275.html
--- a/layout/tables/crashtests/362275.html
+++ b/layout/tables/crashtests/362275.html
@@ -1,9 +1,9 @@
-<html class="reftest-print"><head>
+<html class="reftest-paged"><head>
 <title>Testcase bug 362275 - Hang with testcase on print preview, using -moz-column-count and table related stuff</title>
 </head>
 <body>
 This page should not hang Mozilla on print preview
 <div style="-moz-column-count: 2;">
   <span style="display: table-cell;">	
     <span>
       <textarea style="display: table-cell;"></textarea>
diff --git a/layout/tables/crashtests/373400-1.html b/layout/tables/crashtests/373400-1.html
--- a/layout/tables/crashtests/373400-1.html
+++ b/layout/tables/crashtests/373400-1.html
@@ -1,9 +1,9 @@
-<html class="reftest-print"><head>
+<html class="reftest-paged"><head>
 <style>
 td {
 height: 670px;
 }
 </style>
 </head>
 <body>
 <table border="1"><tbody>
diff --git a/layout/tables/crashtests/373400-2.html b/layout/tables/crashtests/373400-2.html
--- a/layout/tables/crashtests/373400-2.html
+++ b/layout/tables/crashtests/373400-2.html
@@ -1,9 +1,9 @@
-<html class="reftest-print"><head><title>tinderbox: Firefox</title></head>
+<html class="reftest-paged"><head><title>tinderbox: Firefox</title></head>
 <body>
 <table bgcolor="#ffffff" border="1" cellpadding="1" cellspacing="1">
 <tbody><tr align="center">
 <th>Build Time</th>
 <th>Guilty</th>
 <td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">Linux argo-vm Dep Nightly</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">Linux bl-bldlnx01 Dep argo-vm test perf</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">Linux bl-bldlnx01 Dep fx-linux-tbox test perf</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">Linux fx-linux-tbox Dep</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">Linux fxdbug-linux-tbox Dep</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">Linux qm-rhel02 dep unit test</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">MacOSX Darwin 8.8.4 bm-xserve08 Dep Universal Nightly</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">MacOSX Darwin 8.8.4 qm-xserve01 dep unit test</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">WINNT 5.1 bl-bldxp01 Dep fx-win32-tbox perf test</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">WINNT 5.1 qm-winxp01 dep unit test</font></td><td rowspan="2" bgcolor="#11dd11"><font face="Helvetica,Arial" size="-1">WINNT 5.2 fx-win32-tbox Dep Nightly</font></td></tr><tr>
 <td rowspan="1"><font size="-1">Click time to <br>see changes <br>since then</font></td><td><font size="-1">Click name to see what they did</font></td></tr>
 <tr align="center"><td align="right"><a href="http://bonsai.mozilla.org/cvsquery.cgi?module=PhoenixTinderbox&amp;date=explicit&amp;mindate=1176559022">
diff --git a/layout/tables/crashtests/373400-3.html b/layout/tables/crashtests/373400-3.html
--- a/layout/tables/crashtests/373400-3.html
+++ b/layout/tables/crashtests/373400-3.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <body>
 <table border>
 	<tr>
 		<td rowspan="2" valign="top">
 <p>Location:  </p>
 
 <p>
 We are located at 333 West San Carlos Street, Suite 1650, San Jose.
diff --git a/layout/tables/crashtests/563009-1.html b/layout/tables/crashtests/563009-1.html
--- a/layout/tables/crashtests/563009-1.html
+++ b/layout/tables/crashtests/563009-1.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style type="text/css">
 
  div.room {
    display: inline-block;
    float: left;
    border: 1px solid green; 
  }
diff --git a/layout/tables/crashtests/563009-2.html b/layout/tables/crashtests/563009-2.html
--- a/layout/tables/crashtests/563009-2.html
+++ b/layout/tables/crashtests/563009-2.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
 
diff --git a/layout/tables/crashtests/563009-3.html b/layout/tables/crashtests/563009-3.html
--- a/layout/tables/crashtests/563009-3.html
+++ b/layout/tables/crashtests/563009-3.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <style type="text/css">
 
  div{
    border: 1px solid green; 
  }
 
 
diff --git a/layout/tables/crashtests/576890-1.html b/layout/tables/crashtests/576890-1.html
--- a/layout/tables/crashtests/576890-1.html
+++ b/layout/tables/crashtests/576890-1.html
@@ -1,8 +1,8 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 </head>
 <body style=" -moz-column-count: 2;">
 <b style="display: table-footer-group; page-break-before: always;"></b>
 <span style="display: table-header-group;"></span>
 </body>
 </html>
diff --git a/layout/tables/crashtests/576890-2.html b/layout/tables/crashtests/576890-2.html
--- a/layout/tables/crashtests/576890-2.html
+++ b/layout/tables/crashtests/576890-2.html
@@ -1,8 +1,8 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 </head>
 <body style=" -moz-column-count: 2;">
 <b style="display: table-footer-group; page-break-before: always;">footer</b>
 <span style="display: table-header-group;">header</span>
 </body>
 </html>
diff --git a/layout/tables/crashtests/576890-3.html b/layout/tables/crashtests/576890-3.html
--- a/layout/tables/crashtests/576890-3.html
+++ b/layout/tables/crashtests/576890-3.html
@@ -1,8 +1,8 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 </head>
 <body style=" -moz-column-count: 2;">
 <b style="display: table-footer-group;"></b>
 <span style="display: table-header-group; page-break-after: always;"></span>
 </body>
 </html>
diff --git a/layout/tables/crashtests/595758-1.xhtml b/layout/tables/crashtests/595758-1.xhtml
--- a/layout/tables/crashtests/595758-1.xhtml
+++ b/layout/tables/crashtests/595758-1.xhtml
@@ -1,9 +1,9 @@
-<html class="reftest-print" xmlns="http://www.w3.org/1999/xhtml">
+<html class="reftest-paged" xmlns="http://www.w3.org/1999/xhtml">
 
 <table contenteditable="true">
 <li/>
 <mtext xmlns="http://www.w3.org/1998/Math/MathML" style="display: table-caption;"/>
 </table>
 
 
 <style>
diff --git a/layout/tables/crashtests/595758-2.xhtml b/layout/tables/crashtests/595758-2.xhtml
--- a/layout/tables/crashtests/595758-2.xhtml
+++ b/layout/tables/crashtests/595758-2.xhtml
@@ -1,9 +1,9 @@
-<html class="reftest-print" xmlns="http://www.w3.org/1999/xhtml">
+<html class="reftest-paged" xmlns="http://www.w3.org/1999/xhtml">
 
  <table>
   <tbody>
    <tr>
     <td>
      <img style ="float: left" src=" data:image/gif,GIF89a%01%00%E8%03%80%00%00%00%00%00%FF%FF%FF!%F9%04%00%00%00%00%00%2C%00%00%00%00%01%00%E8%03%00%02%1E%84%8F%A9%CB%ED%0F%A3%9C%B4%DA%8B%B3%DE%BC%FB%0F%86%E2H%96%E6%89%A6%EA%CA%B6%EE%0B%3B%05%00%3B"/>
     </td>
    </tr>
diff --git a/layout/tables/crashtests/678447-1.html b/layout/tables/crashtests/678447-1.html
--- a/layout/tables/crashtests/678447-1.html
+++ b/layout/tables/crashtests/678447-1.html
@@ -1,9 +1,9 @@
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 </head>
 <body style=" -moz-column-count: 2;">
 <table>
 <tbody><tr><td>rowgroup1</td></tr></tbody>
 <tbody><tr><td>rowgroup2</td></tr></tbody>
 </table>
 </body>
diff --git a/layout/tables/crashtests/695430-1.html b/layout/tables/crashtests/695430-1.html
--- a/layout/tables/crashtests/695430-1.html
+++ b/layout/tables/crashtests/695430-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
-<html  class="reftest-print">
+<html  class="reftest-paged">
 <style>
 div.spacer{height:80px}
 td { border: solid 1px blue}
 table {border: solid 1px green}
 </style>
 <body>
 
   <div class="spacer"> </div>
diff --git a/layout/tables/crashtests/696640-1.html b/layout/tables/crashtests/696640-1.html
--- a/layout/tables/crashtests/696640-1.html
+++ b/layout/tables/crashtests/696640-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <meta name="flags" content="paged">
 <title> crash at A4 90% generated content + repeatable tfoot</title>
 <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=696640">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
diff --git a/layout/tables/crashtests/696640-2.html b/layout/tables/crashtests/696640-2.html
--- a/layout/tables/crashtests/696640-2.html
+++ b/layout/tables/crashtests/696640-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html class="reftest-print">
+<html class="reftest-paged">
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <meta name="flags" content="paged">
 <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=696640">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -5107,18 +5107,17 @@ nsTableFrame::BCRecalcNeeded(nsStyleCont
     // we need to recompute the borders and the caller needs to mark
     // the bc damage area
     // XXX In principle this should only be necessary for border style changes
     // However the bc painting code tries to maximize the drawn border segments
     // so it stores in the cellmap where a new border segment starts and this
     // introduces a unwanted cellmap data dependence on color
     nsCOMPtr<nsIRunnable> evt = new nsDelayedCalcBCBorders(this);
     nsresult rv =
-      GetContent()->OwnerDoc()->Dispatch("nsDelayedCalcBCBorders",
-                                         TaskCategory::Other, evt.forget());
+      GetContent()->OwnerDoc()->Dispatch(TaskCategory::Other, evt.forget());
     return NS_SUCCEEDED(rv);
   }
   return false;
 }
 
 
 // Compare two border segments, this comparison depends whether the two
 // segments meet at a corner and whether the second segment is inline-dir.
diff --git a/layout/tools/reftest/README.txt b/layout/tools/reftest/README.txt
--- a/layout/tools/reftest/README.txt
+++ b/layout/tools/reftest/README.txt
@@ -559,36 +559,36 @@ Testing Async Zooming: reftest-async-zoo
 
 When the "reftest-async-zoom" attribute is present on the root element then at
 the end of the test take the snapshot with the given async zoom on top of any
 existing zoom. Content is not re-rendered at the new zoom level. This
 corresponds to the mobile style "pinch zoom" style of zoom. This is unsupported
 in many configurations, and any tests using this will probably want to have
 pref(apz.allow_zooming,true) on them.
 
-Printing Tests: class="reftest-print"
+Pagination Tests: class="reftest-paged"
 =====================================
 
 Now that the patch for bug 374050 has landed
 (https://bugzilla.mozilla.org/show_bug.cgi?id=374050), it is possible to
 create reftests that run in a paginated context.
 
 The page size used is 5in wide and 3in tall (with the default half-inch
 margins).  This is to allow tests to have less text and to make the
 entire test fit on the screen.
 
-There is a layout/reftests/printing directory for printing reftests; however,
-there is nothing special about this directory.  You can put printing reftests
+There is a layout/reftests/printing directory for pagination reftests; however,
+there is nothing special about this directory.  You can put pagination reftests
 anywhere that is appropriate.
 
-The suggested first lines for any printing test is
-<!DOCTYPE html><html class="reftest-print">
+The suggested first lines for any pagination test is
+<!DOCTYPE html><html class="reftest-paged">
 <style>html{font-size:12pt}</style>
 
-The reftest-print class on the root element triggers the reftest to
+The reftest-paged class on the root element triggers the reftest to
 switch into page mode. Fixing the font size is suggested, although not
 required, because the pages are a fixed size in inches. The switch to page mode
 happens on load if the reftest-wait class is not present; otherwise it happens
 immediately after firing the MozReftestInvalidate event.
 
 The underlying layout support for this mode isn't really complete; it
 doesn't use exactly the same codepath as real print preview/print. In
 particular, scripting and frames are likely to cause problems; it is untested,
diff --git a/layout/tools/reftest/reftest-content.js b/layout/tools/reftest/reftest-content.js
--- a/layout/tools/reftest/reftest-content.js
+++ b/layout/tools/reftest/reftest-content.js
@@ -172,20 +172,25 @@ function setupFullZoom(contentRootElemen
 }
 
 function resetZoom() {
     markupDocumentViewer().fullZoom = 1.0;
 }
 
 function doPrintMode(contentRootElement) {
     // use getAttribute because className works differently in HTML and SVG
-    return contentRootElement &&
-           contentRootElement.hasAttribute('class') &&
-           contentRootElement.getAttribute('class').split(/\s+/)
-                             .indexOf("reftest-print") != -1;
+    if (contentRootElement &&
+        contentRootElement.hasAttribute('class')) {
+        var classList = contentRootElement.getAttribute('class').split(/\s+/);
+        if (classList.indexOf("reftest-print") != -1) {
+            SendException("reftest-print is obsolete, use reftest-paged instead");
+            return;
+        }
+        return classList.indexOf("reftest-paged") != -1;
+    }
 }
 
 function setupPrintMode() {
    var PSSVC =
        CC[PRINTSETTINGS_CONTRACTID].getService(CI.nsIPrintSettingsService);
    var ps = PSSVC.newPrintSettings;
    ps.paperWidth = 5;
    ps.paperHeight = 3;
diff --git a/layout/xul/nsImageBoxFrame.cpp b/layout/xul/nsImageBoxFrame.cpp
--- a/layout/xul/nsImageBoxFrame.cpp
+++ b/layout/xul/nsImageBoxFrame.cpp
@@ -109,18 +109,17 @@ nsImageBoxFrameEvent::Run()
 
 void
 FireImageDOMEvent(nsIContent* aContent, EventMessage aMessage)
 {
   NS_ASSERTION(aMessage == eLoad || aMessage == eLoadError,
                "invalid message");
 
   nsCOMPtr<nsIRunnable> event = new nsImageBoxFrameEvent(aContent, aMessage);
-  nsresult rv = aContent->OwnerDoc()->Dispatch("nsImageBoxFrameEvent",
-                                               TaskCategory::Other,
+  nsresult rv = aContent->OwnerDoc()->Dispatch(TaskCategory::Other,
                                                event.forget());
   if (NS_FAILED(rv)) {
     NS_WARNING("failed to dispatch image event");
   }
 }
 
 //
 // NS_NewImageBoxFrame
diff --git a/layout/xul/nsListBoxBodyFrame.cpp b/layout/xul/nsListBoxBodyFrame.cpp
--- a/layout/xul/nsListBoxBodyFrame.cpp
+++ b/layout/xul/nsListBoxBodyFrame.cpp
@@ -841,18 +841,17 @@ nsListBoxBodyFrame::InternalPositionChan
                                          -smoother->mDelta : smoother->mDelta);
 }
 
 nsresult
 nsListBoxBodyFrame::InternalPositionChanged(bool aUp, int32_t aDelta)
 {
   RefPtr<nsPositionChangedEvent> event =
     new nsPositionChangedEvent(this, aUp, aDelta);
-  nsresult rv = mContent->OwnerDoc()->Dispatch("nsPositionChangedEvent",
-                                               TaskCategory::Other,
+  nsresult rv = mContent->OwnerDoc()->Dispatch(TaskCategory::Other,
                                                do_AddRef(event));
   if (NS_SUCCEEDED(rv)) {
     if (!mPendingPositionChangeEvents.AppendElement(event)) {
       rv = NS_ERROR_OUT_OF_MEMORY;
       event->Revoke();
     }
   }
   return rv;
diff --git a/layout/xul/nsMenuBarFrame.cpp b/layout/xul/nsMenuBarFrame.cpp
--- a/layout/xul/nsMenuBarFrame.cpp
+++ b/layout/xul/nsMenuBarFrame.cpp
@@ -343,18 +343,17 @@ nsMenuBarFrame::ChangeMenuItem(nsMenuFra
     if (wasOpen && !aMenuItem->IsDisabled())
       aNewMenu = content;
   }
 
   // use an event so that hiding and showing can be done synchronously, which
   // avoids flickering
   nsCOMPtr<nsIRunnable> event =
     new nsMenuBarSwitchMenu(GetContent(), aOldMenu, aNewMenu, aSelectFirstItem);
-  return mContent->OwnerDoc()->Dispatch("nsMenuBarSwitchMenu",
-                                        TaskCategory::Other,
+  return mContent->OwnerDoc()->Dispatch(TaskCategory::Other,
                                         event.forget());
 }
 
 nsMenuFrame*
 nsMenuBarFrame::Enter(WidgetGUIEvent* aEvent)
 {
   if (!mCurrentMenu)
     return nullptr;
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -602,18 +602,17 @@ nsMenuFrame::PopupClosed(bool aDeselectM
             return;
 
           parent = parent->GetParent();
         }
 
         nsCOMPtr<nsIRunnable> event =
           new nsMenuActivateEvent(current->GetContent(),
                                   PresContext(), true);
-        mContent->OwnerDoc()->Dispatch("nsMenuActivateEvent",
-                                       TaskCategory::Other,
+        mContent->OwnerDoc()->Dispatch(TaskCategory::Other,
                                        event.forget());
       }
     }
   }
 }
 
 NS_IMETHODIMP
 nsMenuFrame::SelectMenu(bool aActivateFlag)
@@ -653,18 +652,17 @@ nsMenuFrame::SelectMenu(bool aActivateFl
     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
     if (pm) {
       nsMenuParent* menuParent = GetMenuParent();
       pm->CancelMenuTimer(menuParent);
     }
 
     nsCOMPtr<nsIRunnable> event =
       new nsMenuActivateEvent(mContent, PresContext(), aActivateFlag);
-    mContent->OwnerDoc()->Dispatch("nsMenuActivateEvent",
-                                   TaskCategory::Other,
+    mContent->OwnerDoc()->Dispatch(TaskCategory::Other,
                                    event.forget());
   }
 
   return NS_OK;
 }
 
 nsresult
 nsMenuFrame::AttributeChanged(int32_t aNameSpaceID,
@@ -1527,19 +1525,8 @@ void nsMenuTimerMediator::ClearFrame()
  * @param aName the name to return
  */
 NS_IMETHODIMP
 nsMenuTimerMediator::GetName(nsACString& aName)
 {
   aName.AssignLiteral("nsMenuTimerMediator");
   return NS_OK;
 }
-
-/**
- * Set the name to this timer callback.
- * @param aName the name to set
- */
-NS_IMETHODIMP
-nsMenuTimerMediator::SetName(const char* aName)
-{
-  // We don't need to change the name for nsMenuTimerMediator.
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -590,18 +590,17 @@ nsMenuPopupFrame::LayoutPopup(nsBoxLayou
       mPopupShownDispatcher = new nsXULPopupShownEvent(mContent, pc);
       mContent->AddSystemEventListener(NS_LITERAL_STRING("transitionend"),
                                        mPopupShownDispatcher, false, false);
       return;
     }
 
     // If there are no transitions, fire the popupshown event right away.
     nsCOMPtr<nsIRunnable> event = new nsXULPopupShownEvent(GetContent(), pc);
-    mContent->OwnerDoc()->Dispatch("nsXULPopupShownEvent",
-                                   TaskCategory::Other,
+    mContent->OwnerDoc()->Dispatch(TaskCategory::Other,
                                    event.forget());
   }
 
   if (needCallback && !mReflowCallbackData.mPosted) {
     pc->PresShell()->PostReflowCallback(this);
     mReflowCallbackData.MarkPosted(aAnchor, aSizedToPopup);
   }
 }
diff --git a/layout/xul/nsXULPopupManager.cpp b/layout/xul/nsXULPopupManager.cpp
--- a/layout/xul/nsXULPopupManager.cpp
+++ b/layout/xul/nsXULPopupManager.cpp
@@ -760,19 +760,17 @@ nsXULPopupManager::ShowMenu(nsIContent *
   InitTriggerEvent(nullptr, nullptr, nullptr);
   popupFrame->InitializePopup(menuFrame->GetAnchor(), nullptr, position, 0, 0,
                               MenuPopupAnchorType_Node, true);
 
   if (aAsynchronous) {
     nsCOMPtr<nsIRunnable> event =
       new nsXULPopupShowingEvent(popupFrame->GetContent(),
                                  parentIsContextMenu, aSelectFirstItem);
-    aMenu->OwnerDoc()->Dispatch("nsXULPopupShowingEvent",
-                                TaskCategory::Other,
-                                event.forget());
+    aMenu->OwnerDoc()->Dispatch(TaskCategory::Other, event.forget());
   }
   else {
     nsCOMPtr<nsIContent> popupContent = popupFrame->GetContent();
     FirePopupShowingEvent(popupContent, parentIsContextMenu, aSelectFirstItem, nullptr);
   }
 }
 
 void
@@ -1084,18 +1082,17 @@ nsXULPopupManager::HidePopup(nsIContent*
       popupFrame->SetPopupState(ePopupHiding);
     }
 
     // For menus, popupToHide is always the frontmost item in the list to hide.
     if (aAsynchronous) {
       nsCOMPtr<nsIRunnable> event =
         new nsXULPopupHidingEvent(popupToHide, nextPopup, lastPopup,
                                   popupFrame->PopupType(), deselectMenu, aIsCancel);
-        aPopup->OwnerDoc()->Dispatch("nsXULPopupHidingEvent",
-                                     TaskCategory::Other,
+        aPopup->OwnerDoc()->Dispatch(TaskCategory::Other,
                                      event.forget());
     }
     else {
       FirePopupHidingEvent(popupToHide, nextPopup, lastPopup,
                            popupFrame->PresContext(), popupFrame->PopupType(),
                            deselectMenu, aIsCancel);
     }
   }
@@ -1416,18 +1413,17 @@ nsXULPopupManager::ExecuteMenu(nsIConten
 
     // Now hide the popups. If the closemenu mode is auto, deselect the menu,
     // otherwise only one popup is closing, so keep the parent menu selected.
     HidePopupsInList(popupsToHide);
   }
 
   aEvent->SetCloseMenuMode(cmm);
   nsCOMPtr<nsIRunnable> event = aEvent;
-  aMenu->OwnerDoc()->Dispatch("nsXULMenuCommandEvent",
-                              TaskCategory::Other,
+  aMenu->OwnerDoc()->Dispatch(TaskCategory::Other,
                               event.forget());
 }
 
 void
 nsXULPopupManager::FirePopupShowingEvent(nsIContent* aPopup,
                                          bool aIsContextMenu,
                                          bool aSelectFirstItem,
                                          nsIDOMEvent* aTriggerEvent)
@@ -2777,19 +2773,17 @@ nsXULPopupPositionedEvent::DispatchIfNee
                                             bool aIsContextMenu,
                                             bool aSelectFirstItem)
 {
   // The popuppositioned event only fires on arrow panels for now.
   if (aPopup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
                           nsGkAtoms::arrow, eCaseMatters)) {
     nsCOMPtr<nsIRunnable> event =
       new nsXULPopupPositionedEvent(aPopup, aIsContextMenu, aSelectFirstItem);
-    aPopup->OwnerDoc()->Dispatch("nsXULPopupPositionedEvent",
-                                 TaskCategory::Other,
-                                 event.forget());
+    aPopup->OwnerDoc()->Dispatch(TaskCategory::Other, event.forget());
 
     return true;
   }
 
   return false;
 }
 
 NS_IMETHODIMP
diff --git a/layout/xul/tree/nsTreeBodyFrame.cpp b/layout/xul/tree/nsTreeBodyFrame.cpp
--- a/layout/xul/tree/nsTreeBodyFrame.cpp
+++ b/layout/xul/tree/nsTreeBodyFrame.cpp
@@ -4775,18 +4775,17 @@ nsTreeBodyFrame::FireScrollEvent()
 
 void
 nsTreeBodyFrame::PostScrollEvent()
 {
   if (mScrollEvent.IsPending())
     return;
 
   RefPtr<ScrollEvent> event = new ScrollEvent(this);
-  nsresult rv = mContent->OwnerDoc()->Dispatch("ScrollEvent",
-                                               TaskCategory::Other,
+  nsresult rv = mContent->OwnerDoc()->Dispatch(TaskCategory::Other,
                                                do_AddRef(event));
   if (NS_FAILED(rv)) {
     NS_WARNING("failed to dispatch ScrollEvent");
   } else {
     mScrollEvent = Move(event);
   }
 }
 
@@ -4972,18 +4971,17 @@ nsTreeBodyFrame::FullScrollbarsUpdate(bo
   // Overflow checking dispatches synchronous events, which can cause infinite
   // recursion during reflow. Do the first overflow check synchronously, but
   // force any nested checks to round-trip through the event loop. See bug
   // 905909.
   RefPtr<nsOverflowChecker> checker = new nsOverflowChecker(this);
   if (!mCheckingOverflow) {
     nsContentUtils::AddScriptRunner(checker);
   } else {
-    mContent->OwnerDoc()->Dispatch("nsOverflowChecker",
-                                   TaskCategory::Other,
+    mContent->OwnerDoc()->Dispatch(TaskCategory::Other,
                                    checker.forget());
   }
   return weakFrame.IsAlive();
 }
 
 nsresult
 nsTreeBodyFrame::OnImageIsAnimated(imgIRequest* aRequest)
 {
diff --git a/media/mtransport/nr_timer.cpp b/media/mtransport/nr_timer.cpp
--- a/media/mtransport/nr_timer.cpp
+++ b/media/mtransport/nr_timer.cpp
@@ -50,16 +50,17 @@
  */
 
 #include <string>
 
 #include "nsCOMPtr.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #include "nsIEventTarget.h"
+#include "nsINamed.h"
 #include "nsITimer.h"
 #include "nsNetCID.h"
 #include "runnable_utils.h"
 #include "mozilla/DebugOnly.h"
 
 extern "C" {
 #include "nr_api.h"
 #include "async_timer.h"
@@ -82,17 +83,18 @@ protected:
   /* additional members */
   NR_async_cb cb_;
   void *cb_arg_;
   std::string function_;
   int line_;
 };
 
 class nrappkitTimerCallback : public nrappkitCallback,
-                              public nsITimerCallback {
+                              public nsITimerCallback,
+                              public nsINamed {
  public:
   // We're going to release ourself in the callback, so we need to be threadsafe
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
 
   nrappkitTimerCallback(NR_async_cb cb, void *cb_arg,
                         const char *function, int line)
       : nrappkitCallback(cb, cb_arg, function, line),
@@ -105,22 +107,28 @@ class nrappkitTimerCallback : public nra
   virtual void Cancel() override {
     AddRef();  // Cancelling the timer causes the callback it holds to
                // be released. AddRef() keeps us alive.
     timer_->Cancel();
     timer_ = nullptr;
     Release(); // Will cause deletion of this object.
   }
 
+  NS_IMETHOD
+  GetName(nsACString& aName) override {
+    aName.AssignLiteral("nrappkitTimerCallback");
+    return NS_OK;
+  }
+
  private:
   nsCOMPtr<nsITimer> timer_;
   virtual ~nrappkitTimerCallback() {}
 };
 
-NS_IMPL_ISUPPORTS(nrappkitTimerCallback, nsITimerCallback)
+NS_IMPL_ISUPPORTS(nrappkitTimerCallback, nsITimerCallback, nsINamed)
 
 NS_IMETHODIMP nrappkitTimerCallback::Notify(nsITimer *timer) {
   r_log(LOG_GENERIC, LOG_DEBUG, "Timer callback fired (set in %s:%d)",
         function_.c_str(), line_);
   MOZ_RELEASE_ASSERT(timer == timer_);
   cb_(nullptr, 0, cb_arg_);
 
   // Allow the timer to go away.
diff --git a/media/mtransport/transportlayerloopback.cpp b/media/mtransport/transportlayerloopback.cpp
--- a/media/mtransport/transportlayerloopback.cpp
+++ b/media/mtransport/transportlayerloopback.cpp
@@ -14,16 +14,17 @@
 #include "nsIComponentManager.h"
 #include "nsComponentManagerUtils.h"
 #include "nsIComponentRegistrar.h"
 #include "nsIEventTarget.h"
 #include "nsIIOService.h"
 #include "nsIServiceManager.h"
 #include "nsISocketTransportService.h"
 #include "nsServiceManagerUtils.h"
+#include "nsString.h"
 
 #include "transportflow.h"
 #include "transportlayerloopback.h"
 
 namespace mozilla {
 
 MOZ_MTLOG_MODULE("mtransport")
 
@@ -113,19 +114,25 @@ void TransportLayerLoopback::DeliverPack
     MOZ_MTLOG(ML_DEBUG, LAYER_INFO << " Delivering packet of length " <<
          packet->len());
     SignalPacketReceived(this, packet->data(), packet->len());
 
     delete packet;
   }
 }
 
-NS_IMPL_ISUPPORTS(TransportLayerLoopback::Deliverer, nsITimerCallback)
+NS_IMPL_ISUPPORTS(TransportLayerLoopback::Deliverer, nsITimerCallback, nsINamed)
 
 NS_IMETHODIMP TransportLayerLoopback::Deliverer::Notify(nsITimer *timer) {
   if (!layer_)
     return NS_OK;
 
   layer_->DeliverPackets();
 
   return NS_OK;
 }
+
+NS_IMETHODIMP TransportLayerLoopback::Deliverer::GetName(nsACString& aName) {
+  aName.AssignLiteral("TransportLayerLoopback::Deliverer");
+  return NS_OK;
+}
+
 }  // close namespace
diff --git a/media/mtransport/transportlayerloopback.h b/media/mtransport/transportlayerloopback.h
--- a/media/mtransport/transportlayerloopback.h
+++ b/media/mtransport/transportlayerloopback.h
@@ -14,16 +14,17 @@
 #include "prlock.h"
 
 #include <memory>
 #include <queue>
 
 
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
+#include "nsINamed.h"
 #include "nsITimer.h"
 
 
 #include "m_cpp_utils.h"
 #include "transportflow.h"
 #include "transportlayer.h"
 
 // A simple loopback transport layer that is used for testing.
@@ -113,26 +114,28 @@ class TransportLayerLoopback : public Tr
     DISALLOW_COPY_ASSIGN(QueuedPacket);
 
     unsigned char *data_;
     size_t len_;
   };
 
   // A timer to deliver packets if some are available
   // Fires every 100 ms
-  class Deliverer : public nsITimerCallback {
+  class Deliverer : public nsITimerCallback
+                  , public nsINamed {
    public:
     explicit Deliverer(TransportLayerLoopback *layer) :
         layer_(layer) {}
     void Detach() {
       layer_ = nullptr;
     }
 
     NS_DECL_THREADSAFE_ISUPPORTS
     NS_DECL_NSITIMERCALLBACK
+    NS_DECL_NSINAMED
 
  private:
     virtual ~Deliverer() {
     }
 
     DISALLOW_COPY_ASSIGN(Deliverer);
 
     TransportLayerLoopback *layer_;
diff --git a/media/webrtc/signaling/src/media-conduit/AudioConduit.h b/media/webrtc/signaling/src/media-conduit/AudioConduit.h
--- a/media/webrtc/signaling/src/media-conduit/AudioConduit.h
+++ b/media/webrtc/signaling/src/media-conduit/AudioConduit.h
@@ -2,16 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 
 #ifndef AUDIO_SESSION_H_
 #define AUDIO_SESSION_H_
 
 #include "mozilla/Attributes.h"
+#include "mozilla/ReentrantMonitor.h"
 #include "mozilla/TimeStamp.h"
 #include "nsTArray.h"
 
 #include "MediaConduitInterface.h"
 #include "MediaEngineWrapper.h"
 
 // Audio Engine Includes
 #include "webrtc/common_types.h"
diff --git a/media/webrtc/signaling/src/media-conduit/VideoConduit.h b/media/webrtc/signaling/src/media-conduit/VideoConduit.h
--- a/media/webrtc/signaling/src/media-conduit/VideoConduit.h
+++ b/media/webrtc/signaling/src/media-conduit/VideoConduit.h
@@ -2,16 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef VIDEO_SESSION_H_
 #define VIDEO_SESSION_H_
 
 #include "mozilla/Atomics.h"
 #include "mozilla/Attributes.h"
+#include "mozilla/ReentrantMonitor.h"
 #include "mozilla/SharedThreadPool.h"
 #include "nsAutoPtr.h"
 #include "nsITimer.h"
 
 #include "MediaConduitInterface.h"
 #include "MediaEngineWrapper.h"
 #include "RunningStat.h"
 #include "runnable_utils.h"
diff --git a/media/webrtc/trunk/webrtc/modules/desktop_capture/screen_capturer_mac.mm b/media/webrtc/trunk/webrtc/modules/desktop_capture/screen_capturer_mac.mm
--- a/media/webrtc/trunk/webrtc/modules/desktop_capture/screen_capturer_mac.mm
+++ b/media/webrtc/trunk/webrtc/modules/desktop_capture/screen_capturer_mac.mm
@@ -24,16 +24,17 @@
 #include <dlfcn.h>
 #include <IOKit/pwr_mgt/IOPMLib.h>
 #include <OpenGL/CGLMacro.h>
 #include <OpenGL/OpenGL.h>
 
 #include "webrtc/base/checks.h"
 #include "webrtc/base/constructormagic.h"
 #include "webrtc/base/macutils.h"
+#include "webrtc/base/criticalsection.h"
 #include "webrtc/base/timeutils.h"
 #include "webrtc/modules/desktop_capture/desktop_capturer.h"
 #include "webrtc/modules/desktop_capture/desktop_capture_options.h"
 #include "webrtc/modules/desktop_capture/desktop_frame.h"
 #include "webrtc/modules/desktop_capture/desktop_geometry.h"
 #include "webrtc/modules/desktop_capture/desktop_region.h"
 #include "webrtc/modules/desktop_capture/mac/desktop_configuration.h"
 #include "webrtc/modules/desktop_capture/mac/desktop_configuration_monitor.h"
@@ -326,16 +327,24 @@ class ScreenCapturerMac : public Desktop
                         const CGRect *rect_array);
   static void ScreenRefreshCallback(CGRectCount count,
                                     const CGRect *rect_array,
                                     void *user_parameter);
   static void ScreenUpdateMoveCallback(CGScreenUpdateMoveDelta delta,
                                        size_t count,
                                        const CGRect *rect_array,
                                        void *user_parameter);
+  struct ScreenCallbackData {
+    explicit ScreenCallbackData(ScreenCapturerMac* capturer)
+              : capturer(capturer) {}
+    rtc::CriticalSection crit_sect_;
+    ScreenCapturerMac* capturer;
+  };
+
+  ScreenCallbackData* screen_callback_data_;
 #endif
 
   std::unique_ptr<DesktopFrame> CreateFrame();
 
   Callback* callback_ = nullptr;
 
   CGLContextObj cgl_context_ = nullptr;
   ScopedPixelBufferObject pixel_buffer_object_;
@@ -412,26 +421,30 @@ class InvertedDesktopFrame : public Desk
  private:
   std::unique_ptr<DesktopFrame> original_frame_;
 
   RTC_DISALLOW_COPY_AND_ASSIGN(InvertedDesktopFrame);
 };
 
 ScreenCapturerMac::ScreenCapturerMac(
     rtc::scoped_refptr<DesktopConfigurationMonitor> desktop_config_monitor)
-    : desktop_config_monitor_(desktop_config_monitor) {
+    : screen_callback_data_(new ScreenCallbackData(this))
+    , desktop_config_monitor_(desktop_config_monitor) {
 #if defined(MAC_OS_X_VERSION_10_8) && \
   (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8)
   display_stream_manager_ = new DisplayStreamManager;
 #endif
 }
 
 ScreenCapturerMac::~ScreenCapturerMac() {
   ReleaseBuffers();
-  UnregisterRefreshAndMoveHandlers();
+  {
+    rtc::CritScope lock(&screen_callback_data_->crit_sect_);
+    screen_callback_data_->capturer = nullptr;
+  }
 #if defined(MAC_OS_X_VERSION_10_8) && \
   (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8)
   display_stream_manager_->PrepareForSelfDestruction();
 #endif
   dlclose(app_services_library_);
   dlclose(opengl_library_);
 }
 
@@ -1029,24 +1042,24 @@ bool ScreenCapturerMac::RegisterRefreshA
       CFRunLoopSourceRef source =
           CGDisplayStreamGetRunLoopSource(display_stream);
       CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode);
       display_stream_manager_->SaveStream(unique_id, display_stream);
     }
   }
 #else
  CGError err = CGRegisterScreenRefreshCallback(
-      ScreenCapturerMac::ScreenRefreshCallback, this);
+      ScreenCapturerMac::ScreenRefreshCallback, screen_callback_data_);
   if (err != kCGErrorSuccess) {
     LOG(LS_ERROR) << "CGRegisterScreenRefreshCallback " << err;
     return false;
   }
 
   err = CGScreenRegisterMoveCallback(
-      ScreenCapturerMac::ScreenUpdateMoveCallback, this);
+      ScreenCapturerMac::ScreenUpdateMoveCallback, screen_callback_data_);
   if (err != kCGErrorSuccess) {
     LOG(LS_ERROR) << "CGScreenRegisterMoveCallback " << err;
     return false;
   }
 #endif
 
   return true;
 }
@@ -1093,31 +1106,57 @@ void ScreenCapturerMac::ScreenUpdateMove
 
   // Currently we just treat move events the same as refreshes.
   ScreenRefresh(count, refresh_rects);
 }
 
 void ScreenCapturerMac::ScreenRefreshCallback(CGRectCount count,
                                               const CGRect* rect_array,
                                               void* user_parameter) {
-  ScreenCapturerMac* capturer =
-      reinterpret_cast<ScreenCapturerMac*>(user_parameter);
-  if (capturer->screen_pixel_bounds_.is_empty())
-    capturer->ScreenConfigurationChanged();
-  capturer->ScreenRefresh(count, rect_array);
+  ScreenCallbackData* screen_callback_data =
+      reinterpret_cast<ScreenCallbackData*>(user_parameter);
+
+  screen_callback_data->crit_sect_.Enter();
+  if (!screen_callback_data->capturer) {
+    CGUnregisterScreenRefreshCallback(
+        ScreenCapturerMac::ScreenRefreshCallback, screen_callback_data);
+    CGScreenUnregisterMoveCallback(
+        ScreenCapturerMac::ScreenUpdateMoveCallback, screen_callback_data);
+    screen_callback_data->crit_sect_.Leave();
+    delete screen_callback_data;
+    return;
+  }
+
+  if (screen_callback_data->capturer->screen_pixel_bounds_.is_empty())
+    screen_callback_data->capturer->ScreenConfigurationChanged();
+  screen_callback_data->capturer->ScreenRefresh(count, rect_array);
+  screen_callback_data->crit_sect_.Leave();
 }
 
 void ScreenCapturerMac::ScreenUpdateMoveCallback(
     CGScreenUpdateMoveDelta delta,
     size_t count,
     const CGRect* rect_array,
     void* user_parameter) {
-  ScreenCapturerMac* capturer =
-      reinterpret_cast<ScreenCapturerMac*>(user_parameter);
-  capturer->ScreenUpdateMove(delta, count, rect_array);
+  ScreenCallbackData* screen_callback_data =
+      reinterpret_cast<ScreenCallbackData*>(user_parameter);
+
+  screen_callback_data->crit_sect_.Enter();
+  if (!screen_callback_data->capturer) {
+    CGUnregisterScreenRefreshCallback(
+        ScreenCapturerMac::ScreenRefreshCallback, screen_callback_data);
+    CGScreenUnregisterMoveCallback(
+        ScreenCapturerMac::ScreenUpdateMoveCallback, screen_callback_data);
+    screen_callback_data->crit_sect_.Leave();
+    delete screen_callback_data;
+    return;
+  }
+
+  screen_callback_data->capturer->ScreenUpdateMove(delta, count, rect_array);
+  screen_callback_data->crit_sect_.Leave();
 }
 #endif
 
 std::unique_ptr<DesktopFrame> ScreenCapturerMac::CreateFrame() {
   std::unique_ptr<DesktopFrame> frame(
       new BasicDesktopFrame(screen_pixel_bounds_.size()));
   frame->set_dpi(DesktopVector(kStandardDPI * dip_to_pixel_scale_,
                                kStandardDPI * dip_to_pixel_scale_));
diff --git a/mfbt/EnumSet.h b/mfbt/EnumSet.h
--- a/mfbt/EnumSet.h
+++ b/mfbt/EnumSet.h
@@ -229,17 +229,17 @@ public:
   class ConstIterator
   {
     const EnumSet<T>* mSet;
     uint32_t mPos;
 #ifdef DEBUG
     uint64_t mVersion;
 #endif
 
-    void checkVersion() {
+    void checkVersion() const {
       // Check that the set has not been modified while being iterated.
       MOZ_ASSERT_IF(mSet, mSet->mVersion == mVersion);
     }
 
    public:
     ConstIterator(const EnumSet<T>& aSet, uint32_t aPos)
      : mSet(&aSet), mPos(aPos)
     {
@@ -269,27 +269,27 @@ public:
 #endif
       aOther.mSet = nullptr;
     }
 
     ~ConstIterator() {
       checkVersion();
     }
 
-    bool operator==(const ConstIterator& other) {
+    bool operator==(const ConstIterator& other) const {
       MOZ_ASSERT(mSet == other.mSet);
       checkVersion();
       return mPos == other.mPos;
     }
 
-    bool operator!=(const ConstIterator& other) {
+    bool operator!=(const ConstIterator& other) const {
       return !(*this == other);
     }
 
-    T operator*() {
+    T operator*() const {
       MOZ_ASSERT(mSet);
       MOZ_ASSERT(mPos < kMaxBits);
       MOZ_ASSERT(mSet->contains(T(mPos)));
       checkVersion();
       return T(mPos);
     }
 
     ConstIterator& operator++() {
diff --git a/mfbt/GuardObjects.h b/mfbt/GuardObjects.h
--- a/mfbt/GuardObjects.h
+++ b/mfbt/GuardObjects.h
@@ -129,31 +129,31 @@ public:
 } /* namespace mozilla */
 
 #undef MOZ_POISON
 
 #endif /* DEBUG */
 
 #ifdef DEBUG
 #  define MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER \
-     mozilla::detail::GuardObjectNotificationReceiver _mCheckNotUsedAsTemporary;
+     ::mozilla::detail::GuardObjectNotificationReceiver _mCheckNotUsedAsTemporary;
 #  define MOZ_GUARD_OBJECT_NOTIFIER_PARAM \
-     , mozilla::detail::GuardObjectNotifier&& _notifier = \
-         mozilla::detail::GuardObjectNotifier()
+     , ::mozilla::detail::GuardObjectNotifier&& _notifier = \
+         ::mozilla::detail::GuardObjectNotifier()
 #  define MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM \
-     mozilla::detail::GuardObjectNotifier&& _notifier = \
-         mozilla::detail::GuardObjectNotifier()
+     ::mozilla::detail::GuardObjectNotifier&& _notifier = \
+         ::mozilla::detail::GuardObjectNotifier()
 #  define MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL \
-     , mozilla::detail::GuardObjectNotifier&& _notifier
+     , ::mozilla::detail::GuardObjectNotifier&& _notifier
 #  define MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM_IN_IMPL \
-     mozilla::detail::GuardObjectNotifier&& _notifier
+     ::mozilla::detail::GuardObjectNotifier&& _notifier
 #  define MOZ_GUARD_OBJECT_NOTIFIER_PARAM_TO_PARENT \
-     , mozilla::Move(_notifier)
+     , ::mozilla::Move(_notifier)
 #  define MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM_TO_PARENT \
-       mozilla::Move(_notifier)
+       ::mozilla::Move(_notifier)
 #  define MOZ_GUARD_OBJECT_NOTIFIER_INIT \
      do { _mCheckNotUsedAsTemporary.init(_notifier); } while (0)
 #else
 #  define MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 #  define MOZ_GUARD_OBJECT_NOTIFIER_PARAM
 #  define MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
 #  define MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
 #  define MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM_IN_IMPL
diff --git a/mobile/android/components/build/nsAndroidHistory.cpp b/mobile/android/components/build/nsAndroidHistory.cpp
--- a/mobile/android/components/build/nsAndroidHistory.cpp
+++ b/mobile/android/components/build/nsAndroidHistory.cpp
@@ -20,17 +20,17 @@
 #define PREF_HISTORY_ENABLED "places.history.enabled"
 
 // Time we wait to see if a pending visit is really a redirect
 #define PENDING_REDIRECT_TIMEOUT 3000
 
 using namespace mozilla;
 using mozilla::dom::Link;
 
-NS_IMPL_ISUPPORTS(nsAndroidHistory, IHistory, nsIRunnable, nsITimerCallback)
+NS_IMPL_ISUPPORTS(nsAndroidHistory, IHistory, nsIRunnable, nsITimerCallback, nsINamed)
 
 nsAndroidHistory* nsAndroidHistory::sHistory = nullptr;
 
 /*static*/
 nsAndroidHistory*
 nsAndroidHistory::GetSingleton()
 {
   if (!sHistory) {
@@ -189,16 +189,23 @@ nsAndroidHistory::Notify(nsITimer *timer
   for (i = 0; i < mPendingVisitURIs.Length(); ++i) {
     SaveVisitURI(mPendingVisitURIs.ElementAt(i));
   }
   mPendingVisitURIs.Clear();
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsAndroidHistory::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsAndroidHistory");
+  return NS_OK;
+}
+
 void
 nsAndroidHistory::SaveVisitURI(nsIURI* aURI) {
   // Add the URI to our cache so we can take a fast path later
   AppendToRecentlyVisitedURIs(aURI);
 
   if (jni::IsFennec()) {
     // Save this URI in our history
     nsAutoCString spec;
diff --git a/mobile/android/components/build/nsAndroidHistory.h b/mobile/android/components/build/nsAndroidHistory.h
--- a/mobile/android/components/build/nsAndroidHistory.h
+++ b/mobile/android/components/build/nsAndroidHistory.h
@@ -4,39 +4,42 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef NS_ANDROIDHISTORY_H
 #define NS_ANDROIDHISTORY_H
 
 #include "IHistory.h"
 #include "nsDataHashtable.h"
 #include "nsTPriorityQueue.h"
+#include "nsINamed.h"
 #include "nsIRunnable.h"
 #include "nsIURI.h"
 #include "nsITimer.h"
 
 
 #define NS_ANDROIDHISTORY_CID \
     {0xCCAA4880, 0x44DD, 0x40A7, {0xA1, 0x3F, 0x61, 0x56, 0xFC, 0x88, 0x2C, 0x0B}}
 
 // Max size of History::mRecentlyVisitedURIs
 #define RECENTLY_VISITED_URI_SIZE 8
 
 // Max size of History::mEmbedURIs
 #define EMBED_URI_SIZE 128
 
 class nsAndroidHistory final : public mozilla::IHistory,
                                public nsIRunnable,
-                               public nsITimerCallback
+                               public nsITimerCallback,
+                               public nsINamed
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_IHISTORY
   NS_DECL_NSIRUNNABLE
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   /**
    * Obtains a pointer that has had AddRef called on it.  Used by the service
    * manager only.
    */
   static nsAndroidHistory* GetSingleton();
 
   nsAndroidHistory();
diff --git a/modules/libpref/Preferences.cpp b/modules/libpref/Preferences.cpp
--- a/modules/libpref/Preferences.cpp
+++ b/modules/libpref/Preferences.cpp
@@ -373,18 +373,17 @@ public:
     if (prefs) {
       rv = PreferencesWriter::Write(mFile, *prefs);
 
       // Make a copy of these so we can have them in runnable lambda.
       // nsIFile is only there so that we would never release the
       // ref counted pointer off main thread.
       nsresult rvCopy = rv;
       nsCOMPtr<nsIFile> fileCopy(mFile);
-      SystemGroup::Dispatch("Preferences::WriterRunnable",
-                            TaskCategory::Other,
+      SystemGroup::Dispatch(TaskCategory::Other,
                             NS_NewRunnableFunction("Preferences::WriterRunnable", [fileCopy, rvCopy] {
         MOZ_RELEASE_ASSERT(NS_IsMainThread());
         if (NS_FAILED(rvCopy)) {
           Preferences::DirtyCallback();
         }
       }));
     }
     return rv;
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -1274,17 +1274,21 @@ pref("dom.storage.testing", false);
 pref("dom.send_after_paint_to_content", false);
 
 // Timeout clamp in ms for timeouts we clamp
 pref("dom.min_timeout_value", 4);
 // And for background windows
 pref("dom.min_background_timeout_value", 1000);
 // Timeout clamp in ms for tracking timeouts we clamp
 // Note that this requires the privacy.trackingprotection.annotate_channels pref to be on in order to have any effect.
+#ifdef NIGHTLY_BUILD
+pref("dom.min_tracking_timeout_value", 10000);
+#else
 pref("dom.min_tracking_timeout_value", 4);
+#endif
 // And for background windows
 // Note that this requires the privacy.trackingprotection.annotate_channels pref to be on in order to have any effect.
 pref("dom.min_tracking_background_timeout_value", 10000);
 // Delay in ms from document load until we start throttling background timeouts.
 pref("dom.timeout.throttling_delay", 30000);
 
 // Time (in ms) that it takes to regenerate 1ms.
 pref("dom.timeout.background_budget_regeneration_rate", 100);
diff --git a/netwerk/base/CaptivePortalService.cpp b/netwerk/base/CaptivePortalService.cpp
--- a/netwerk/base/CaptivePortalService.cpp
+++ b/netwerk/base/CaptivePortalService.cpp
@@ -21,17 +21,17 @@ namespace mozilla {
 namespace net {
 
 static LazyLogModule gCaptivePortalLog("CaptivePortalService");
 #undef LOG
 #define LOG(args) MOZ_LOG(gCaptivePortalLog, mozilla::LogLevel::Debug, args)
 
 NS_IMPL_ISUPPORTS(CaptivePortalService, nsICaptivePortalService, nsIObserver,
                   nsISupportsWeakReference, nsITimerCallback,
-                  nsICaptivePortalCallback)
+                  nsICaptivePortalCallback, nsINamed)
 
 CaptivePortalService::CaptivePortalService()
   : mState(UNKNOWN)
   , mStarted(false)
   , mInitialized(false)
   , mRequestInProgress(false)
   , mEverBeenCaptive(false)
   , mDelay(kDefaultInterval)
@@ -274,16 +274,27 @@ CaptivePortalService::Notify(nsITimer *a
 
   // Note - if mDelay is 0, the timer will not be rearmed.
   RearmTimer();
 
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
+// CaptivePortalService::nsINamed
+//-----------------------------------------------------------------------------
+
+NS_IMETHODIMP
+CaptivePortalService::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("CaptivePortalService");
+  return NS_OK;
+}
+
+//-----------------------------------------------------------------------------
 // CaptivePortalService::nsIObserver
 //-----------------------------------------------------------------------------
 NS_IMETHODIMP
 CaptivePortalService::Observe(nsISupports *aSubject,
                               const char * aTopic,
                               const char16_t * aData)
 {
   if (XRE_GetProcessType() != GeckoProcessType_Default) {
diff --git a/netwerk/base/CaptivePortalService.h b/netwerk/base/CaptivePortalService.h
--- a/netwerk/base/CaptivePortalService.h
+++ b/netwerk/base/CaptivePortalService.h
@@ -2,38 +2,41 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef CaptivePortalService_h_
 #define CaptivePortalService_h_
 
 #include "nsICaptivePortalService.h"
 #include "nsICaptivePortalDetector.h"
+#include "nsINamed.h"
 #include "nsIObserver.h"
 #include "nsWeakReference.h"
 #include "nsITimer.h"
 #include "nsCOMArray.h"
 #include "mozilla/TimeStamp.h"
 
 namespace mozilla {
 namespace net {
 
 class CaptivePortalService
   : public nsICaptivePortalService
   , public nsIObserver
   , public nsSupportsWeakReference
   , public nsITimerCallback
   , public nsICaptivePortalCallback
+  , public nsINamed
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSICAPTIVEPORTALSERVICE
   NS_DECL_NSIOBSERVER
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSICAPTIVEPORTALCALLBACK
+  NS_DECL_NSINAMED
 
   CaptivePortalService();
   nsresult Initialize();
   nsresult Start();
   nsresult Stop();
 
   // This method is only called in the content process, in order to mirror
   // the captive portal state in the parent process.
diff --git a/netwerk/base/Dashboard.cpp b/netwerk/base/Dashboard.cpp
--- a/netwerk/base/Dashboard.cpp
+++ b/netwerk/base/Dashboard.cpp
@@ -7,16 +7,17 @@
 #include "mozilla/ErrorNames.h"
 #include "mozilla/net/Dashboard.h"
 #include "mozilla/net/HttpInfo.h"
 #include "nsHttp.h"
 #include "nsICancelable.h"
 #include "nsIDNSService.h"
 #include "nsIDNSRecord.h"
 #include "nsIInputStream.h"
+#include "nsINamed.h"
 #include "nsISocketTransport.h"
 #include "nsIThread.h"
 #include "nsProxyRelease.h"
 #include "nsSocketTransportService2.h"
 #include "nsThreadUtils.h"
 #include "nsURLHelper.h"
 #include "mozilla/Logging.h"
 #include "nsIOService.h"
@@ -125,29 +126,37 @@ public:
 };
 
 NS_IMPL_ISUPPORTS0(DnsData)
 
 
 class ConnectionData
     : public nsITransportEventSink
     , public nsITimerCallback
+    , public nsINamed
 {
     virtual ~ConnectionData()
     {
         if (mTimer) {
             mTimer->Cancel();
         }
     }
 
 public:
     NS_DECL_THREADSAFE_ISUPPORTS
     NS_DECL_NSITRANSPORTEVENTSINK
     NS_DECL_NSITIMERCALLBACK
 
+    NS_IMETHOD GetName(nsACString& aName) override
+    {
+      aName.AssignLiteral("net::ConnectionData");
+      return NS_OK;
+    }
+
+
     void StartTimer(uint32_t aTimeout);
     void StopTimer();
 
     explicit ConnectionData(Dashboard *target)
     {
         mEventTarget = nullptr;
         mDashboard = target;
     }
@@ -162,17 +171,17 @@ public:
     nsCString mHost;
     uint32_t mPort;
     const char *mProtocol;
     uint32_t mTimeout;
 
     nsString mStatus;
 };
 
-NS_IMPL_ISUPPORTS(ConnectionData, nsITransportEventSink, nsITimerCallback)
+NS_IMPL_ISUPPORTS(ConnectionData, nsITransportEventSink, nsITimerCallback, nsINamed)
 
 
 class RcwnData
     : public nsISupports
 {
     virtual ~RcwnData()
     {
     }
diff --git a/netwerk/base/EventTokenBucket.cpp b/netwerk/base/EventTokenBucket.cpp
--- a/netwerk/base/EventTokenBucket.cpp
+++ b/netwerk/base/EventTokenBucket.cpp
@@ -69,17 +69,17 @@ TokenBucketCancelable::Fire()
   mEvent = nullptr;
   event->OnTokenBucketAdmitted();
 }
 
 ////////////////////////////////////////////
 // EventTokenBucket
 ////////////////////////////////////////////
 
-NS_IMPL_ISUPPORTS(EventTokenBucket, nsITimerCallback)
+NS_IMPL_ISUPPORTS(EventTokenBucket, nsITimerCallback, nsINamed)
 
 // by default 1hz with no burst
 EventTokenBucket::EventTokenBucket(uint32_t eventsPerSecond,
                                    uint32_t burstSize)
   : mUnitCost(kUsecPerSec)
   , mMaxCredit(kUsecPerSec)
   , mCredit(kUsecPerSec)
   , mPaused(false)
@@ -352,16 +352,23 @@ EventTokenBucket::Notify(nsITimer *timer
 
   UpdateCredits();
   DispatchEvents();
   UpdateTimer();
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+EventTokenBucket::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("EventTokenBucket");
+  return NS_OK;
+}
+
 void
 EventTokenBucket::UpdateCredits()
 {
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
 
   TimeStamp now = TimeStamp::Now();
   TimeDuration elapsed = now - mLastUpdate;
   mLastUpdate = now;
diff --git a/netwerk/base/EventTokenBucket.h b/netwerk/base/EventTokenBucket.h
--- a/netwerk/base/EventTokenBucket.h
+++ b/netwerk/base/EventTokenBucket.h
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef NetEventTokenBucket_h__
 #define NetEventTokenBucket_h__
 
 #include "ARefBase.h"
 #include "nsCOMPtr.h"
 #include "nsDeque.h"
+#include "nsINamed.h"
 #include "nsITimer.h"
 
 #include "mozilla/TimeStamp.h"
 
 class nsICancelable;
 
 namespace mozilla {
 namespace net {
@@ -63,21 +64,24 @@ class EventTokenBucket;
 class ATokenBucketEvent
 {
 public:
   virtual void OnTokenBucketAdmitted() = 0;
 };
 
 class TokenBucketCancelable;
 
-class EventTokenBucket : public nsITimerCallback, public ARefBase
+class EventTokenBucket : public nsITimerCallback
+                       , public nsINamed
+                       , public ARefBase
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   // This should be constructed on the main thread
   EventTokenBucket(uint32_t eventsPerSecond, uint32_t burstSize);
 
   // These public methods are all meant to be called from the socket thread
   void ClearCredits();
   uint32_t BurstEventsAvailable();
   uint32_t QueuedEvents();
diff --git a/netwerk/base/Predictor.cpp b/netwerk/base/Predictor.cpp
--- a/netwerk/base/Predictor.cpp
+++ b/netwerk/base/Predictor.cpp
@@ -1546,19 +1546,17 @@ Predictor::LearnNative(nsIURI *targetURI
 
   if (IsNeckoChild()) {
     MOZ_DIAGNOSTIC_ASSERT(gNeckoChild);
 
     PREDICTOR_LOG(("    called on child process"));
 
     RefPtr<PredictorLearnRunnable> runnable = new PredictorLearnRunnable(
       targetURI, sourceURI, reason, originAttributes);
-    SystemGroup::Dispatch("PredictorLearnRunnable",
-                          TaskCategory::Other,
-                          runnable.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, runnable.forget());
 
     return NS_OK;
   }
 
   PREDICTOR_LOG(("    called on parent process"));
 
   if (!mInitialized) {
     PREDICTOR_LOG(("    not initialized"));
diff --git a/netwerk/base/ProxyAutoConfig.cpp b/netwerk/base/ProxyAutoConfig.cpp
--- a/netwerk/base/ProxyAutoConfig.cpp
+++ b/netwerk/base/ProxyAutoConfig.cpp
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ProxyAutoConfig.h"
 #include "nsICancelable.h"
 #include "nsIDNSListener.h"
 #include "nsIDNSRecord.h"
 #include "nsIDNSService.h"
+#include "nsINamed.h"
 #include "nsThreadUtils.h"
 #include "nsIConsoleService.h"
 #include "nsIURLParser.h"
 #include "nsJSUtils.h"
 #include "jsfriendapi.h"
 #include "prnetdb.h"
 #include "nsITimer.h"
 #include "mozilla/net/DNS.h"
@@ -271,16 +272,17 @@ static void SetRunning(ProxyAutoConfig *
 {
   MOZ_ASSERT(sRunningIndex != 0xdeadbeef);
   PR_SetThreadPrivate(sRunningIndex, arg);
 }
 
 // The PACResolver is used for dnsResolve()
 class PACResolver final : public nsIDNSListener
                         , public nsITimerCallback
+                        , public nsINamed
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
 
   explicit PACResolver(nsIEventTarget *aTarget)
     : mStatus(NS_ERROR_FAILURE)
     , mMainThreadEventTarget(aTarget)
   {
@@ -306,26 +308,33 @@ public:
   NS_IMETHOD Notify(nsITimer *timer) override
   {
     if (mRequest)
       mRequest->Cancel(NS_ERROR_NET_TIMEOUT);
     mTimer = nullptr;
     return NS_OK;
   }
 
+  // nsINamed
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("PACResolver");
+    return NS_OK;
+  }
+
   nsresult                 mStatus;
   nsCOMPtr<nsICancelable>  mRequest;
   nsCOMPtr<nsIDNSRecord>   mResponse;
   nsCOMPtr<nsITimer>       mTimer;
   nsCOMPtr<nsIEventTarget> mMainThreadEventTarget;
 
 private:
   ~PACResolver() {}
 };
-NS_IMPL_ISUPPORTS(PACResolver, nsIDNSListener, nsITimerCallback)
+NS_IMPL_ISUPPORTS(PACResolver, nsIDNSListener, nsITimerCallback, nsINamed)
 
 static
 void PACLogToConsole(nsString &aMessage)
 {
   nsCOMPtr<nsIConsoleService> consoleService =
     do_GetService(NS_CONSOLESERVICE_CONTRACTID);
   if (!consoleService)
     return;
diff --git a/netwerk/base/ThrottleQueue.cpp b/netwerk/base/ThrottleQueue.cpp
--- a/netwerk/base/ThrottleQueue.cpp
+++ b/netwerk/base/ThrottleQueue.cpp
@@ -230,17 +230,17 @@ ThrottleInputStream::AllowInput()
                                 mCallback, mEventTarget);
   mCallback = nullptr;
   mEventTarget = nullptr;
   callbackEvent->OnInputStreamReady(this);
 }
 
 //-----------------------------------------------------------------------------
 
-NS_IMPL_ISUPPORTS(ThrottleQueue, nsIInputChannelThrottleQueue, nsITimerCallback)
+NS_IMPL_ISUPPORTS(ThrottleQueue, nsIInputChannelThrottleQueue, nsITimerCallback, nsINamed)
 
 ThrottleQueue::ThrottleQueue()
   : mMeanBytesPerSecond(0)
   , mMaxBytesPerSecond(0)
   , mBytesProcessed(0)
   , mTimerArmed(false)
 {
   nsresult rv;
@@ -350,16 +350,23 @@ ThrottleQueue::Notify(nsITimer* aTimer)
   for (size_t i = 0; i < events.Length(); ++i) {
     events[i]->AllowInput();
   }
 
   mTimerArmed = false;
   return NS_OK;
 }
 
+NS_IMETHODIMP
+ThrottleQueue::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("net::ThrottleQueue");
+  return NS_OK;
+}
+
 void
 ThrottleQueue::QueueStream(ThrottleInputStream* aStream)
 {
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
   if (mAsyncEvents.IndexOf(aStream) == mAsyncEvents.NoIndex) {
     mAsyncEvents.AppendElement(aStream);
 
     if (!mTimerArmed) {
diff --git a/netwerk/base/ThrottleQueue.h b/netwerk/base/ThrottleQueue.h
--- a/netwerk/base/ThrottleQueue.h
+++ b/netwerk/base/ThrottleQueue.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_net_ThrottleQueue_h
 #define mozilla_net_ThrottleQueue_h
 
 #include "mozilla/TimeStamp.h"
+#include "nsINamed.h"
 #include "nsIThrottledInputChannel.h"
 #include "nsITimer.h"
 
 namespace mozilla {
 namespace net {
 
 class ThrottleInputStream;
 
@@ -23,24 +24,26 @@ class ThrottleInputStream;
  * but otherwise, after creation, it can only be used on the socket
  * thread.  It currently throttles with a one second granularity, so
  * may be a bit choppy.
  */
 
 class ThrottleQueue final
   : public nsIInputChannelThrottleQueue
   , public nsITimerCallback
+  , public nsINamed
 {
 public:
 
   ThrottleQueue();
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTCHANNELTHROTTLEQUEUE
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   void QueueStream(ThrottleInputStream* aStream);
   void DequeueStream(ThrottleInputStream* aStream);
 
 private:
 
   ~ThrottleQueue();
 
diff --git a/netwerk/base/Tickler.cpp b/netwerk/base/Tickler.cpp
--- a/netwerk/base/Tickler.cpp
+++ b/netwerk/base/Tickler.cpp
@@ -2,16 +2,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "Tickler.h"
 
 #ifdef MOZ_USE_WIFI_TICKLER
 #include "nsComponentManagerUtils.h"
+#include "nsINamed.h"
 #include "nsIPrefBranch.h"
 #include "nsIPrefService.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 #include "prnetdb.h"
 
 #include "mozilla/jni/Utils.h"
 #include "GeneratedJNIWrappers.h"
@@ -191,26 +192,33 @@ void Tickler::StopTickler()
   MOZ_ASSERT(mThread == NS_GetCurrentThread());
   MOZ_ASSERT(mTimer);
   MOZ_ASSERT(mActive);
 
   mTimer->Cancel();
   mActive = false;
 }
 
-class TicklerTimer final : public nsITimerCallback
+class TicklerTimer final : public nsITimerCallback, public nsINamed
 {
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
 
   TicklerTimer(Tickler *aTickler)
   {
     mTickler = do_GetWeakReference(aTickler);
   }
 
+  // nsINamed
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("TicklerTimer");
+    return NS_OK;
+  }
+
 private:
   ~TicklerTimer() {}
 
   nsWeakPtr mTickler;
 };
 
 void Tickler::StartTickler()
 {
@@ -232,17 +240,17 @@ void Tickler::SetIPV4Address(uint32_t ad
 }
 
 // argument should be in network byte order
 void Tickler::SetIPV4Port(uint16_t port)
 {
   mAddr.inet.port = port;
 }
 
-NS_IMPL_ISUPPORTS(TicklerTimer, nsITimerCallback)
+NS_IMPL_ISUPPORTS(TicklerTimer, nsITimerCallback, nsINamed)
 
 NS_IMETHODIMP TicklerTimer::Notify(nsITimer *timer)
 {
   RefPtr<Tickler> tickler = do_QueryReferent(mTickler);
   if (!tickler)
     return NS_ERROR_FAILURE;
   MutexAutoLock lock(tickler->mLock);
 
diff --git a/netwerk/base/nsAsyncRedirectVerifyHelper.cpp b/netwerk/base/nsAsyncRedirectVerifyHelper.cpp
--- a/netwerk/base/nsAsyncRedirectVerifyHelper.cpp
+++ b/netwerk/base/nsAsyncRedirectVerifyHelper.cpp
@@ -236,22 +236,16 @@ nsAsyncRedirectVerifyHelper::InitCallbac
 NS_IMETHODIMP
 nsAsyncRedirectVerifyHelper::GetName(nsACString& aName)
 {
     aName.AssignASCII("nsAsyncRedirectVerifyHelper");
     return NS_OK;
 }
 
 NS_IMETHODIMP
-nsAsyncRedirectVerifyHelper::SetName(const char* aName)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
 nsAsyncRedirectVerifyHelper::Run()
 {
     /* If the channel got canceled after it fired AsyncOnChannelRedirect
      * and before we got here, mostly because docloader load has been canceled,
      * we must completely ignore this notification and prevent any further
      * notification.
      */
     if (IsOldChannelCanceled()) {
diff --git a/netwerk/base/nsInputStreamPump.cpp b/netwerk/base/nsInputStreamPump.cpp
--- a/netwerk/base/nsInputStreamPump.cpp
+++ b/netwerk/base/nsInputStreamPump.cpp
@@ -39,17 +39,17 @@ nsInputStreamPump::nsInputStreamPump()
     , mStreamLength(UINT64_MAX)
     , mStatus(NS_OK)
     , mSuspendCount(0)
     , mLoadFlags(LOAD_NORMAL)
     , mProcessingCallbacks(false)
     , mWaitingForInputStreamReady(false)
     , mCloseWhenDone(false)
     , mRetargeting(false)
-    , mMonitor("nsInputStreamPump")
+    , mMutex("nsInputStreamPump")
 {
 }
 
 nsInputStreamPump::~nsInputStreamPump()
 {
 }
 
 nsresult
@@ -94,17 +94,17 @@ CallPeekFunc(nsIInputStream *aInStream, 
   data->mFunc(data->mClosure,
               reinterpret_cast<const uint8_t*>(aFromSegment), aCount);
   return NS_BINDING_ABORTED;
 }
 
 nsresult
 nsInputStreamPump::PeekStream(PeekSegmentFun callback, void* closure)
 {
-  ReentrantMonitorAutoEnter mon(mMonitor);
+  RecursiveMutexAutoLock lock(mMutex);
 
   NS_ASSERTION(mAsyncStream, "PeekStream called without stream");
 
   nsresult rv = CreateBufferedStreamIfNeeded();
   NS_ENSURE_SUCCESS(rv, rv);
 
   // See if the pipe is closed by checking the return of Available.
   uint64_t dummy64;
@@ -118,17 +118,17 @@ nsInputStreamPump::PeekStream(PeekSegmen
                                        &data,
                                        nsIOService::gDefaultSegmentSize,
                                        &dummy);
 }
 
 nsresult
 nsInputStreamPump::EnsureWaiting()
 {
-    mMonitor.AssertCurrentThreadIn();
+    mMutex.AssertCurrentThreadIn();
 
     // no need to worry about multiple threads... an input stream pump lives
     // on only one thread at a time.
     MOZ_ASSERT(mAsyncStream);
     if (!mWaitingForInputStreamReady && !mProcessingCallbacks) {
         // Ensure OnStateStop is called on the main thread.
         if (mState == STATE_STOP) {
             nsCOMPtr<nsIEventTarget> mainThread = mLabeledMainThreadTarget
@@ -167,46 +167,46 @@ NS_IMPL_ISUPPORTS(nsInputStreamPump,
 
 //-----------------------------------------------------------------------------
 // nsInputStreamPump::nsIRequest
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 nsInputStreamPump::GetName(nsACString &result)
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     result.Truncate();
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::IsPending(bool *result)
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     *result = (mState != STATE_IDLE);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::GetStatus(nsresult *status)
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     *status = mStatus;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::Cancel(nsresult status)
 {
     MOZ_ASSERT(NS_IsMainThread());
 
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     LOG(("nsInputStreamPump::Cancel [this=%p status=%" PRIx32 "]\n",
         this, static_cast<uint32_t>(status)));
 
     if (NS_FAILED(mStatus)) {
         LOG(("  already canceled\n"));
         return NS_OK;
     }
@@ -225,72 +225,72 @@ nsInputStreamPump::Cancel(nsresult statu
         // on a closed stream works and will dispatch an event immediately.
     }
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::Suspend()
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     LOG(("nsInputStreamPump::Suspend [this=%p]\n", this));
     NS_ENSURE_TRUE(mState != STATE_IDLE, NS_ERROR_UNEXPECTED);
     ++mSuspendCount;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::Resume()
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     LOG(("nsInputStreamPump::Resume [this=%p]\n", this));
     NS_ENSURE_TRUE(mSuspendCount > 0, NS_ERROR_UNEXPECTED);
     NS_ENSURE_TRUE(mState != STATE_IDLE, NS_ERROR_UNEXPECTED);
 
     // There is a brief in-between state when we null out mAsyncStream in
     // OnStateStop() before calling OnStopRequest, and only afterwards set
     // STATE_IDLE, which we need to handle gracefully.
     if (--mSuspendCount == 0 && mAsyncStream)
         EnsureWaiting();
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::GetLoadFlags(nsLoadFlags *aLoadFlags)
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     *aLoadFlags = mLoadFlags;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::SetLoadFlags(nsLoadFlags aLoadFlags)
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     mLoadFlags = aLoadFlags;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::GetLoadGroup(nsILoadGroup **aLoadGroup)
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     NS_IF_ADDREF(*aLoadGroup = mLoadGroup);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::SetLoadGroup(nsILoadGroup *aLoadGroup)
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     mLoadGroup = aLoadGroup;
     return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // nsInputStreamPump::nsIInputStreamPump implementation
 //-----------------------------------------------------------------------------
@@ -313,17 +313,17 @@ nsInputStreamPump::Init(nsIInputStream *
     mLabeledMainThreadTarget = mainThreadTarget;
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsInputStreamPump::AsyncRead(nsIStreamListener *listener, nsISupports *ctxt)
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     NS_ENSURE_TRUE(mState == STATE_IDLE, NS_ERROR_IN_PROGRESS);
     NS_ENSURE_ARG_POINTER(listener);
     MOZ_ASSERT(NS_IsMainThread(), "nsInputStreamPump should be read from the "
                                   "main thread only.");
 
     //
     // OK, we need to use the stream transport service if
@@ -412,22 +412,22 @@ nsInputStreamPump::OnInputStreamReady(ns
 
     // this function has been called from a PLEvent, so we can safely call
     // any listener or progress sink methods directly from here.
 
     for (;;) {
         // There should only be one iteration of this loop happening at a time.
         // To prevent AsyncWait() (called during callbacks or on other threads)
         // from creating a parallel OnInputStreamReady(), we use:
-        // -- a monitor; and
+        // -- a mutex; and
         // -- a boolean mProcessingCallbacks to detect parallel loops
-        //    when exiting the monitor for callbacks.
-        ReentrantMonitorAutoEnter lock(mMonitor);
+        //    when exiting the mutex for callbacks.
+        RecursiveMutexAutoLock lock(mMutex);
 
-        // Prevent parallel execution during callbacks, while out of monitor.
+        // Prevent parallel execution during callbacks, while out of mutex.
         if (mProcessingCallbacks) {
             MOZ_ASSERT(!mProcessingCallbacks);
             break;
         }
         mProcessingCallbacks = true;
         if (mSuspendCount || mState == STATE_IDLE) {
             mWaitingForInputStreamReady = false;
             mProcessingCallbacks = false;
@@ -506,17 +506,17 @@ nsInputStreamPump::OnInputStreamReady(ns
         mState = nextState;
     }
     return NS_OK;
 }
 
 uint32_t
 nsInputStreamPump::OnStateStart()
 {
-    mMonitor.AssertCurrentThreadIn();
+    mMutex.AssertCurrentThreadIn();
 
     AUTO_PROFILER_LABEL("nsInputStreamPump::OnStateStart", NETWORK);
 
     LOG(("  OnStateStart [this=%p]\n", this));
 
     nsresult rv;
 
     // need to check the reason why the stream is ready.  this is required
@@ -525,36 +525,35 @@ nsInputStreamPump::OnStateStart()
     if (NS_SUCCEEDED(mStatus)) {
         uint64_t avail;
         rv = mAsyncStream->Available(&avail);
         if (NS_FAILED(rv) && rv != NS_BASE_STREAM_CLOSED)
             mStatus = rv;
     }
 
     {
-        // Note: Must exit monitor for call to OnStartRequest to avoid
+        // Note: Must exit mutex for call to OnStartRequest to avoid
         // deadlocks when calls to RetargetDeliveryTo for multiple
         // nsInputStreamPumps are needed (e.g. nsHttpChannel).
-        mMonitor.Exit();
+        RecursiveMutexAutoUnlock unlock(mMutex);
         rv = mListener->OnStartRequest(this, mListenerContext);
-        mMonitor.Enter();
     }
 
     // an error returned from OnStartRequest should cause us to abort; however,
     // we must not stomp on mStatus if already canceled.
     if (NS_FAILED(rv) && NS_SUCCEEDED(mStatus))
         mStatus = rv;
 
     return NS_SUCCEEDED(mStatus) ? STATE_TRANSFER : STATE_STOP;
 }
 
 uint32_t
 nsInputStreamPump::OnStateTransfer()
 {
-    mMonitor.AssertCurrentThreadIn();
+    mMutex.AssertCurrentThreadIn();
 
     AUTO_PROFILER_LABEL("nsInputStreamPump::OnStateTransfer", NETWORK);
 
     LOG(("  OnStateTransfer [this=%p]\n", this));
 
     // if canceled, go directly to STATE_STOP...
     if (NS_FAILED(mStatus))
         return STATE_STOP;
@@ -604,24 +603,23 @@ nsInputStreamPump::OnStateTransfer()
             uint32_t odaAvail =
                 avail > UINT32_MAX ?
                 UINT32_MAX : uint32_t(avail);
 
             LOG(("  calling OnDataAvailable [offset=%" PRIu64 " count=%" PRIu64 "(%u)]\n",
                 mStreamOffset, avail, odaAvail));
 
             {
-                // Note: Must exit monitor for call to OnStartRequest to avoid
+                // Note: Must exit mutex for call to OnStartRequest to avoid
                 // deadlocks when calls to RetargetDeliveryTo for multiple
                 // nsInputStreamPumps are needed (e.g. nsHttpChannel).
-                mMonitor.Exit();
+                RecursiveMutexAutoUnlock unlock(mMutex);
                 rv = mListener->OnDataAvailable(this, mListenerContext,
                                                 mBufferedStream, mStreamOffset,
                                                 odaAvail);
-                mMonitor.Enter();
             }
 
             // don't enter this code if ODA failed or called Cancel
             if (NS_SUCCEEDED(rv) && NS_SUCCEEDED(mStatus)) {
                 // test to see if this ODA failed to consume data
                 if (seekable) {
                     // NOTE: if Tell fails, which can happen if the stream is
                     // now closed, then we assume that everything was read.
@@ -667,29 +665,29 @@ nsInputStreamPump::OnStateTransfer()
         }
     }
     return STATE_STOP;
 }
 
 nsresult
 nsInputStreamPump::CallOnStateStop()
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     MOZ_ASSERT(NS_IsMainThread(),
                "CallOnStateStop should only be called on the main thread.");
 
     mState = OnStateStop();
     return NS_OK;
 }
 
 uint32_t
 nsInputStreamPump::OnStateStop()
 {
-    mMonitor.AssertCurrentThreadIn();
+    mMutex.AssertCurrentThreadIn();
 
     if (!NS_IsMainThread()) {
         // Hopefully temporary hack: OnStateStop should only run on the main
         // thread, but we're seeing some rare off-main-thread calls. For now
         // just redispatch to the main thread in release builds, and crash in
         // debug builds.
         MOZ_ASSERT(NS_IsMainThread(),
                    "OnStateStop should only be called on the main thread.");
@@ -720,22 +718,21 @@ nsInputStreamPump::OnStateStop()
     else if (mCloseWhenDone)
         mAsyncStream->Close();
 
     mAsyncStream = nullptr;
     mBufferedStream = nullptr;
     mTargetThread = nullptr;
     mIsPending = false;
     {
-        // Note: Must exit monitor for call to OnStartRequest to avoid
+        // Note: Must exit mutex for call to OnStartRequest to avoid
         // deadlocks when calls to RetargetDeliveryTo for multiple
         // nsInputStreamPumps are needed (e.g. nsHttpChannel).
-        mMonitor.Exit();
+        RecursiveMutexAutoUnlock unlock(mMutex);
         mListener->OnStopRequest(this, mListenerContext, mStatus);
-        mMonitor.Enter();
     }
     mListener = nullptr;
     mListenerContext = nullptr;
 
     if (mLoadGroup)
         mLoadGroup->RemoveRequest(this, nullptr, mStatus);
 
     return STATE_IDLE;
@@ -765,17 +762,17 @@ nsInputStreamPump::CreateBufferedStreamI
 
 //-----------------------------------------------------------------------------
 // nsIThreadRetargetableRequest
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 nsInputStreamPump::RetargetDeliveryTo(nsIEventTarget* aNewTarget)
 {
-    ReentrantMonitorAutoEnter mon(mMonitor);
+    RecursiveMutexAutoLock lock(mMutex);
 
     NS_ENSURE_ARG(aNewTarget);
     NS_ENSURE_TRUE(mState == STATE_START || mState == STATE_TRANSFER,
                    NS_ERROR_UNEXPECTED);
 
     // If canceled, do not retarget. Return with canceled status.
     if (NS_FAILED(mStatus)) {
         return mStatus;
diff --git a/netwerk/base/nsInputStreamPump.h b/netwerk/base/nsInputStreamPump.h
--- a/netwerk/base/nsInputStreamPump.h
+++ b/netwerk/base/nsInputStreamPump.h
@@ -6,30 +6,31 @@
 #ifndef nsInputStreamPump_h__
 #define nsInputStreamPump_h__
 
 #include "nsIInputStreamPump.h"
 #include "nsIAsyncInputStream.h"
 #include "nsIThreadRetargetableRequest.h"
 #include "nsCOMPtr.h"
 #include "mozilla/Attributes.h"
-#include "mozilla/ReentrantMonitor.h"
+#include "mozilla/RecursiveMutex.h"
 
 class nsIInputStream;
 class nsILoadGroup;
 class nsIStreamListener;
 
 class nsInputStreamPump final : public nsIInputStreamPump
                               , public nsIInputStreamCallback
                               , public nsIThreadRetargetableRequest
 {
     ~nsInputStreamPump();
 
 public:
-    typedef mozilla::ReentrantMonitorAutoEnter ReentrantMonitorAutoEnter;
+    typedef mozilla::RecursiveMutexAutoLock RecursiveMutexAutoLock;
+    typedef mozilla::RecursiveMutexAutoUnlock RecursiveMutexAutoUnlock;
     NS_DECL_THREADSAFE_ISUPPORTS
     NS_DECL_NSIREQUEST
     NS_DECL_NSIINPUTSTREAMPUMP
     NS_DECL_NSIINPUTSTREAMCALLBACK
     NS_DECL_NSITHREADRETARGETABLEREQUEST
 
     nsInputStreamPump();
 
@@ -98,12 +99,12 @@ protected:
     // True while in OnInputStreamReady, calling OnStateStart, OnStateTransfer
     // and OnStateStop. Used to prevent calls to AsyncWait during callbacks.
     bool                          mProcessingCallbacks;
     // True if waiting on the "input stream ready" callback.
     bool                          mWaitingForInputStreamReady;
     bool                          mCloseWhenDone;
     bool                          mRetargeting;
     // Protects state/member var accesses across multiple threads.
-    mozilla::ReentrantMonitor     mMonitor;
+    mozilla::RecursiveMutex       mMutex;
 };
 
 #endif // !nsInputStreamChannel_h__
diff --git a/netwerk/cache/nsCacheService.cpp b/netwerk/cache/nsCacheService.cpp
--- a/netwerk/cache/nsCacheService.cpp
+++ b/netwerk/cache/nsCacheService.cpp
@@ -18,17 +18,17 @@
 #include "nsCacheEntryDescriptor.h"
 #include "nsCacheDevice.h"
 #include "nsMemoryCacheDevice.h"
 #include "nsICacheVisitor.h"
 #include "nsDiskCacheDevice.h"
 #include "nsDiskCacheDeviceSQL.h"
 #include "nsCacheUtils.h"
 #include "../cache2/CacheObserver.h"
-
+#include "nsINamed.h"
 #include "nsIObserverService.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 #include "nsIFile.h"
 #include "nsIOService.h"
 #include "nsDirectoryServiceDefs.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsThreadUtils.h"
@@ -198,33 +198,39 @@ private:
 
     bool                    mSanitizeOnShutdown;
     bool                    mClearCacheOnShutdown;
 };
 
 NS_IMPL_ISUPPORTS(nsCacheProfilePrefObserver, nsIObserver)
 
 class nsSetDiskSmartSizeCallback final : public nsITimerCallback
+                                       , public nsINamed
 {
     ~nsSetDiskSmartSizeCallback() {}
 
 public:
     NS_DECL_THREADSAFE_ISUPPORTS
 
     NS_IMETHOD Notify(nsITimer* aTimer) override {
         if (nsCacheService::gService) {
             nsCacheServiceAutoLock autoLock(LOCK_TELEM(NSSETDISKSMARTSIZECALLBACK_NOTIFY));
             nsCacheService::gService->SetDiskSmartSize_Locked();
             nsCacheService::gService->mSmartSizeTimer = nullptr;
         }
         return NS_OK;
     }
+
+    NS_IMETHOD GetName(nsACString& aName) override {
+      aName.AssignLiteral("nsSetDiskSmartSizeCallback");
+      return NS_OK;
+    }
 };
 
-NS_IMPL_ISUPPORTS(nsSetDiskSmartSizeCallback, nsITimerCallback)
+NS_IMPL_ISUPPORTS(nsSetDiskSmartSizeCallback, nsITimerCallback, nsINamed)
 
 // Runnable sent to main thread after the cache IO thread calculates available
 // disk space, so that there is no race in setting mDiskCacheCapacity.
 class nsSetSmartSizeEvent: public Runnable
 {
 public:
   explicit nsSetSmartSizeEvent(int32_t smartSize)
     : mozilla::Runnable("nsSetSmartSizeEvent")
diff --git a/netwerk/cache2/CacheFileIOManager.cpp b/netwerk/cache2/CacheFileIOManager.cpp
--- a/netwerk/cache2/CacheFileIOManager.cpp
+++ b/netwerk/cache2/CacheFileIOManager.cpp
@@ -1187,17 +1187,17 @@ public:
       break;
     }
     return NS_OK;
   }
 };
 
 StaticRefPtr<CacheFileIOManager> CacheFileIOManager::gInstance;
 
-NS_IMPL_ISUPPORTS(CacheFileIOManager, nsITimerCallback)
+NS_IMPL_ISUPPORTS(CacheFileIOManager, nsITimerCallback, nsINamed)
 
 CacheFileIOManager::CacheFileIOManager()
   : mShuttingDown(false)
   , mTreeCreated(false)
   , mTreeCreationFailed(false)
   , mOverLimitEvicting(false)
   , mCacheSizeOnHardLimit(false)
   , mRemovingTrashDirs(false)
@@ -1621,16 +1621,23 @@ CacheFileIOManager::Notify(nsITimer * aT
   for (uint32_t i = 0; i < files.Length(); ++i) {
     CacheFile * file = files[i];
     file->WriteMetadataIfNeeded();
   }
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+CacheFileIOManager::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("CacheFileIOManager");
+  return NS_OK;
+}
+
 // static
 nsresult
 CacheFileIOManager::OpenFile(const nsACString &aKey,
                              uint32_t aFlags, CacheFileIOListener *aCallback)
 {
   LOG(("CacheFileIOManager::OpenFile() [key=%s, flags=%d, listener=%p]",
        PromiseFlatCString(aKey).get(), aFlags, aCallback));
 
diff --git a/netwerk/cache2/CacheFileIOManager.h b/netwerk/cache2/CacheFileIOManager.h
--- a/netwerk/cache2/CacheFileIOManager.h
+++ b/netwerk/cache2/CacheFileIOManager.h
@@ -4,16 +4,17 @@
 
 #ifndef CacheFileIOManager__h__
 #define CacheFileIOManager__h__
 
 #include "CacheIOThread.h"
 #include "CacheStorageService.h"
 #include "CacheHashUtils.h"
 #include "nsIEventTarget.h"
+#include "nsINamed.h"
 #include "nsITimer.h"
 #include "nsCOMPtr.h"
 #include "mozilla/Atomics.h"
 #include "mozilla/SHA1.h"
 #include "mozilla/StaticPtr.h"
 #include "mozilla/TimeStamp.h"
 #include "nsTArray.h"
 #include "nsString.h"
@@ -254,20 +255,22 @@ public:
 
   virtual bool IsKilled() { return false; }
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(CacheFileIOListener, CACHEFILEIOLISTENER_IID)
 
 
 class CacheFileIOManager : public nsITimerCallback
+                         , public nsINamed
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   enum {
     OPEN         =  0U,
     CREATE       =  1U,
     CREATE_NEW   =  2U,
     PRIORITY     =  4U,
     SPECIAL_FILE =  8U,
     PINNED       = 16U
diff --git a/netwerk/cache2/CacheStorageService.cpp b/netwerk/cache2/CacheStorageService.cpp
--- a/netwerk/cache2/CacheStorageService.cpp
+++ b/netwerk/cache2/CacheStorageService.cpp
@@ -102,17 +102,18 @@ CacheStorageService::MemoryPool::Limit()
   MOZ_CRASH("Bad pool type");
   return 0;
 }
 
 NS_IMPL_ISUPPORTS(CacheStorageService,
                   nsICacheStorageService,
                   nsIMemoryReporter,
                   nsITimerCallback,
-                  nsICacheTesting)
+                  nsICacheTesting,
+                  nsINamed)
 
 CacheStorageService* CacheStorageService::sSelf = nullptr;
 
 CacheStorageService::CacheStorageService()
 : mLock("CacheStorageService.mLock")
 , mForcedValidEntriesLock("CacheStorageService.mForcedValidEntriesLock")
 , mShutdown(false)
 , mDiskPool(MemoryPool::DISK)
@@ -1331,16 +1332,23 @@ CacheStorageService::Notify(nsITimer* aT
                         this,
                         &CacheStorageService::PurgeOverMemoryLimit);
     Dispatch(event);
   }
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+CacheStorageService::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("CacheStorageService");
+  return NS_OK;
+}
+
 void
 CacheStorageService::PurgeOverMemoryLimit()
 {
   MOZ_ASSERT(IsOnManagementThread());
 
   LOG(("CacheStorageService::PurgeOverMemoryLimit"));
 
   static TimeDuration const kFourSeconds = TimeDuration::FromSeconds(4);
diff --git a/netwerk/cache2/CacheStorageService.h b/netwerk/cache2/CacheStorageService.h
--- a/netwerk/cache2/CacheStorageService.h
+++ b/netwerk/cache2/CacheStorageService.h
@@ -2,16 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef CacheStorageService__h__
 #define CacheStorageService__h__
 
 #include "nsICacheStorageService.h"
 #include "nsIMemoryReporter.h"
+#include "nsINamed.h"
 #include "nsITimer.h"
 #include "nsICacheTesting.h"
 
 #include "nsClassHashtable.h"
 #include "nsDataHashtable.h"
 #include "nsString.h"
 #include "nsThreadUtils.h"
 #include "nsProxyRelease.h"
@@ -63,23 +64,25 @@ protected:
   ~CacheMemoryConsumer() { DoMemoryReport(0); }
   void DoMemoryReport(uint32_t aCurrentSize);
 };
 
 class CacheStorageService final : public nsICacheStorageService
                                 , public nsIMemoryReporter
                                 , public nsITimerCallback
                                 , public nsICacheTesting
+                                , public nsINamed
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSICACHESTORAGESERVICE
   NS_DECL_NSIMEMORYREPORTER
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSICACHETESTING
+  NS_DECL_NSINAMED
 
   CacheStorageService();
 
   void Shutdown();
   void DropPrivateBrowsingEntries();
 
   // Takes care of deleting any pending trashes for both cache1 and cache2
   // as well as the cache directory of an inactive cache version when requested.
diff --git a/netwerk/dns/DNSRequestChild.cpp b/netwerk/dns/DNSRequestChild.cpp
--- a/netwerk/dns/DNSRequestChild.cpp
+++ b/netwerk/dns/DNSRequestChild.cpp
@@ -209,17 +209,16 @@ DNSRequestChild::DNSRequestChild(const n
 }
 
 void
 DNSRequestChild::StartRequest()
 {
   // we can only do IPDL on the main thread
   if (!NS_IsMainThread()) {
     SystemGroup::Dispatch(
-      "StartDNSRequestChild",
       TaskCategory::Other,
       NewRunnableMethod("net::DNSRequestChild::StartRequest",
                         this,
                         &DNSRequestChild::StartRequest));
     return;
   }
 
   nsCOMPtr<nsIEventTarget> systemGroupEventTarget
@@ -322,18 +321,16 @@ NS_IMPL_ISUPPORTS(DNSRequestChild,
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 DNSRequestChild::Cancel(nsresult reason)
 {
   if(mIPCOpen) {
     // We can only do IPDL on the main thread
     nsCOMPtr<nsIRunnable> runnable = new CancelDNSRequestEvent(this, reason);
-    SystemGroup::Dispatch("CancelDNSRequest",
-                          TaskCategory::Other,
-                          runnable.forget());
+    SystemGroup::Dispatch(TaskCategory::Other, runnable.forget());
   }
   return NS_OK;
 }
 
 //------------------------------------------------------------------------------
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/ipc/ChannelEventQueue.h b/netwerk/ipc/ChannelEventQueue.h
--- a/netwerk/ipc/ChannelEventQueue.h
+++ b/netwerk/ipc/ChannelEventQueue.h
@@ -10,17 +10,17 @@
 
 #include "nsTArray.h"
 #include "nsAutoPtr.h"
 #include "nsIEventTarget.h"
 #include "nsThreadUtils.h"
 #include "nsXULAppAPI.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/Mutex.h"
-#include "mozilla/ReentrantMonitor.h"
+#include "mozilla/RecursiveMutex.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/Unused.h"
 
 class nsISupports;
 
 namespace mozilla {
 namespace net {
 
@@ -94,17 +94,17 @@ class ChannelEventQueue final
  public:
   explicit ChannelEventQueue(nsISupports *owner)
     : mSuspendCount(0)
     , mSuspended(false)
     , mForcedCount(0)
     , mFlushing(false)
     , mOwner(owner)
     , mMutex("ChannelEventQueue::mMutex")
-    , mRunningMonitor("ChannelEventQueue::mRunningMonitor")
+    , mRunningMutex("ChannelEventQueue::mRunningMutex")
   {}
 
   // Puts IPDL-generated channel event into queue, to be run later
   // automatically when EndForcedQueueing and/or Resume is called.
   //
   // @param aCallback - the ChannelEvent
   // @param aAssertionWhenNotQueued - this optional param will be used in an
   //   assertion when the event is executed directly.
@@ -155,17 +155,17 @@ class ChannelEventQueue final
 
   // Keep ptr to avoid refcount cycle: only grab ref during flushing.
   nsISupports *mOwner;
 
   // For atomic mEventQueue operation and state update
   Mutex mMutex;
 
   // To guarantee event execution order among threads
-  ReentrantMonitor mRunningMonitor;
+  RecursiveMutex mRunningMutex;
 
   friend class AutoEventEnqueuer;
 };
 
 inline void
 ChannelEventQueue::RunOrEnqueue(ChannelEvent* aCallback,
                                 bool aAssertionWhenNotQueued)
 {
@@ -177,17 +177,17 @@ ChannelEventQueue::RunOrEnqueue(ChannelE
   nsCOMPtr<nsISupports> kungFuDeathGrip(mOwner);
   Unused << kungFuDeathGrip; // Not used in this function
 
   // To avoid leaks.
   UniquePtr<ChannelEvent> event(aCallback);
 
   // To guarantee that the running event and all the events generated within
   // it will be finished before events on other threads.
-  ReentrantMonitorAutoEnter monitor(mRunningMonitor);
+  RecursiveMutexAutoLock lock(mRunningMutex);
 
   {
     MutexAutoLock lock(mMutex);
 
     bool enqueue =  !!mForcedCount || mSuspended || mFlushing || !mEventQueue.IsEmpty();
 
     if (enqueue) {
       mEventQueue.AppendElement(Move(event));
diff --git a/netwerk/protocol/http/HSTSPrimerListener.cpp b/netwerk/protocol/http/HSTSPrimerListener.cpp
--- a/netwerk/protocol/http/HSTSPrimerListener.cpp
+++ b/netwerk/protocol/http/HSTSPrimerListener.cpp
@@ -24,17 +24,17 @@
 
 namespace mozilla {
 namespace net {
 
 using namespace mozilla;
 
 NS_IMPL_ISUPPORTS(HSTSPrimingListener, nsIStreamListener,
                   nsIRequestObserver, nsIInterfaceRequestor,
-                  nsITimerCallback)
+                  nsITimerCallback, nsINamed)
 
 // default to 2000ms, same as the preference
 // security.mixed_content.hsts_priming_request_timeout
 uint32_t HSTSPrimingListener::sHSTSPrimingTimeout = 2000;
 
 
 HSTSPrimingListener::HSTSPrimingListener(nsIHstsPrimingCallback* aCallback)
   : mCallback(aCallback)
@@ -208,16 +208,24 @@ HSTSPrimingListener::Notify(nsITimer* ti
   rv = callback->OnHSTSPrimingFailed(NS_ERROR_HSTS_PRIMING_TIMEOUT, false);
   if (NS_FAILED(rv)) {
     NS_ERROR("HSTS Priming timed out, and we got an error reporting the failure.");
   }
 
   return NS_OK; // unused
 }
 
+/** nsINamed **/
+NS_IMETHODIMP
+HSTSPrimingListener::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("HSTSPrimingListener");
+  return NS_OK;
+}
+
 // static
 nsresult
 HSTSPrimingListener::StartHSTSPriming(nsIChannel* aRequestChannel,
                                       nsIHstsPrimingCallback* aCallback)
 {
   nsCOMPtr<nsIURI> finalChannelURI;
   nsresult rv = NS_GetFinalChannelURI(aRequestChannel, getter_AddRefs(finalChannelURI));
   NS_ENSURE_SUCCESS(rv, rv);
diff --git a/netwerk/protocol/http/HSTSPrimerListener.h b/netwerk/protocol/http/HSTSPrimerListener.h
--- a/netwerk/protocol/http/HSTSPrimerListener.h
+++ b/netwerk/protocol/http/HSTSPrimerListener.h
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef HSTSPrimingListener_h__
 #define HSTSPrimingListener_h__
 
 #include "nsCOMPtr.h"
 #include "nsIChannelEventSink.h"
 #include "nsIInterfaceRequestor.h"
+#include "nsINamed.h"
 #include "nsIStreamListener.h"
 #include "nsIThreadRetargetableStreamListener.h"
 #include "nsITimer.h"
 
 #include "mozilla/Attributes.h"
 
 class nsIPrincipal;
 class nsINetworkInterceptController;
@@ -85,26 +86,28 @@ enum HSTSPrimingResult {
 };
 
 //////////////////////////////////////////////////////////////////////////
 // Class used as streamlistener and notification callback when
 // doing the HEAD request for an HSTS Priming check. Needs to be an
 // nsIStreamListener in order to receive events from AsyncOpen2
 class HSTSPrimingListener final : public nsIStreamListener,
                                   public nsIInterfaceRequestor,
-                                  public nsITimerCallback
+                                  public nsITimerCallback,
+                                  public nsINamed
 {
 public:
   explicit HSTSPrimingListener(nsIHstsPrimingCallback* aCallback);
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSISTREAMLISTENER
   NS_DECL_NSIREQUESTOBSERVER
   NS_DECL_NSIINTERFACEREQUESTOR
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
 private:
   ~HSTSPrimingListener() {}
 
   // Only nsHttpChannel can invoke HSTS priming
   friend class mozilla::net::nsHttpChannel;
 
   /**
diff --git a/netwerk/protocol/http/TunnelUtils.cpp b/netwerk/protocol/http/TunnelUtils.cpp
--- a/netwerk/protocol/http/TunnelUtils.cpp
+++ b/netwerk/protocol/http/TunnelUtils.cpp
@@ -442,16 +442,23 @@ TLSFilterTransaction::Notify(nsITimer *t
   if (timer != mTimer) {
     return NS_ERROR_UNEXPECTED;
   }
   DebugOnly<nsresult> rv = StartTimerCallback();
   MOZ_ASSERT(NS_SUCCEEDED(rv));
   return NS_OK;
 }
 
+NS_IMETHODIMP
+TLSFilterTransaction::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("TLSFilterTransaction");
+  return NS_OK;
+}
+
 nsresult
 TLSFilterTransaction::StartTimerCallback()
 {
   LOG(("TLSFilterTransaction %p NudgeTunnel StartTimerCallback %p\n",
        this, mNudgeCallback.get()));
 
   if (mNudgeCallback) {
     // This class can be called re-entrantly, so cleanup m* before ->on()
@@ -1618,17 +1625,17 @@ SocketTransportShim::SetQoSBits(uint8_t 
 }
 
 NS_IMETHODIMP
 SocketTransportShim::SetFastOpenCallback(TCPFastOpen *aFastOpen)
 {
   return mWrapped->SetFastOpenCallback(aFastOpen);
 }
 
-NS_IMPL_ISUPPORTS(TLSFilterTransaction, nsITimerCallback)
+NS_IMPL_ISUPPORTS(TLSFilterTransaction, nsITimerCallback, nsINamed)
 NS_IMPL_ISUPPORTS(SocketTransportShim, nsISocketTransport, nsITransport)
 NS_IMPL_ISUPPORTS(InputStreamShim, nsIInputStream, nsIAsyncInputStream)
 NS_IMPL_ISUPPORTS(OutputStreamShim, nsIOutputStream, nsIAsyncOutputStream)
 NS_IMPL_ISUPPORTS(SocketInWrapper, nsIAsyncInputStream)
 NS_IMPL_ISUPPORTS(SocketOutWrapper, nsIAsyncOutputStream)
 
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/protocol/http/TunnelUtils.h b/netwerk/protocol/http/TunnelUtils.h
--- a/netwerk/protocol/http/TunnelUtils.h
+++ b/netwerk/protocol/http/TunnelUtils.h
@@ -7,16 +7,17 @@
 #ifndef mozilla_net_TLSFilterTransaction_h
 #define mozilla_net_TLSFilterTransaction_h
 
 #include "mozilla/Attributes.h"
 #include "mozilla/UniquePtr.h"
 #include "nsAHttpTransaction.h"
 #include "nsIAsyncInputStream.h"
 #include "nsIAsyncOutputStream.h"
+#include "nsINamed.h"
 #include "nsISocketTransport.h"
 #include "nsITimer.h"
 #include "NullHttpTransaction.h"
 #include "mozilla/TimeStamp.h"
 #include "prio.h"
 
 // a TLSFilterTransaction wraps another nsAHttpTransaction but
 // applies a encode/decode filter of TLS onto the ReadSegments
@@ -98,24 +99,26 @@ public:
 
 #define NS_DECL_NUDGETUNNELCALLBACK void OnTunnelNudged(TLSFilterTransaction *) override;
 
 class TLSFilterTransaction final
   : public nsAHttpTransaction
   , public nsAHttpSegmentReader
   , public nsAHttpSegmentWriter
   , public nsITimerCallback
+  , public nsINamed
 {
   ~TLSFilterTransaction();
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSAHTTPTRANSACTION
   NS_DECL_NSAHTTPSEGMENTREADER
   NS_DECL_NSAHTTPSEGMENTWRITER
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   TLSFilterTransaction(nsAHttpTransaction *aWrappedTransaction,
                        const char *tlsHost, int32_t tlsPort,
                        nsAHttpSegmentReader *reader,
                        nsAHttpSegmentWriter *writer);
 
   const nsAHttpTransaction *Transaction() const { return mTransaction.get(); }
   MOZ_MUST_USE nsresult CommitToSegmentSize(uint32_t size,
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -3651,16 +3651,17 @@ NS_IMPL_ADDREF(nsHttpConnectionMgr::nsHa
 NS_IMPL_RELEASE(nsHttpConnectionMgr::nsHalfOpenSocket)
 
 NS_INTERFACE_MAP_BEGIN(nsHttpConnectionMgr::nsHalfOpenSocket)
     NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
     NS_INTERFACE_MAP_ENTRY(nsIOutputStreamCallback)
     NS_INTERFACE_MAP_ENTRY(nsITransportEventSink)
     NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
     NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
+    NS_INTERFACE_MAP_ENTRY(nsINamed)
     // we have no macro that covers this case.
     if (aIID.Equals(NS_GET_IID(nsHttpConnectionMgr::nsHalfOpenSocket)) ) {
         AddRef();
         *aInstancePtr = this;
         return NS_OK;
     } else
 NS_INTERFACE_MAP_END
 
@@ -4031,16 +4032,23 @@ nsHttpConnectionMgr::nsHalfOpenSocket::N
 
     DebugOnly<nsresult> rv = SetupBackupStreams();
     MOZ_ASSERT(NS_SUCCEEDED(rv));
 
     mSynTimer = nullptr;
     return NS_OK;
 }
 
+NS_IMETHODIMP // method for nsINamed
+nsHttpConnectionMgr::nsHalfOpenSocket::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsHttpConnectionMgr::nsHalfOpenSocket");
+  return NS_OK;
+}
+
 already_AddRefed<nsHttpConnectionMgr::PendingTransactionInfo>
 nsHttpConnectionMgr::
 nsHalfOpenSocket::FindTransactionHelper(bool removeWhenFound)
 {
     nsTArray<RefPtr<PendingTransactionInfo>> *pendingQ =
         gHttpHandler->ConnMgr()->GetTransactionPendingQHelper(mEnt, mTransaction);
 
     int32_t index = pendingQ
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.h b/netwerk/protocol/http/nsHttpConnectionMgr.h
--- a/netwerk/protocol/http/nsHttpConnectionMgr.h
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.h
@@ -16,16 +16,17 @@
 #include "mozilla/ReentrantMonitor.h"
 #include "mozilla/TimeStamp.h"
 #include "mozilla/Attributes.h"
 #include "AlternateServices.h"
 #include "ARefBase.h"
 #include "nsWeakReference.h"
 #include "TCPFastOpen.h"
 
+#include "nsINamed.h"
 #include "nsIObserver.h"
 #include "nsITimer.h"
 
 class nsIHttpUpgradeListener;
 
 namespace mozilla {
 namespace net {
 class EventTokenBucket;
@@ -353,28 +354,30 @@ private:
 
     // nsHalfOpenSocket is used to hold the state of an opening TCP socket
     // while we wait for it to establish and bind it to a connection
 
     class nsHalfOpenSocket final : public nsIOutputStreamCallback,
                                    public nsITransportEventSink,
                                    public nsIInterfaceRequestor,
                                    public nsITimerCallback,
+                                   public nsINamed,
                                    public nsSupportsWeakReference,
                                    public TCPFastOpen
     {
         ~nsHalfOpenSocket();
 
     public:
         NS_DECLARE_STATIC_IID_ACCESSOR(NS_HALFOPENSOCKET_IID)
         NS_DECL_THREADSAFE_ISUPPORTS
         NS_DECL_NSIOUTPUTSTREAMCALLBACK
         NS_DECL_NSITRANSPORTEVENTSINK
         NS_DECL_NSIINTERFACEREQUESTOR
         NS_DECL_NSITIMERCALLBACK
+        NS_DECL_NSINAMED
 
         nsHalfOpenSocket(nsConnectionEntry *ent,
                          nsAHttpTransaction *trans,
                          uint32_t caps,
                          bool speculative,
                          bool isFromPredictor);
 
         MOZ_MUST_USE nsresult SetupStreams(nsISocketTransport **,
diff --git a/netwerk/protocol/http/nsHttpRequestHead.cpp b/netwerk/protocol/http/nsHttpRequestHead.cpp
--- a/netwerk/protocol/http/nsHttpRequestHead.cpp
+++ b/netwerk/protocol/http/nsHttpRequestHead.cpp
@@ -16,261 +16,261 @@
 namespace mozilla {
 namespace net {
 
 nsHttpRequestHead::nsHttpRequestHead()
     : mMethod(NS_LITERAL_CSTRING("GET"))
     , mVersion(NS_HTTP_VERSION_1_1)
     , mParsedMethod(kMethod_Get)
     , mHTTPS(false)
-    , mReentrantMonitor("nsHttpRequestHead.mReentrantMonitor")
+    , mRecursiveMutex("nsHttpRequestHead.mRecursiveMutex")
     , mInVisitHeaders(false)
 {
     MOZ_COUNT_CTOR(nsHttpRequestHead);
 }
 
 nsHttpRequestHead::~nsHttpRequestHead()
 {
     MOZ_COUNT_DTOR(nsHttpRequestHead);
 }
 
 // Don't use this function. It is only used by HttpChannelParent to avoid
 // copying of request headers!!!
 const nsHttpHeaderArray &
 nsHttpRequestHead::Headers() const
 {
     nsHttpRequestHead &curr = const_cast<nsHttpRequestHead&>(*this);
-    curr.mReentrantMonitor.AssertCurrentThreadIn();
+    curr.mRecursiveMutex.AssertCurrentThreadIn();
     return mHeaders;
 }
 
 void
 nsHttpRequestHead::SetHeaders(const nsHttpHeaderArray& aHeaders)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     mHeaders = aHeaders;
 }
 
 void
 nsHttpRequestHead::SetVersion(nsHttpVersion version)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     mVersion = version;
 }
 
 void
 nsHttpRequestHead::SetRequestURI(const nsACString& s)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     mRequestURI = s;
 }
 
 void
 nsHttpRequestHead::SetPath(const nsACString& s)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     mPath = s;
 }
 
 uint32_t
 nsHttpRequestHead::HeaderCount()
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     return mHeaders.Count();
 }
 
 nsresult
 nsHttpRequestHead::VisitHeaders(nsIHttpHeaderVisitor *visitor,
                                 nsHttpHeaderArray::VisitorFilter filter /* = nsHttpHeaderArray::eFilterAll*/)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     mInVisitHeaders = true;
     nsresult rv = mHeaders.VisitHeaders(visitor, filter);
     mInVisitHeaders = false;
     return rv;
 }
 
 void
 nsHttpRequestHead::Method(nsACString &aMethod)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     aMethod = mMethod;
 }
 
 nsHttpVersion
 nsHttpRequestHead::Version()
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     return mVersion;
 }
 
 void
 nsHttpRequestHead::RequestURI(nsACString &aRequestURI)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     aRequestURI = mRequestURI;
 }
 
 void
 nsHttpRequestHead::Path(nsACString &aPath)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     aPath = mPath.IsEmpty() ? mRequestURI : mPath;
 }
 
 void
 nsHttpRequestHead::SetHTTPS(bool val)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     mHTTPS = val;
 }
 
 void
 nsHttpRequestHead::Origin(nsACString &aOrigin)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     aOrigin = mOrigin;
 }
 
 nsresult
 nsHttpRequestHead::SetHeader(const nsACString &h, const nsACString &v,
                              bool m /*= false*/)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
 
     if (mInVisitHeaders) {
         return NS_ERROR_FAILURE;
     }
 
     return mHeaders.SetHeader(h, v, m,
                               nsHttpHeaderArray::eVarietyRequestOverride);
 }
 
 nsresult
 nsHttpRequestHead::SetHeader(nsHttpAtom h, const nsACString &v,
                              bool m /*= false*/)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
 
     if (mInVisitHeaders) {
         return NS_ERROR_FAILURE;
     }
 
     return mHeaders.SetHeader(h, v, m,
                               nsHttpHeaderArray::eVarietyRequestOverride);
 }
 
 nsresult
 nsHttpRequestHead::SetHeader(nsHttpAtom h, const nsACString &v, bool m,
                              nsHttpHeaderArray::HeaderVariety variety)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
 
     if (mInVisitHeaders) {
         return NS_ERROR_FAILURE;
     }
 
     return mHeaders.SetHeader(h, v, m, variety);
 }
 
 nsresult
 nsHttpRequestHead::SetEmptyHeader(const nsACString &h)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
 
     if (mInVisitHeaders) {
         return NS_ERROR_FAILURE;
     }
 
     return mHeaders.SetEmptyHeader(h,
                                    nsHttpHeaderArray::eVarietyRequestOverride);
 }
 
 nsresult
 nsHttpRequestHead::GetHeader(nsHttpAtom h, nsACString &v)
 {
     v.Truncate();
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     return mHeaders.GetHeader(h, v);
 }
 
 nsresult
 nsHttpRequestHead::ClearHeader(nsHttpAtom h)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
 
     if (mInVisitHeaders) {
         return NS_ERROR_FAILURE;
     }
 
     mHeaders.ClearHeader(h);
     return NS_OK;
 }
 
 void
 nsHttpRequestHead::ClearHeaders()
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
 
     if (mInVisitHeaders) {
         return;
     }
 
     mHeaders.Clear();
 }
 
 bool
 nsHttpRequestHead::HasHeader(nsHttpAtom h)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     return mHeaders.HasHeader(h);
 }
 
 bool
 nsHttpRequestHead::HasHeaderValue(nsHttpAtom h, const char *v)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     return mHeaders.HasHeaderValue(h, v);
 }
 
 nsresult
 nsHttpRequestHead::SetHeaderOnce(nsHttpAtom h, const char *v,
                                  bool merge /*= false */)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
 
     if (mInVisitHeaders) {
         return NS_ERROR_FAILURE;
     }
 
     if (!merge || !mHeaders.HasHeaderValue(h, v)) {
         return mHeaders.SetHeader(h, nsDependentCString(v), merge,
                                   nsHttpHeaderArray::eVarietyRequestOverride);
     }
     return NS_OK;
 }
 
 nsHttpRequestHead::ParsedMethodType
 nsHttpRequestHead::ParsedMethod()
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     return mParsedMethod;
 }
 
 bool
 nsHttpRequestHead::EqualsMethod(ParsedMethodType aType)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     return mParsedMethod == aType;
 }
 
 void
 nsHttpRequestHead::ParseHeaderSet(const char *buffer)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     nsHttpAtom hdr;
     nsAutoCString headerNameOriginal;
     nsAutoCString val;
     while (buffer) {
         const char *eof = strchr(buffer, '\r');
         if (!eof) {
             break;
         }
@@ -291,24 +291,24 @@ nsHttpRequestHead::ParseHeaderSet(const 
             buffer++;
         }
     }
 }
 
 bool
 nsHttpRequestHead::IsHTTPS()
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     return mHTTPS;
 }
 
 void
 nsHttpRequestHead::SetMethod(const nsACString &method)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     mParsedMethod = kMethod_Custom;
     mMethod = method;
     if (!strcmp(mMethod.get(), "GET")) {
         mParsedMethod = kMethod_Get;
     } else if (!strcmp(mMethod.get(), "POST")) {
         mParsedMethod = kMethod_Post;
     } else if (!strcmp(mMethod.get(), "OPTIONS")) {
         mParsedMethod = kMethod_Options;
@@ -322,30 +322,30 @@ nsHttpRequestHead::SetMethod(const nsACS
         mParsedMethod = kMethod_Trace;
     }
 }
 
 void
 nsHttpRequestHead::SetOrigin(const nsACString &scheme, const nsACString &host,
                              int32_t port)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     mOrigin.Assign(scheme);
     mOrigin.Append(NS_LITERAL_CSTRING("://"));
     mOrigin.Append(host);
     if (port >= 0) {
         mOrigin.Append(NS_LITERAL_CSTRING(":"));
         mOrigin.AppendInt(port);
     }
 }
 
 bool
 nsHttpRequestHead::IsSafeMethod()
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     // This code will need to be extended for new safe methods, otherwise
     // they'll default to "not safe".
     if ((mParsedMethod == kMethod_Get) || (mParsedMethod == kMethod_Head) ||
         (mParsedMethod == kMethod_Options) || (mParsedMethod == kMethod_Trace)
        ) {
         return true;
     }
 
@@ -356,17 +356,17 @@ nsHttpRequestHead::IsSafeMethod()
     return (!strcmp(mMethod.get(), "PROPFIND") ||
             !strcmp(mMethod.get(), "REPORT") ||
             !strcmp(mMethod.get(), "SEARCH"));
 }
 
 void
 nsHttpRequestHead::Flatten(nsACString &buf, bool pruneProxyHeaders)
 {
-    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    RecursiveMutexAutoLock mon(mRecursiveMutex);
     // note: the first append is intentional.
 
     buf.Append(mMethod);
     buf.Append(' ');
     buf.Append(mRequestURI);
     buf.AppendLiteral(" HTTP/");
 
     switch (mVersion) {
diff --git a/netwerk/protocol/http/nsHttpRequestHead.h b/netwerk/protocol/http/nsHttpRequestHead.h
--- a/netwerk/protocol/http/nsHttpRequestHead.h
+++ b/netwerk/protocol/http/nsHttpRequestHead.h
@@ -4,17 +4,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsHttpRequestHead_h__
 #define nsHttpRequestHead_h__
 
 #include "nsHttp.h"
 #include "nsHttpHeaderArray.h"
 #include "nsString.h"
-#include "mozilla/ReentrantMonitor.h"
+#include "mozilla/RecursiveMutex.h"
 
 class nsIHttpHeaderVisitor;
 
 namespace mozilla { namespace net {
 
 //-----------------------------------------------------------------------------
 // nsHttpRequestHead represents the request line and headers from an HTTP
 // request.
@@ -25,18 +25,18 @@ class nsHttpRequestHead
 public:
     nsHttpRequestHead();
     ~nsHttpRequestHead();
 
     // The following function is only used in HttpChannelParent to avoid
     // copying headers. If you use it be careful to do it only under
     // nsHttpRequestHead lock!!!
     const nsHttpHeaderArray &Headers() const;
-    void Enter() { mReentrantMonitor.Enter(); }
-    void Exit() { mReentrantMonitor.Exit(); }
+    void Enter() { mRecursiveMutex.Lock(); }
+    void Exit() { mRecursiveMutex.Unlock(); }
 
     void SetHeaders(const nsHttpHeaderArray& aHeaders);
 
     void SetMethod(const nsACString &method);
     void SetVersion(nsHttpVersion version);
     void SetRequestURI(const nsACString& s);
     void SetPath(const nsACString& s);
     uint32_t HeaderCount();
@@ -114,19 +114,19 @@ private:
     // because this is used off the main thread
     nsCString         mRequestURI;
     nsCString         mPath;
 
     nsCString         mOrigin;
     ParsedMethodType  mParsedMethod;
     bool              mHTTPS;
 
-    // We are using ReentrantMonitor instead of a Mutex because VisitHeader
+    // We are using RecursiveMutex instead of a Mutex because VisitHeader
     // function calls nsIHttpHeaderVisitor::VisitHeader while under lock.
-    ReentrantMonitor  mReentrantMonitor;
+    RecursiveMutex  mRecursiveMutex;
 
     // During VisitHeader we sould not allow cal to SetHeader.
     bool mInVisitHeaders;
 };
 
 } // namespace net
 } // namespace mozilla
 
diff --git a/netwerk/protocol/http/nsHttpResponseHead.cpp b/netwerk/protocol/http/nsHttpResponseHead.cpp
--- a/netwerk/protocol/http/nsHttpResponseHead.cpp
+++ b/netwerk/protocol/http/nsHttpResponseHead.cpp
@@ -19,21 +19,21 @@
 namespace mozilla {
 namespace net {
 
 //-----------------------------------------------------------------------------
 // nsHttpResponseHead <public>
 //-----------------------------------------------------------------------------
 
 nsHttpResponseHead::nsHttpResponseHead(const nsHttpResponseHead &aOther)
-    : mReentrantMonitor("nsHttpResponseHead.mReentrantMonitor")
+    : mRecursiveMutex("nsHttpResponseHead.mRecursiveMutex")
     , mInVisitHeaders(false)
 {
     nsHttpResponseHead &other = const_cast<nsHttpResponseHead&>(aOther);
-    ReentrantMonitorAutoEnter monitor(other.mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(other.mRecursiveMutex);
 
     mHeaders = other.mHeaders;
     mVersion = other.mVersion;
     mStatus = other.mStatus;
     mStatusText = other.mStatusText;
     mContentLength = other.mContentLength;
     mContentType = other.mContentType;
     mContentCharset = other.mContentCharset;
@@ -43,18 +43,18 @@ nsHttpResponseHead::nsHttpResponseHead(c
     mCacheControlImmutable = other.mCacheControlImmutable;
     mPragmaNoCache = other.mPragmaNoCache;
 }
 
 nsHttpResponseHead&
 nsHttpResponseHead::operator=(const nsHttpResponseHead &aOther)
 {
     nsHttpResponseHead &other = const_cast<nsHttpResponseHead&>(aOther);
-    ReentrantMonitorAutoEnter monitorOther(other.mReentrantMonitor);
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitorOther(other.mRecursiveMutex);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
 
     mHeaders = other.mHeaders;
     mVersion = other.mVersion;
     mStatus = other.mStatus;
     mStatusText = other.mStatusText;
     mContentLength = other.mContentLength;
     mContentType = other.mContentType;
     mContentCharset = other.mContentCharset;
@@ -65,89 +65,89 @@ nsHttpResponseHead::operator=(const nsHt
     mPragmaNoCache = other.mPragmaNoCache;
 
     return *this;
 }
 
 nsHttpVersion
 nsHttpResponseHead::Version()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return mVersion;
 }
 
 uint16_t
 nsHttpResponseHead::Status()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return mStatus;
 }
 
 void
 nsHttpResponseHead::StatusText(nsACString &aStatusText)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     aStatusText = mStatusText;
 }
 
 int64_t
 nsHttpResponseHead::ContentLength()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return mContentLength;
 }
 
 void
 nsHttpResponseHead::ContentType(nsACString &aContentType)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     aContentType = mContentType;
 }
 
 void
 nsHttpResponseHead::ContentCharset(nsACString &aContentCharset)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     aContentCharset = mContentCharset;
 }
 
 bool
 nsHttpResponseHead::Private()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return mCacheControlPrivate;
 }
 
 bool
 nsHttpResponseHead::NoStore()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return mCacheControlNoStore;
 }
 
 bool
 nsHttpResponseHead::NoCache()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return (mCacheControlNoCache || mPragmaNoCache);
 }
 
 bool
 nsHttpResponseHead::Immutable()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return mCacheControlImmutable;
 }
 
 nsresult
 nsHttpResponseHead::SetHeader(const nsACString &hdr,
                               const nsACString &val,
                               bool merge)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
 
     if (mInVisitHeaders) {
         return NS_ERROR_FAILURE;
     }
 
     nsHttpAtom atom = nsHttp::ResolveAtom(PromiseFlatCString(hdr).get());
     if (!atom) {
         NS_WARNING("failed to resolve atom");
@@ -157,17 +157,17 @@ nsHttpResponseHead::SetHeader(const nsAC
     return SetHeader_locked(atom, hdr, val, merge);
 }
 
 nsresult
 nsHttpResponseHead::SetHeader(nsHttpAtom hdr,
                               const nsACString &val,
                               bool merge)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
 
     if (mInVisitHeaders) {
         return NS_ERROR_FAILURE;
     }
 
     return SetHeader_locked(hdr, EmptyCString(), val, merge);
 }
 
@@ -190,66 +190,66 @@ nsHttpResponseHead::SetHeader_locked(nsH
 
     return NS_OK;
 }
 
 nsresult
 nsHttpResponseHead::GetHeader(nsHttpAtom h, nsACString &v)
 {
     v.Truncate();
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return mHeaders.GetHeader(h, v);
 }
 
 void
 nsHttpResponseHead::ClearHeader(nsHttpAtom h)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     mHeaders.ClearHeader(h);
 }
 
 void
 nsHttpResponseHead::ClearHeaders()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     mHeaders.Clear();
 }
 
 bool
 nsHttpResponseHead::HasHeaderValue(nsHttpAtom h, const char *v)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return mHeaders.HasHeaderValue(h, v);
 }
 
 bool
 nsHttpResponseHead::HasHeader(nsHttpAtom h)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return mHeaders.HasHeader(h);
 }
 
 void
 nsHttpResponseHead::SetContentType(const nsACString &s)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     mContentType = s;
 }
 
 void
 nsHttpResponseHead::SetContentCharset(const nsACString &s)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     mContentCharset = s;
 }
 
 void
 nsHttpResponseHead::SetContentLength(int64_t len)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
 
     mContentLength = len;
     if (len < 0)
         mHeaders.ClearHeader(nsHttp::Content_Length);
     else {
         DebugOnly<nsresult> rv =
             mHeaders.SetHeader(nsHttp::Content_Length,
                                nsPrintfCString("%" PRId64, len),
@@ -257,17 +257,17 @@ nsHttpResponseHead::SetContentLength(int
                                nsHttpHeaderArray::eVarietyResponse);
         MOZ_ASSERT(NS_SUCCEEDED(rv));
     }
 }
 
 void
 nsHttpResponseHead::Flatten(nsACString &buf, bool pruneTransients)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     if (mVersion == NS_HTTP_VERSION_0_9)
         return;
 
     buf.AppendLiteral("HTTP/");
     if (mVersion == NS_HTTP_VERSION_2_0)
         buf.AppendLiteral("2.0 ");
     else if (mVersion == NS_HTTP_VERSION_1_1)
         buf.AppendLiteral("1.1 ");
@@ -281,28 +281,28 @@ nsHttpResponseHead::Flatten(nsACString &
 
 
     mHeaders.Flatten(buf, false, pruneTransients);
 }
 
 void
 nsHttpResponseHead::FlattenNetworkOriginalHeaders(nsACString &buf)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     if (mVersion == NS_HTTP_VERSION_0_9) {
         return;
     }
 
     mHeaders.FlattenOriginalHeader(buf);
 }
 
 nsresult
 nsHttpResponseHead::ParseCachedHead(const char *block)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     LOG(("nsHttpResponseHead::ParseCachedHead [this=%p]\n", this));
 
     // this command works on a buffer as prepared by Flatten, as such it is
     // not very forgiving ;-)
 
     char *p = PL_strstr(block, "\r\n");
     if (!p)
         return NS_ERROR_UNEXPECTED;
@@ -324,17 +324,17 @@ nsHttpResponseHead::ParseCachedHead(cons
     } while (1);
 
     return NS_OK;
 }
 
 nsresult
 nsHttpResponseHead::ParseCachedOriginalHeaders(char *block)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     LOG(("nsHttpResponseHead::ParseCachedOriginalHeader [this=%p]\n", this));
 
     // this command works on a buffer as prepared by FlattenOriginalHeader,
     // as such it is not very forgiving ;-)
 
     if (!block) {
         return NS_ERROR_UNEXPECTED;
     }
@@ -530,17 +530,17 @@ nsHttpResponseHead::AssignDefaultStatusT
         break;
     }
 }
 
 void
 nsHttpResponseHead::ParseStatusLine(const nsACString &line)
 {
 
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     ParseStatusLine_locked(line);
 }
 
 void
 nsHttpResponseHead::ParseStatusLine_locked(const nsACString &line)
 {
     //
     // Parse Status-Line:: HTTP-Version SP Status-Code SP Reason-Phrase CRLF
@@ -581,17 +581,17 @@ nsHttpResponseHead::ParseStatusLine_lock
 
     LOG(("Have status line [version=%u status=%u statusText=%s]\n",
         unsigned(mVersion), unsigned(mStatus), mStatusText.get()));
 }
 
 nsresult
 nsHttpResponseHead::ParseHeaderLine(const nsACString &line)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return ParseHeaderLine_locked(line, true);
 }
 
 nsresult
 nsHttpResponseHead::ParseHeaderLine_locked(const nsACString &line, bool originalFromNetHeaders)
 {
     nsHttpAtom hdr = {0};
     nsAutoCString headerNameOriginal;
@@ -654,17 +654,17 @@ nsHttpResponseHead::ParseHeaderLine_lock
 //
 // This is typically a very small number.
 //
 nsresult
 nsHttpResponseHead::ComputeCurrentAge(uint32_t now,
                                       uint32_t requestTime,
                                       uint32_t *result)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     uint32_t dateValue;
     uint32_t ageValue;
 
     *result = 0;
 
     if (requestTime > now) {
         // for calculation purposes lets not allow the request to happen in the future
         requestTime = now;
@@ -700,17 +700,17 @@ nsHttpResponseHead::ComputeCurrentAge(ui
 // <or>
 //     freshnessLifetime = min(one-week,(date_value - last_modified_value) * 0.10)
 // <or>
 //     freshnessLifetime = 0
 //
 nsresult
 nsHttpResponseHead::ComputeFreshnessLifetime(uint32_t *result)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     *result = 0;
 
     // Try HTTP/1.1 style max-age directive...
     if (NS_SUCCEEDED(GetMaxAgeValue_locked(result)))
         return NS_OK;
 
     *result = 0;
 
@@ -758,17 +758,17 @@ nsHttpResponseHead::ComputeFreshnessLife
          "lifetime!\n", this));
 
     return NS_OK;
 }
 
 bool
 nsHttpResponseHead::MustValidate()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     LOG(("nsHttpResponseHead::MustValidate ??\n"));
 
     // Some response codes are cacheable, but the rest are not.  This switch
     // should stay in sync with the list in nsHttpChannel::ProcessResponse
     switch (mStatus) {
         // Success codes
     case 200:
     case 203:
@@ -834,34 +834,34 @@ nsHttpResponseHead::MustValidateIfExpire
     //  a subsequent request without first revalidating it with the origin server.
     //
     return HasHeaderValue(nsHttp::Cache_Control, "must-revalidate");
 }
 
 bool
 nsHttpResponseHead::IsResumable()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     // even though some HTTP/1.0 servers may support byte range requests, we're not
     // going to bother with them, since those servers wouldn't understand If-Range.
     // Also, while in theory it may be possible to resume when the status code
     // is not 200, it is unlikely to be worth the trouble, especially for
     // non-2xx responses.
     return mStatus == 200 &&
            mVersion >= NS_HTTP_VERSION_1_1 &&
            mHeaders.PeekHeader(nsHttp::Content_Length) &&
            (mHeaders.PeekHeader(nsHttp::ETag) ||
             mHeaders.PeekHeader(nsHttp::Last_Modified)) &&
            mHeaders.HasHeaderValue(nsHttp::Accept_Ranges, "bytes");
 }
 
 bool
 nsHttpResponseHead::ExpiresInPast()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return ExpiresInPast_locked();
 }
 
 bool
 nsHttpResponseHead::ExpiresInPast_locked() const
 {
     uint32_t maxAgeVal, expiresVal, dateVal;
 
@@ -875,18 +875,18 @@ nsHttpResponseHead::ExpiresInPast_locked
            expiresVal < dateVal;
 }
 
 nsresult
 nsHttpResponseHead::UpdateHeaders(nsHttpResponseHead *aOther)
 {
     LOG(("nsHttpResponseHead::UpdateHeaders [this=%p]\n", this));
 
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
-    ReentrantMonitorAutoEnter monitorOther(aOther->mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
+    RecursiveMutexAutoLock monitorOther(aOther->mRecursiveMutex);
 
     uint32_t i, count = aOther->mHeaders.Count();
     for (i=0; i<count; ++i) {
         nsHttpAtom header;
         nsAutoCString headerNameOriginal;
         const char *val = aOther->mHeaders.PeekHeaderAt(i, header, headerNameOriginal);
 
         if (!val) {
@@ -930,17 +930,17 @@ nsHttpResponseHead::UpdateHeaders(nsHttp
     return NS_OK;
 }
 
 void
 nsHttpResponseHead::Reset()
 {
     LOG(("nsHttpResponseHead::Reset\n"));
 
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
 
     mHeaders.Clear();
 
     mVersion = NS_HTTP_VERSION_1_1;
     mStatus = 200;
     mContentLength = -1;
     mCacheControlPrivate = false;
     mCacheControlNoStore = false;
@@ -966,17 +966,17 @@ nsHttpResponseHead::ParseDateHeader(nsHt
 
     *result = PRTimeToSeconds(time);
     return NS_OK;
 }
 
 nsresult
 nsHttpResponseHead::GetAgeValue(uint32_t *result)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return GetAgeValue_locked(result);
 }
 
 nsresult
 nsHttpResponseHead::GetAgeValue_locked(uint32_t *result) const
 {
     const char *val = mHeaders.PeekHeader(nsHttp::Age);
     if (!val)
@@ -986,17 +986,17 @@ nsHttpResponseHead::GetAgeValue_locked(u
     return NS_OK;
 }
 
 // Return the value of the (HTTP 1.1) max-age directive, which itself is a
 // component of the Cache-Control response header
 nsresult
 nsHttpResponseHead::GetMaxAgeValue(uint32_t *result)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return GetMaxAgeValue_locked(result);
 }
 
 nsresult
 nsHttpResponseHead::GetMaxAgeValue_locked(uint32_t *result) const
 {
     const char *val = mHeaders.PeekHeader(nsHttp::Cache_Control);
     if (!val)
@@ -1019,24 +1019,24 @@ nsHttpResponseHead::GetMaxAgeValue_locke
         maxAgeValue = 0;
     *result = static_cast<uint32_t>(maxAgeValue);
     return NS_OK;
 }
 
 nsresult
 nsHttpResponseHead::GetDateValue(uint32_t *result)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return GetDateValue_locked(result);
 }
 
 nsresult
 nsHttpResponseHead::GetExpiresValue(uint32_t *result)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return GetExpiresValue_locked(result);
 }
 
 nsresult
 nsHttpResponseHead::GetExpiresValue_locked(uint32_t *result) const
 {
     const char *val = mHeaders.PeekHeader(nsHttp::Expires);
     if (!val)
@@ -1056,27 +1056,27 @@ nsHttpResponseHead::GetExpiresValue_lock
     else
         *result = PRTimeToSeconds(time);
     return NS_OK;
 }
 
 nsresult
 nsHttpResponseHead::GetLastModifiedValue(uint32_t *result)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return ParseDateHeader(nsHttp::Last_Modified, result);
 }
 
 bool
 nsHttpResponseHead::operator==(const nsHttpResponseHead& aOther) const
 {
     nsHttpResponseHead &curr = const_cast<nsHttpResponseHead&>(*this);
     nsHttpResponseHead &other = const_cast<nsHttpResponseHead&>(aOther);
-    ReentrantMonitorAutoEnter monitorOther(other.mReentrantMonitor);
-    ReentrantMonitorAutoEnter monitor(curr.mReentrantMonitor);
+    RecursiveMutexAutoLock monitorOther(other.mRecursiveMutex);
+    RecursiveMutexAutoLock monitor(curr.mRecursiveMutex);
 
     return mHeaders == aOther.mHeaders &&
            mVersion == aOther.mVersion &&
            mStatus == aOther.mStatus &&
            mStatusText == aOther.mStatusText &&
            mContentLength == aOther.mContentLength &&
            mContentType == aOther.mContentType &&
            mContentCharset == aOther.mContentCharset &&
@@ -1085,17 +1085,17 @@ nsHttpResponseHead::operator==(const nsH
            mCacheControlNoStore == aOther.mCacheControlNoStore &&
            mCacheControlImmutable == aOther.mCacheControlImmutable &&
            mPragmaNoCache == aOther.mPragmaNoCache;
 }
 
 int64_t
 nsHttpResponseHead::TotalEntitySize()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     const char* contentRange = mHeaders.PeekHeader(nsHttp::Content_Range);
     if (!contentRange)
         return mContentLength;
 
     // Total length is after a slash
     const char* slash = strrchr(contentRange, '/');
     if (!slash)
         return -1; // No idea what the length is
@@ -1213,42 +1213,42 @@ nsHttpResponseHead::ParsePragma(const ch
     if (nsHttp::FindToken(val, "no-cache", HTTP_HEADER_VALUE_SEPS))
         mPragmaNoCache = true;
 }
 
 nsresult
 nsHttpResponseHead::VisitHeaders(nsIHttpHeaderVisitor *visitor,
                                  nsHttpHeaderArray::VisitorFilter filter)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     mInVisitHeaders = true;
     nsresult rv = mHeaders.VisitHeaders(visitor, filter);
     mInVisitHeaders = false;
     return rv;
 }
 
 nsresult
 nsHttpResponseHead::GetOriginalHeader(nsHttpAtom aHeader,
                                       nsIHttpHeaderVisitor *aVisitor)
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     mInVisitHeaders = true;
     nsresult rv = mHeaders.GetOriginalHeader(aHeader, aVisitor);
     mInVisitHeaders = false;
     return rv;
 }
 
 bool
 nsHttpResponseHead::HasContentType()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return !mContentType.IsEmpty();
 }
 
 bool
 nsHttpResponseHead::HasContentCharset()
 {
-    ReentrantMonitorAutoEnter monitor(mReentrantMonitor);
+    RecursiveMutexAutoLock monitor(mRecursiveMutex);
     return !mContentCharset.IsEmpty();
 }
 
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/protocol/http/nsHttpResponseHead.h b/netwerk/protocol/http/nsHttpResponseHead.h
--- a/netwerk/protocol/http/nsHttpResponseHead.h
+++ b/netwerk/protocol/http/nsHttpResponseHead.h
@@ -4,17 +4,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsHttpResponseHead_h__
 #define nsHttpResponseHead_h__
 
 #include "nsHttpHeaderArray.h"
 #include "nsHttp.h"
 #include "nsString.h"
-#include "mozilla/ReentrantMonitor.h"
+#include "mozilla/RecursiveMutex.h"
 
 class nsIHttpHeaderVisitor;
 
 // This needs to be forward declared here so we can include only this header
 // without also including PHttpChannelParams.h
 namespace IPC {
     template <typename> struct ParamTraits;
 } // namespace IPC
@@ -32,24 +32,24 @@ public:
     nsHttpResponseHead() : mVersion(NS_HTTP_VERSION_1_1)
                          , mStatus(200)
                          , mContentLength(-1)
                          , mCacheControlPrivate(false)
                          , mCacheControlNoStore(false)
                          , mCacheControlNoCache(false)
                          , mCacheControlImmutable(false)
                          , mPragmaNoCache(false)
-                         , mReentrantMonitor("nsHttpResponseHead.mReentrantMonitor")
+                         , mRecursiveMutex("nsHttpResponseHead.mRecursiveMutex")
                          , mInVisitHeaders(false) {}
 
     nsHttpResponseHead(const nsHttpResponseHead &aOther);
     nsHttpResponseHead &operator=(const nsHttpResponseHead &aOther);
 
-    void Enter() { mReentrantMonitor.Enter(); }
-    void Exit() { mReentrantMonitor.Exit(); }
+    void Enter() { mRecursiveMutex.Lock(); }
+    void Exit() { mRecursiveMutex.Unlock(); }
 
     nsHttpVersion Version();
 // X11's Xlib.h #defines 'Status' to 'int' on some systems!
 #undef Status
     uint16_t Status();
     void StatusText(nsACString &aStatusText);
     int64_t ContentLength();
     void ContentType(nsACString &aContentType);
@@ -180,19 +180,19 @@ private:
     nsCString         mContentType;
     nsCString         mContentCharset;
     bool              mCacheControlPrivate;
     bool              mCacheControlNoStore;
     bool              mCacheControlNoCache;
     bool              mCacheControlImmutable;
     bool              mPragmaNoCache;
 
-    // We are using ReentrantMonitor instead of a Mutex because VisitHeader
+    // We are using RecursiveMutex instead of a Mutex because VisitHeader
     // function calls nsIHttpHeaderVisitor::VisitHeader while under lock.
-    ReentrantMonitor  mReentrantMonitor;
+    RecursiveMutex  mRecursiveMutex;
     // During VisitHeader we sould not allow cal to SetHeader.
     bool              mInVisitHeaders;
 
     friend struct IPC::ParamTraits<nsHttpResponseHead>;
 };
 
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/protocol/websocket/WebSocketChannel.cpp b/netwerk/protocol/websocket/WebSocketChannel.cpp
--- a/netwerk/protocol/websocket/WebSocketChannel.cpp
+++ b/netwerk/protocol/websocket/WebSocketChannel.cpp
@@ -84,17 +84,18 @@ NS_IMPL_ISUPPORTS(WebSocketChannel,
                   nsIInputStreamCallback,
                   nsIOutputStreamCallback,
                   nsITimerCallback,
                   nsIDNSListener,
                   nsIProtocolProxyCallback,
                   nsIInterfaceRequestor,
                   nsIChannelEventSink,
                   nsIThreadRetargetableRequest,
-                  nsIObserver)
+                  nsIObserver,
+                  nsINamed)
 
 // We implement RFC 6455, which uses Sec-WebSocket-Version: 13 on the wire.
 #define SEC_WEBSOCKET_VERSION "13"
 
 /*
  * About SSL unsigned certificates
  *
  * wss will not work to a host using an unsigned certificate unless there
@@ -3315,16 +3316,25 @@ WebSocketChannel::Notify(nsITimer *timer
     CleanupConnection();
   } else {
     MOZ_ASSERT(0, "Unknown Timer");
   }
 
   return NS_OK;
 }
 
+// nsINamed
+
+NS_IMETHODIMP
+WebSocketChannel::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("WebSocketChannel");
+  return NS_OK;
+}
+
 // nsIWebSocketChannel
 
 NS_IMETHODIMP
 WebSocketChannel::GetSecurityInfo(nsISupports **aSecurityInfo)
 {
   LOG(("WebSocketChannel::GetSecurityInfo() %p\n", this));
   MOZ_ASSERT(NS_IsMainThread(), "not main thread");
 
diff --git a/netwerk/protocol/websocket/WebSocketChannel.h b/netwerk/protocol/websocket/WebSocketChannel.h
--- a/netwerk/protocol/websocket/WebSocketChannel.h
+++ b/netwerk/protocol/websocket/WebSocketChannel.h
@@ -9,16 +9,17 @@
 
 #include "nsISupports.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIStreamListener.h"
 #include "nsIAsyncInputStream.h"
 #include "nsIAsyncOutputStream.h"
 #include "nsITimer.h"
 #include "nsIDNSListener.h"
+#include "nsINamed.h"
 #include "nsIObserver.h"
 #include "nsIProtocolProxyCallback.h"
 #include "nsIChannelEventSink.h"
 #include "nsIHttpChannelInternal.h"
 #include "nsIStringStream.h"
 #include "BaseWebSocketChannel.h"
 
 #include "nsCOMPtr.h"
@@ -66,33 +67,35 @@ class WebSocketChannel : public BaseWebS
                          public nsIStreamListener,
                          public nsIInputStreamCallback,
                          public nsIOutputStreamCallback,
                          public nsITimerCallback,
                          public nsIDNSListener,
                          public nsIObserver,
                          public nsIProtocolProxyCallback,
                          public nsIInterfaceRequestor,
-                         public nsIChannelEventSink
+                         public nsIChannelEventSink,
+                         public nsINamed
 {
   friend class WebSocketFrame;
 
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIHTTPUPGRADELISTENER
   NS_DECL_NSIREQUESTOBSERVER
   NS_DECL_NSISTREAMLISTENER
   NS_DECL_NSIINPUTSTREAMCALLBACK
   NS_DECL_NSIOUTPUTSTREAMCALLBACK
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSIDNSLISTENER
   NS_DECL_NSIPROTOCOLPROXYCALLBACK
   NS_DECL_NSIINTERFACEREQUESTOR
   NS_DECL_NSICHANNELEVENTSINK
   NS_DECL_NSIOBSERVER
+  NS_DECL_NSINAMED
 
   // nsIWebSocketChannel methods BaseWebSocketChannel didn't implement for us
   //
   NS_IMETHOD AsyncOpen(nsIURI *aURI,
                        const nsACString &aOrigin,
                        uint64_t aWindowID,
                        nsIWebSocketListener *aListener,
                        nsISupports *aContext) override;
diff --git a/old-configure.in b/old-configure.in
--- a/old-configure.in
+++ b/old-configure.in
@@ -3107,27 +3107,16 @@ if test -n "$MOZ_CRASHREPORTER"; then
   if test "$OS_ARCH" = "WINNT"; then
     if test -z "$HAVE_64BIT_BUILD" -a -n "$COMPILE_ENVIRONMENT"; then
       MOZ_CRASHREPORTER_INJECTOR=1
       AC_DEFINE(MOZ_CRASHREPORTER_INJECTOR)
     fi
   fi
 fi
 
-MOZ_ARG_WITH_STRING(crashreporter-enable-percent,
-[  --with-crashreporter-enable-percent=NN
-                          Enable sending crash reports by default on NN% of users. (default=100)],
-[ val=`echo $withval | sed 's/[^0-9]//g'`
-    MOZ_CRASHREPORTER_ENABLE_PERCENT="$val"])
-
-if test -z "$MOZ_CRASHREPORTER_ENABLE_PERCENT"; then
-   MOZ_CRASHREPORTER_ENABLE_PERCENT=100
-fi
-AC_DEFINE_UNQUOTED(MOZ_CRASHREPORTER_ENABLE_PERCENT, $MOZ_CRASHREPORTER_ENABLE_PERCENT)
-
 dnl ========================================================
 dnl = libjpeg-turbo configuration
 dnl ========================================================
 MOZ_LIBJPEG_TURBO=
 LIBJPEG_TURBO_USE_YASM=
 if test -z "$MOZ_SYSTEM_JPEG"; then
     MOZ_LIBJPEG_TURBO=1
 fi
diff --git a/parser/html/nsHtml5StreamParser.cpp b/parser/html/nsHtml5StreamParser.cpp
--- a/parser/html/nsHtml5StreamParser.cpp
+++ b/parser/html/nsHtml5StreamParser.cpp
@@ -1372,17 +1372,17 @@ nsHtml5StreamParser::FlushTreeOpsAndDisa
     }
     mFlushTimerArmed = false;
   }
   if (mMode == VIEW_SOURCE_HTML || mMode == VIEW_SOURCE_XML) {
     mTokenizer->FlushViewSource();
   }
   mTreeBuilder->Flush();
   nsCOMPtr<nsIRunnable> runnable(mExecutorFlusher);
-  if (NS_FAILED(DispatchToMain("nsHtml5ExecutorFlusher", runnable.forget()))) {
+  if (NS_FAILED(DispatchToMain(runnable.forget()))) {
     NS_WARNING("failed to dispatch executor flush event");
   }
 }
 
 void
 nsHtml5StreamParser::ParseAvailableData()
 {
   NS_ASSERTION(IsParserThread(), "Wrong thread!");
@@ -1409,17 +1409,17 @@ nsHtml5StreamParser::ParseAvailableData(
             }
             mTreeBuilder->FlushLoads();
             {
               // Dispatch this runnable unconditionally, because the loads
               // that need flushing may have been flushed earlier even if the
               // flush right above here did nothing.
               nsCOMPtr<nsIRunnable> runnable(mLoadFlusher);
               if (NS_FAILED(
-                    DispatchToMain("nsHtml5LoadFlusher", runnable.forget()))) {
+                    DispatchToMain(runnable.forget()))) {
                 NS_WARNING("failed to dispatch load flush event");
               }
             }
             return; // no more data for now but expecting more
           case STREAM_ENDED:
             if (mAtEOF) {
               return;
             }
@@ -1752,27 +1752,27 @@ nsHtml5StreamParser::TimerFlush()
     return;
   }
 
   if (mMode == VIEW_SOURCE_HTML || mMode == VIEW_SOURCE_XML) {
     mTreeBuilder->Flush(); // delete useless ops
     if (mTokenizer->FlushViewSource()) {
       nsCOMPtr<nsIRunnable> runnable(mExecutorFlusher);
       if (NS_FAILED(
-            DispatchToMain("nsHtml5ExecutorFlusher", runnable.forget()))) {
+            DispatchToMain(runnable.forget()))) {
         NS_WARNING("failed to dispatch executor flush event");
       }
     }
   } else {
     // we aren't speculating and we don't know when new data is
     // going to arrive. Send data to the main thread.
     if (mTreeBuilder->Flush(true)) {
       nsCOMPtr<nsIRunnable> runnable(mExecutorFlusher);
       if (NS_FAILED(
-            DispatchToMain("nsHtml5ExecutorFlusher", runnable.forget()))) {
+            DispatchToMain(runnable.forget()))) {
         NS_WARNING("failed to dispatch executor flush event");
       }
     }
   }
 }
 
 void
 nsHtml5StreamParser::MarkAsBroken(nsresult aRv)
@@ -1780,24 +1780,21 @@ nsHtml5StreamParser::MarkAsBroken(nsresu
   NS_ASSERTION(IsParserThread(), "Wrong thread!");
   mTokenizerMutex.AssertCurrentThreadOwns();
 
   Terminate();
   mTreeBuilder->MarkAsBroken(aRv);
   mozilla::DebugOnly<bool> hadOps = mTreeBuilder->Flush(false);
   NS_ASSERTION(hadOps, "Should have had the markAsBroken op!");
   nsCOMPtr<nsIRunnable> runnable(mExecutorFlusher);
-  if (NS_FAILED(DispatchToMain("nsHtml5ExecutorFlusher", runnable.forget()))) {
+  if (NS_FAILED(DispatchToMain(runnable.forget()))) {
     NS_WARNING("failed to dispatch executor flush event");
   }
 }
 
 nsresult
-nsHtml5StreamParser::DispatchToMain(const char* aName,
-                                    already_AddRefed<nsIRunnable>&& aRunnable)
+nsHtml5StreamParser::DispatchToMain(already_AddRefed<nsIRunnable>&& aRunnable)
 {
-  nsCOMPtr<nsIRunnable> runnable(aRunnable);
   if (mDocGroup) {
-    return mDocGroup->Dispatch(aName, TaskCategory::Network, runnable.forget());
+    return mDocGroup->Dispatch(TaskCategory::Network, Move(aRunnable));
   }
-  return SchedulerGroup::UnlabeledDispatch(
-    aName, TaskCategory::Network, runnable.forget());
+  return SchedulerGroup::UnlabeledDispatch(TaskCategory::Network, Move(aRunnable));
 }
diff --git a/parser/html/nsHtml5StreamParser.h b/parser/html/nsHtml5StreamParser.h
--- a/parser/html/nsHtml5StreamParser.h
+++ b/parser/html/nsHtml5StreamParser.h
@@ -385,18 +385,17 @@ public:
     {
         return mSpeculationFailureCount < 100;
     }
 
     /**
      * Dispatch an event to a Quantum DOM main thread-ish thread.
      * (Not the parser thread.)
      */
-    nsresult DispatchToMain(const char* aName,
-                            already_AddRefed<nsIRunnable>&& aRunnable);
+    nsresult DispatchToMain(already_AddRefed<nsIRunnable>&& aRunnable);
 
     nsCOMPtr<nsIRequest>          mRequest;
     nsCOMPtr<nsIRequestObserver>  mObserver;
 
     /**
      * The document title to use if this turns out to be a View Source parser.
      */
     nsCString                     mViewSourceTitle;
diff --git a/parser/html/nsHtml5StreamParserPtr.h b/parser/html/nsHtml5StreamParserPtr.h
--- a/parser/html/nsHtml5StreamParserPtr.h
+++ b/parser/html/nsHtml5StreamParserPtr.h
@@ -47,18 +47,17 @@ private:
     nsHtml5StreamParser* oldPtr = mRawPtr;
     mRawPtr = newPtr;
     if (oldPtr)
       release(oldPtr);
   }
   void release(nsHtml5StreamParser* aPtr)
   {
     nsCOMPtr<nsIRunnable> releaser = new nsHtml5StreamParserReleaser(aPtr);
-    if (NS_FAILED(aPtr->DispatchToMain("nsHtml5StreamParserReleaser",
-                                       releaser.forget()))) {
+    if (NS_FAILED(aPtr->DispatchToMain(releaser.forget()))) {
       NS_WARNING("Failed to dispatch releaser event.");
     }
   }
 
 private:
   nsHtml5StreamParser* mRawPtr;
 
 public:
diff --git a/parser/html/nsHtml5TreeOpExecutor.cpp b/parser/html/nsHtml5TreeOpExecutor.cpp
--- a/parser/html/nsHtml5TreeOpExecutor.cpp
+++ b/parser/html/nsHtml5TreeOpExecutor.cpp
@@ -237,18 +237,17 @@ nsHtml5TreeOpExecutor::MarkAsBroken(nsre
     mStreamParser->Terminate();
   }
   // We are under memory pressure, but let's hope the following allocation
   // works out so that we get to terminate and clean up the parser from
   // a safer point.
   if (mParser && mDocument) { // can mParser ever be null here?
     nsCOMPtr<nsIRunnable> terminator =
       NewRunnableMethod("nsHtml5Parser::Terminate", GetParser(), &nsHtml5Parser::Terminate);
-    if (NS_FAILED(mDocument->Dispatch("nsHtml5Parser::Terminate",
-                                      TaskCategory::Network,
+    if (NS_FAILED(mDocument->Dispatch(TaskCategory::Network,
                                       terminator.forget()))) {
       NS_WARNING("failed to dispatch executor flush event");
     }
   }
   return aReason;
 }
 
 void
@@ -266,18 +265,17 @@ FlushTimerCallback(nsITimer* aTimer, voi
   }
 }
 
 void
 nsHtml5TreeOpExecutor::ContinueInterruptedParsingAsync()
 {
   if (!mDocument || !mDocument->IsInBackgroundWindow()) {
     nsCOMPtr<nsIRunnable> flusher = new nsHtml5ExecutorReflusher(this);
-    if (NS_FAILED(mDocument->Dispatch("nsHtml5ExecutorReflusher",
-                                      TaskCategory::Network,
+    if (NS_FAILED(mDocument->Dispatch(TaskCategory::Network,
                                       flusher.forget()))) {
       NS_WARNING("failed to dispatch executor flush event");
     }
   } else {
     if (!gBackgroundFlushList) {
       gBackgroundFlushList = new mozilla::LinkedList<nsHtml5TreeOpExecutor>();
     }
     if (!isInList()) {
diff --git a/parser/html/nsHtml5TreeOperation.cpp b/parser/html/nsHtml5TreeOperation.cpp
--- a/parser/html/nsHtml5TreeOperation.cpp
+++ b/parser/html/nsHtml5TreeOperation.cpp
@@ -592,17 +592,17 @@ nsHtml5TreeOperation::DoneCreatingElemen
   aNode->DoneCreatingElement();
 }
 
 void
 nsHtml5TreeOperation::SvgLoad(nsIContent* aNode)
 {
   nsCOMPtr<nsIRunnable> event = new nsHtml5SVGLoadDispatcher(aNode);
   if (NS_FAILED(aNode->OwnerDoc()->Dispatch(
-        "nsHtml5SVGLoadDispatcher", TaskCategory::Network, event.forget()))) {
+        TaskCategory::Network, event.forget()))) {
     NS_WARNING("failed to dispatch svg load dispatcher");
   }
 }
 
 void
 nsHtml5TreeOperation::MarkMalformedIfScript(nsIContent* aNode)
 {
   nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(aNode);
diff --git a/parser/htmlparser/tests/mochitest/test_compatmode.html b/parser/htmlparser/tests/mochitest/test_compatmode.html
--- a/parser/htmlparser/tests/mochitest/test_compatmode.html
+++ b/parser/htmlparser/tests/mochitest/test_compatmode.html
@@ -47,42 +47,49 @@ var doctypes = [
 'BackCompat' , '<!DOCTYPEz HTML PUBLIC "-//IETF//DTD HTML 3.2//en">',
 'BackCompat' , '<!DOCTYPE HTMLz PUBLIC "DTD HTML 3.2">',
 'BackCompat' , '<!DOCTYPE "DTD HTML 3.2">',
 /* end from bug 363883 */
 // from bug 502600
 'BackCompat' , '<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">',
 ];
 
-function test(mode,i){
+window.addEventListener("message", verifyResult);
+
+function verifyResult(event) {
+  let i = event.data.index;
+  let curFrame = document.getElementById("test" + i);
+  let mode = SpecialPowers.wrap(curFrame).contentDocument.compatMode;
   is(mode,doctypes[i],doctypes[i+1]);
   if (i == doctypes.length - 2) {
+    window.removeEventListener("message", verifyResult);
     SimpleTest.finish();
   }
 }
 
 ////
 // Insert a hidden iframe into the document, with the src 
 // containing the test doctype.  The iframe's onload
 // function is set to call the test's verification step.
 //
-function insert_iframe(doctype,expected) {
+function insert_iframe(index, doctype) {
   var elm = document.createElement('iframe');
+  elm.setAttribute("id", "test" + index);
   elm.setAttribute('src', 'data:text/html,' + doctype +
-    '<html><body onload="parent.test(document.compatMode,'+i+')"></body>');
+    '<html><body onload="parent.postMessage({index:'+index+'},\'*\');"></body>');
   elm.setAttribute('style', 'display:none');
   document.getElementsByTagName('body')[0].appendChild(elm);
 }
 
 ////
 // Iterate over the tests
 //
 function doTest() {
   for (i=0; i < doctypes.length; i+=2) {
-    insert_iframe(doctypes[i+1],doctypes[i]);
+    insert_iframe(i,doctypes[i+1]);
   }
 }
 
 ////
 // Run the compatbility mode tests.
 //
 SimpleTest.waitForExplicitFinish();
 doTest();
diff --git a/security/sandbox/linux/Sandbox.cpp b/security/sandbox/linux/Sandbox.cpp
--- a/security/sandbox/linux/Sandbox.cpp
+++ b/security/sandbox/linux/Sandbox.cpp
@@ -560,40 +560,29 @@ SandboxEarlyInit(GeckoProcessType aType)
   bool canChroot = false;
   bool canUnshareNet = false;
   bool canUnshareIPC = false;
 
   switch (aType) {
   case GeckoProcessType_Default:
     MOZ_ASSERT(false, "SandboxEarlyInit in parent process");
     return;
-
 #ifdef MOZ_GMP_SANDBOX
   case GeckoProcessType_GMPlugin:
     if (!info.Test(SandboxInfo::kEnabledForMedia)) {
       break;
     }
     canUnshareNet = true;
     canUnshareIPC = true;
     // Need seccomp-bpf to intercept open().
     canChroot = info.Test(SandboxInfo::kHasSeccompBPF);
     break;
 #endif
-
-#ifdef MOZ_CONTENT_SANDBOX
-  case GeckoProcessType_Content:
-    if (!info.Test(SandboxInfo::kEnabledForContent)) {
-      break;
-    }
-#ifndef MOZ_ALSA
-    canUnshareIPC = true;
-#endif
-    break;
-#endif
-
+    // In the future, content processes will be able to use some of
+    // these.
   default:
     // Other cases intentionally left blank.
     break;
   }
 
   // If TSYNC is not supported, set up signal handler
   // used to enable seccomp on each thread.
   if (!info.Test(SandboxInfo::kHasSeccompTSync)) {
diff --git a/security/sandbox/linux/SandboxFilter.cpp b/security/sandbox/linux/SandboxFilter.cpp
--- a/security/sandbox/linux/SandboxFilter.cpp
+++ b/security/sandbox/linux/SandboxFilter.cpp
@@ -563,24 +563,29 @@ public:
     default:
       return SandboxPolicyCommon::EvaluateSocketCall(aCall);
     }
   }
 
 #ifdef DESKTOP
   Maybe<ResultExpr> EvaluateIpcCall(int aCall) const override {
     switch(aCall) {
-      // SysV IPC is a problem: it follows the Unix "same uid policy"
-      // and can't be restricted/brokered like file access.
-#ifdef MOZ_ALSA
+      // These are a problem: SysV shared memory follows the Unix
+      // "same uid policy" and can't be restricted/brokered like file
+      // access.  But the graphics layer might not be using them
+      // anymore; this needs to be studied.
+    case SHMGET:
+    case SHMCTL:
+    case SHMAT:
+    case SHMDT:
     case SEMGET:
     case SEMCTL:
     case SEMOP:
+    case MSGGET:
       return Some(Allow());
-#endif
     default:
       return SandboxPolicyCommon::EvaluateIpcCall(aCall);
     }
   }
 #endif
 
   ResultExpr EvaluateSyscall(int sysno) const override {
     // Straight allow for anything that got overriden via prefs
diff --git a/storage/test/gtest/test_deadlock_detector.cpp b/storage/test/gtest/test_deadlock_detector.cpp
--- a/storage/test/gtest/test_deadlock_detector.cpp
+++ b/storage/test/gtest/test_deadlock_detector.cpp
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Note: This file is essentially a copy of
 // xpcom/tests/gtest/TestDeadlockDetector.cpp, but all mutexes were turned into
 // SQLiteMutexes. We use #include and some macros to avoid actual source code
 // duplication.
 
 #include "mozilla/CondVar.h"
+#include "mozilla/RecursiveMutex.h"
 #include "mozilla/ReentrantMonitor.h"
 #include "SQLiteMutex.h"
 
 #include "gtest/gtest.h"
 
 using namespace mozilla;
 
 /**
diff --git a/testing/awsy/awsy/process_perf_data.py b/testing/awsy/awsy/process_perf_data.py
--- a/testing/awsy/awsy/process_perf_data.py
+++ b/testing/awsy/awsy/process_perf_data.py
@@ -12,16 +12,17 @@ import parse_about_memory
 
 # A description of each checkpoint and the root path to it.
 CHECKPOINTS = [
     { 'name': "Fresh start", 'path': "memory-report-Start-0.json.gz" },
     { 'name': "Fresh start [+30s]", 'path': "memory-report-StartSettled-0.json.gz" },
     { 'name': "After tabs open", 'path': "memory-report-TabsOpen-4.json.gz" },
     { 'name': "After tabs open [+30s]", 'path': "memory-report-TabsOpenSettled-4.json.gz" },
     { 'name': "After tabs open [+30s, forced GC]", 'path': "memory-report-TabsOpenForceGC-4.json.gz" },
+    { 'name': "Tabs closed extra processes", 'path': "memory-report-TabsClosedExtraProcesses-4.json.gz" },
     { 'name': "Tabs closed", 'path': "memory-report-TabsClosed-4.json.gz" },
     { 'name': "Tabs closed [+30s]", 'path': "memory-report-TabsClosedSettled-4.json.gz" },
     { 'name': "Tabs closed [+30s, forced GC]", 'path': "memory-report-TabsClosedForceGC-4.json.gz" }
 ]
 
 # A description of each perfherder suite and the path to its values.
 PERF_SUITES = [
     { 'name': "Resident Memory", 'node': "resident" },
@@ -36,16 +37,17 @@ def update_checkpoint_paths(checkpoint_f
     Updates CHECKPOINTS with memory report file fetched in data_path
     :param checkpoint_files: list of files in data_path
     """
     target_path = [['Start-', 0],
                       ['StartSettled-', 0],
                       ['TabsOpen-', -1],
                       ['TabsOpenSettled-', -1],
                       ['TabsOpenForceGC-', -1],
+                      ['TabsClosedExtraProcesses-', -1],
                       ['TabsClosed-', -1],
                       ['TabsClosedSettled-', -1],
                       ['TabsClosedForceGC-', -1]]
     for i in range(len(target_path)):
         (name, idx) = target_path[i]
         paths = sorted([x for x in checkpoint_files if name in x])
         CHECKPOINTS[i]['path'] = paths[idx]
 
diff --git a/testing/awsy/awsy/test_memory_usage.py b/testing/awsy/awsy/test_memory_usage.py
--- a/testing/awsy/awsy/test_memory_usage.py
+++ b/testing/awsy/awsy/test_memory_usage.py
@@ -121,16 +121,44 @@ class TestMemoryUsage(MarionetteTestCase
                 self.logger.error("gBrowser.removeCurrentTab() Unexpected error: %s" % sys.exc_info()[0])
             else:
                 self.logger.info(result)
             time.sleep(0.25)
 
         self._tabs = self.marionette.window_handles
         self.marionette.switch_to_window(self._tabs[0])
 
+    def clear_preloaded_browser(self):
+        """
+        Clears out the preloaded browser.
+
+        Note: Does nothing on older builds that don't have a
+              `gBrowser.removePreloadedBrowser` method.
+        """
+        self.logger.info("closing preloaded browser")
+        script = """
+            if ("removePreloadedBrowser" in gBrowser) {
+                return gBrowser.removePreloadedBrowser();
+            } else {
+                return "gBrowser.removePreloadedBrowser not available";
+            }
+            """
+        try:
+            result = self.marionette.execute_script(script,
+                                                    script_timeout=180000)
+        except JavascriptException, e:
+            self.logger.error("gBrowser.removePreloadedBrowser() JavaScript error: %s" % e)
+        except ScriptTimeoutException:
+            self.logger.error("gBrowser.removePreloadedBrowser() timed out")
+        except:
+            self.logger.error("gBrowser.removePreloadedBrowser() Unexpected error: %s" % sys.exc_info()[0])
+        else:
+            if result:
+              self.logger.info(result)
+
     def do_full_gc(self):
         """Performs a full garbage collection cycle and returns when it is finished.
 
         Returns True on success and False on failure.
         """
         # NB: we could do this w/ a signal or the fifo queue too
         self.logger.info("starting gc...")
         gc_script = """
@@ -337,16 +365,23 @@ class TestMemoryUsage(MarionetteTestCase
             self.marionette.switch_to_window(self._tabs[0])
             self.logger.info("switched to first window")
             with self.marionette.using_context('content'):
                 self.logger.info("navigating to about:blank")
                 self.marionette.navigate("about:blank")
                 self.logger.info("navigated to about:blank")
             self.signal_user_active()
 
+            # Create checkpoint that may contain retained processes that will
+            # be reused.
+            create_checkpoint("TabsClosedExtraProcesses", itr)
+
+            # Clear out the retained processes and measure again.
+            self.clear_preloaded_browser()
+
             create_checkpoint("TabsClosed", itr)
             time.sleep(self._settleWaitTime)
             create_checkpoint("TabsClosedSettled", itr)
             self.assertTrue(self.do_full_gc(), "GC ran")
             create_checkpoint("TabsClosedForceGC", itr)
 
         # TODO(ER): Temporary hack until bug 1121139 lands
         self.logger.info("setting results")
diff --git a/testing/mozharness/configs/releases/dev_postrelease_firefox_beta.py b/testing/mozharness/configs/releases/dev_postrelease_firefox_beta.py
--- a/testing/mozharness/configs/releases/dev_postrelease_firefox_beta.py
+++ b/testing/mozharness/configs/releases/dev_postrelease_firefox_beta.py
@@ -11,10 +11,10 @@ config = {
         "clone_upstream_url": "https://hg.mozilla.org/mozilla-unified",
     },
     # date is used for staging mozilla-beta
     "push_dest": "ssh://hg.mozilla.org/projects/date",
     "ignore_no_changes": True,
     "ssh_user": "ffxbld",
     "ssh_key": "~/.ssh/ffxbld_rsa",
     "ship_it_root": "https://ship-it-dev.allizom.org",
-    "ship_it_username":  "stage-ffxbld",
+    "ship_it_username":  "ship_it-stage-ffxbld",
 }
diff --git a/testing/mozharness/configs/releases/dev_postrelease_firefox_release.py b/testing/mozharness/configs/releases/dev_postrelease_firefox_release.py
--- a/testing/mozharness/configs/releases/dev_postrelease_firefox_release.py
+++ b/testing/mozharness/configs/releases/dev_postrelease_firefox_release.py
@@ -13,10 +13,10 @@ config = {
         "vcs": "hg",
         "clone_upstream_url": "https://hg.mozilla.org/mozilla-unified",
     },
     "push_dest": "ssh://hg.mozilla.org/projects/jamun",
     "ignore_no_changes": True,
     "ssh_user": "ffxbld",
     "ssh_key": "~/.ssh/ffxbld_rsa",
     "ship_it_root": "https://ship-it-dev.allizom.org",
-    "ship_it_username":  "stage-ffxbld",
+    "ship_it_username":  "ship_it-stage-ffxbld",
 }
diff --git a/testing/mozharness/configs/releases/postrelease_firefox_beta.py b/testing/mozharness/configs/releases/postrelease_firefox_beta.py
--- a/testing/mozharness/configs/releases/postrelease_firefox_beta.py
+++ b/testing/mozharness/configs/releases/postrelease_firefox_beta.py
@@ -9,10 +9,10 @@ config = {
         "clone_upstream_url": "https://hg.mozilla.org/mozilla-unified",
     },
     "vcs_share_base": "/builds/hg-shared",
     "push_dest": "ssh://hg.mozilla.org/releases/mozilla-beta",
     "ignore_no_changes": True,
     "ssh_user": "ffxbld",
     "ssh_key": "~/.ssh/ffxbld_rsa",
     "ship_it_root": "https://ship-it.mozilla.org",
-    "ship_it_username":  "ffxbld",
+    "ship_it_username":  "ship_it-ffxbld",
 }
diff --git a/testing/mozharness/configs/releases/postrelease_firefox_esr52.py b/testing/mozharness/configs/releases/postrelease_firefox_esr52.py
--- a/testing/mozharness/configs/releases/postrelease_firefox_esr52.py
+++ b/testing/mozharness/configs/releases/postrelease_firefox_esr52.py
@@ -13,10 +13,10 @@ config = {
         "clone_upstream_url": "https://hg.mozilla.org/mozilla-unified",
     },
     "vcs_share_base": "/builds/hg-shared",
     "push_dest": "ssh://hg.mozilla.org/releases/mozilla-esr52",
     "ignore_no_changes": True,
     "ssh_user": "ffxbld",
     "ssh_key": "~/.ssh/ffxbld_rsa",
     "ship_it_root": "https://ship-it.mozilla.org",
-    "ship_it_username":  "ffxbld",
+    "ship_it_username":  "ship_it-ffxbld",
 }
diff --git a/testing/mozharness/configs/releases/postrelease_firefox_release.py b/testing/mozharness/configs/releases/postrelease_firefox_release.py
--- a/testing/mozharness/configs/releases/postrelease_firefox_release.py
+++ b/testing/mozharness/configs/releases/postrelease_firefox_release.py
@@ -13,10 +13,10 @@ config = {
         "clone_upstream_url": "https://hg.mozilla.org/mozilla-unified",
     },
     "vcs_share_base": "/builds/hg-shared",
     "push_dest": "ssh://hg.mozilla.org/releases/mozilla-release",
     "ignore_no_changes": True,
     "ssh_user": "ffxbld",
     "ssh_key": "~/.ssh/ffxbld_rsa",
     "ship_it_root": "https://ship-it.mozilla.org",
-    "ship_it_username":  "ffxbld",
+    "ship_it_username":  "ship_it-ffxbld",
 }
diff --git a/testing/profiles/prefs_general.js b/testing/profiles/prefs_general.js
--- a/testing/profiles/prefs_general.js
+++ b/testing/profiles/prefs_general.js
@@ -246,19 +246,25 @@ user_pref("browser.contentHandlers.types
 user_pref("browser.contentHandlers.types.1.uri", "http://test1.example.org/rss?url=%%s")
 user_pref("browser.contentHandlers.types.2.uri", "http://test1.example.org/rss?url=%%s")
 user_pref("browser.contentHandlers.types.3.uri", "http://test1.example.org/rss?url=%%s")
 user_pref("browser.contentHandlers.types.4.uri", "http://test1.example.org/rss?url=%%s")
 user_pref("browser.contentHandlers.types.5.uri", "http://test1.example.org/rss?url=%%s")
 
 // We want to collect telemetry, but we don't want to send in the results.
 user_pref("toolkit.telemetry.server", "https://%(server)s/telemetry-dummy/");
-// Don't new-profile' ping on new profiles during tests, otherwise the testing framework
+// Don't send 'new-profile' ping on new profiles during tests, otherwise the testing framework
 // might wait on the pingsender to finish and slow down tests.
 user_pref("toolkit.telemetry.newProfilePing.enabled", false);
+// Don't send the 'shutdown' ping using the pingsender on the first session using
+// the 'pingsender' process. Valgrind marks the process as leaky (e.g. see bug 1364068
+// for the 'new-profile' ping) but does not provide enough information
+// to suppress the leak. Running locally does not reproduce the issue,
+// so disable this until we rewrite the pingsender in Rust (bug 1339035).
+user_pref("toolkit.telemetry.shutdownPingSender.enabledFirstSession", false);
 
 // A couple of preferences with default values to test that telemetry preference
 // watching is working.
 user_pref("toolkit.telemetry.test.pref1", true);
 user_pref("toolkit.telemetry.test.pref2", false);
 
 // We don't want to hit the real Firefox Accounts server for tests.  We don't
 // actually need a functioning FxA server, so just set it to something that
diff --git a/testing/web-platform/meta/page-visibility/idlharness.html.ini b/testing/web-platform/meta/page-visibility/idlharness.html.ini
--- a/testing/web-platform/meta/page-visibility/idlharness.html.ini
+++ b/testing/web-platform/meta/page-visibility/idlharness.html.ini
@@ -1,14 +1,7 @@
 [idlharness.html]
   type: testharness
   [Document must be primary interface of window.document]
     expected: FAIL
 
   [Stringification of window.document]
     expected: FAIL
-
-  [Document interface: attribute onvisibilitychange]
-    expected: FAIL
-
-  [Document interface: window.document must inherit property "onvisibilitychange" with the proper type (2)]
-    expected: FAIL
-
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-1.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-1.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-1.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-10.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-10.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-10.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-10.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-11.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-11.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-11.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-11.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-12.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-12.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-12.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-12.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-13.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-13.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-13.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-13.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-8-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-14-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-14-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-14-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-14-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .test { page-break-before:always; height:1.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-14.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-14.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-14.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-14.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-14-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-15-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-15-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-15-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-15-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .test { page-break-before:always; height:2.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-15.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-15.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-15.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-15.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-15-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-2.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-2.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-2.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-3.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-3.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-3.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-4.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-4.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-4.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-4.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-5.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-5.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-5.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-5.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-6.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-6.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-6.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-6.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-7.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-7.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-7.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-7.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-8-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-8-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-8-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-8-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-8.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-8.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-8.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-8.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-8-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-9.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-9.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-9.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-9.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-block-page-break-inside-avoid-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .test { page-break-after:always; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-1.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-1.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-1.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-2-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-2-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-2-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-2-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .test { float:left; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-2.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-2.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-2.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-2-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-3.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-3.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-3.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-4.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-4.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-4.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-4.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-block-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-5-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-5-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-5-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-5-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
         html,body {
             color:black; background-color:white; font-size:16px; padding:0; margin:0;
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-5.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-5.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-5.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-5.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-6-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-6-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-6-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-6-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-6.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-6.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-6.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-6.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-6-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-7-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-7-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-7-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-7-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
 }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-7.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-7.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-7.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-7.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-7-ref.html">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-8-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-8-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-8-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-8-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
 }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-8.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-8.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-8.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-8.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-8-ref.html">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-9-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-9-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-9-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-9-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
     color:black; background-color:white; font-size:16px; padding:0; margin:0; height:100%;
 }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-9.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-9.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-9.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-float-page-break-inside-avoid-9.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-float-page-break-inside-avoid-9-ref.html">
   <meta name="flags" content="paged"><style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 html,body {
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-inline-page-break-inside-avoid-1-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-inline-page-break-inside-avoid-1-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-inline-page-break-inside-avoid-1-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-inline-page-break-inside-avoid-1-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-inline-page-break-inside-avoid-1.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-inline-page-break-inside-avoid-1.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-inline-page-break-inside-avoid-1.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-inline-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-inline-page-break-inside-avoid-1-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-row-page-break-inside-avoid-1.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-row-page-break-inside-avoid-1.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-row-page-break-inside-avoid-1.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-row-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-row-page-break-inside-avoid-2.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-row-page-break-inside-avoid-2.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-row-page-break-inside-avoid-2.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-row-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-1.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-1.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-1.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-2.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-2.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-2.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-3.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-3.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-3.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-4.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-4-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 thead { page-break-after:always; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-5.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-6.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-6.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-6.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-6.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 .bb { page-break-before:always; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-7.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-7-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-rowgroup-page-break-inside-avoid-8.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-rowgroup-page-break-inside-avoid-8-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-1.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-1.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-1.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-1.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-2-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-2-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-2-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-2-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-2.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-2.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-2.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-2.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-2-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-3-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-3-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-3-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-3-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-3.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-3.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-3.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-3.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-3-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-4-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-4-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-4-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-4-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 table { display:inline-table; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-4.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-4.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-4.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-4.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-4-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-5-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-5-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-5-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-5-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-5.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-5.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-5.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-5.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-5-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-6-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-6-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-6-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-6-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 </style>
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-6.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-6.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-6.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-6.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-6-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-7-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-7-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-7-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-7-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 div { page-break-after: always; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-7.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-7.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-7.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-7.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-7-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-8.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-8.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-8.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-8.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <link rel="help" href="http://www.w3.org/TR/CSS21/page.html#propdef-page-break-inside">
   <link rel="match" href="moz-css21-table-page-break-inside-avoid-6-ref.html">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-ref.html b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-ref.html
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-ref.html
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/css21/pagination/moz-css21-table-page-break-inside-avoid-ref.html
@@ -1,10 +1,10 @@
 <!DOCTYPE html>
-<html lang="en-US" class="reftest-print">
+<html lang="en-US" class="reftest-paged">
 <head>
   <title>CSS Test: CSS 2.1 page-break-inside:avoid</title>
   <link rel="author" title="Mats Palmgren" href="https://bugzilla.mozilla.org/show_bug.cgi?id=685012">
   <meta name="flags" content="paged">
 <style type="text/css">
 @page { size:5in 3in; margin:0.5in; }
 p { height: 1in; width: 1in; margin:0; background-color:blue; }
 
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/multicol3/multicol-height-002.xht b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/multicol3/multicol-height-002.xht
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/multicol3/multicol-height-002.xht
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/multicol3/multicol-height-002.xht
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml">
- <head class="reftest-print">
+ <head class="reftest-paged">
   <title>CSS Test: Percentage Computed Height on Multicol Child (Definite Multicol Height)</title>
   <link rel="author" title="Elika J. Etemad" href="http://fantasai.inkedblade.net/contact" />
   <link rel="help" href="http://www.w3.org/TR/css3-multicol/#the-multi-column-model" />
   <link rel="help" href="http://www.w3.org/TR/CSS21/visudet.html#the-height-property"/>
   <meta name="flags" content="" />
   <meta name="assert" content="Percentage heights with a multi-column element are relative to the computed height of the multicolumn box, and this works even when the multi-column element is paginated." />
   <link rel="match" href="reference/multicol-height-002.xht" />
   <style type="text/css"><![CDATA[
diff --git a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/multicol3/reference/multicol-height-002.xht b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/multicol3/reference/multicol-height-002.xht
--- a/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/multicol3/reference/multicol-height-002.xht
+++ b/testing/web-platform/tests/css/vendor-imports/mozilla/mozilla-central-reftests/multicol3/reference/multicol-height-002.xht
@@ -1,11 +1,11 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml">
- <head class="reftest-print">
+ <head class="reftest-paged">
   <title>CSS Reftest Reference</title>
   <link rel="author" title="Elika J. Etemad" href="http://fantasai.inkedblade.net/contact" />
   <style type="text/css"><![CDATA[
     html, body { height: 100%; }
     * { margin: 0; }
     div {
       border: double blue 12px;
       height: 150%;
diff --git a/testing/web-platform/tests/page-visibility/idlharness.html b/testing/web-platform/tests/page-visibility/idlharness.html
--- a/testing/web-platform/tests/page-visibility/idlharness.html
+++ b/testing/web-platform/tests/page-visibility/idlharness.html
@@ -1,26 +1,30 @@
 <!DOCTYPE html>
 <html>
 <head>
 <meta charset="utf-8">
 <title>Page Visibility IDL tests</title>
 <link rel="author" title="W3C" href="http://www.w3.org/" />
-<link rel="help" href="http://www.w3.org/TR/page-visibility/#sec-document-interface"/>
+<link rel="help" href="https://w3c.github.io/page-visibility/"/>
 <script src="/resources/testharness.js"></script>
 <script src="/resources/testharnessreport.js"></script>
 <script src="/resources/WebIDLParser.js"></script>
 <script src="/resources/idlharness.js"></script>
 </head>
 <body>
 <h1>Page Visibility IDL tests</h1>
 
 <pre id='untested_idl' style='display:none'>
 interface Document {
 };
+
+[TreatNonObjectAsNull]
+callback EventHandlerNonNull = any (Event event);
+typedef EventHandlerNonNull? EventHandler;
 </pre>
 
 <pre id='idl'>
 enum VisibilityState {
     "hidden",
     "visible",
     "prerender"
 };
diff --git a/toolkit/components/alerts/AlertNotification.cpp b/toolkit/components/alerts/AlertNotification.cpp
--- a/toolkit/components/alerts/AlertNotification.cpp
+++ b/toolkit/components/alerts/AlertNotification.cpp
@@ -190,16 +190,17 @@ AlertNotification::LoadImage(uint32_t aT
 
 NS_IMPL_CYCLE_COLLECTION(AlertImageRequest, mURI, mPrincipal, mListener,
                          mUserData)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(AlertImageRequest)
   NS_INTERFACE_MAP_ENTRY(imgINotificationObserver)
   NS_INTERFACE_MAP_ENTRY(nsICancelable)
   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
+  NS_INTERFACE_MAP_ENTRY(nsINamed)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, imgINotificationObserver)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(AlertImageRequest)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(AlertImageRequest)
 
 AlertImageRequest::AlertImageRequest(nsIURI* aURI, nsIPrincipal* aPrincipal,
                                      bool aInPrivateBrowsing, uint32_t aTimeout,
@@ -265,16 +266,23 @@ AlertImageRequest::Notify(imgIRequest* a
 NS_IMETHODIMP
 AlertImageRequest::Notify(nsITimer* aTimer)
 {
   MOZ_ASSERT(aTimer == mTimer);
   return NotifyMissing();
 }
 
 NS_IMETHODIMP
+AlertImageRequest::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("AlertImageRequest");
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 AlertImageRequest::Cancel(nsresult aReason)
 {
   if (mRequest) {
     mRequest->Cancel(aReason);
   }
   // We call `NotifyMissing` here because we won't receive a `LOAD_COMPLETE`
   // notification if we cancel the request before it loads (bug 1233086,
   // comment 33). Once that's fixed, `nsIAlertNotification::loadImage` could
diff --git a/toolkit/components/alerts/AlertNotification.h b/toolkit/components/alerts/AlertNotification.h
--- a/toolkit/components/alerts/AlertNotification.h
+++ b/toolkit/components/alerts/AlertNotification.h
@@ -5,33 +5,36 @@
 #ifndef mozilla_AlertNotification_h__
 #define mozilla_AlertNotification_h__
 
 #include "imgINotificationObserver.h"
 #include "nsIAlertsService.h"
 #include "nsCOMPtr.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsICancelable.h"
+#include "nsINamed.h"
 #include "nsIPrincipal.h"
 #include "nsString.h"
 #include "nsITimer.h"
 
 namespace mozilla {
 
 class AlertImageRequest final : public imgINotificationObserver,
                                 public nsICancelable,
-                                public nsITimerCallback
+                                public nsITimerCallback,
+                                public nsINamed
 {
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(AlertImageRequest,
                                            imgINotificationObserver)
   NS_DECL_IMGINOTIFICATIONOBSERVER
   NS_DECL_NSICANCELABLE
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   AlertImageRequest(nsIURI* aURI, nsIPrincipal* aPrincipal,
                     bool aInPrivateBrowsing, uint32_t aTimeout,
                     nsIAlertNotificationImageListener* aListener,
                     nsISupports* aUserData);
 
   nsresult Start();
 
diff --git a/toolkit/components/autocomplete/nsAutoCompleteController.cpp b/toolkit/components/autocomplete/nsAutoCompleteController.cpp
--- a/toolkit/components/autocomplete/nsAutoCompleteController.cpp
+++ b/toolkit/components/autocomplete/nsAutoCompleteController.cpp
@@ -50,17 +50,18 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSearches)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mResults)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsAutoCompleteController)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsAutoCompleteController)
 NS_INTERFACE_TABLE_HEAD(nsAutoCompleteController)
   NS_INTERFACE_TABLE(nsAutoCompleteController, nsIAutoCompleteController,
-                     nsIAutoCompleteObserver, nsITimerCallback, nsITreeView)
+                     nsIAutoCompleteObserver, nsITimerCallback, nsITreeView,
+                     nsINamed)
   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsAutoCompleteController)
 NS_INTERFACE_MAP_END
 
 nsAutoCompleteController::nsAutoCompleteController() :
   mDefaultIndexCompleted(false),
   mPopupClosedByCompositionStart(false),
   mProhibitAutoFill(false),
   mUserClearedAutoFill(false),
@@ -919,16 +920,26 @@ nsAutoCompleteController::Notify(nsITime
       return rv;
   }
   StartSearch(nsIAutoCompleteSearchDescriptor::SEARCH_TYPE_DELAYED);
   AfterSearches();
   return NS_OK;
 }
 
 ////////////////////////////////////////////////////////////////////////
+//// nsINamed
+
+NS_IMETHODIMP
+nsAutoCompleteController::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsAutoCompleteController");
+  return NS_OK;
+}
+
+////////////////////////////////////////////////////////////////////////
 // nsITreeView
 
 NS_IMETHODIMP
 nsAutoCompleteController::GetRowCount(int32_t *aRowCount)
 {
   *aRowCount = mRowCount;
   return NS_OK;
 }
diff --git a/toolkit/components/autocomplete/nsAutoCompleteController.h b/toolkit/components/autocomplete/nsAutoCompleteController.h
--- a/toolkit/components/autocomplete/nsAutoCompleteController.h
+++ b/toolkit/components/autocomplete/nsAutoCompleteController.h
@@ -7,37 +7,40 @@
 
 #include "nsIAutoCompleteController.h"
 
 #include "nsCOMPtr.h"
 #include "nsIAutoCompleteInput.h"
 #include "nsIAutoCompletePopup.h"
 #include "nsIAutoCompleteResult.h"
 #include "nsIAutoCompleteSearch.h"
+#include "nsINamed.h"
 #include "nsString.h"
 #include "nsITreeView.h"
 #include "nsITreeSelection.h"
 #include "nsITimer.h"
 #include "nsTArray.h"
 #include "nsCOMArray.h"
 #include "nsCycleCollectionParticipant.h"
 
 class nsAutoCompleteController final : public nsIAutoCompleteController,
                                        public nsIAutoCompleteObserver,
                                        public nsITimerCallback,
-                                       public nsITreeView
+                                       public nsITreeView,
+                                       public nsINamed
 {
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsAutoCompleteController,
                                            nsIAutoCompleteController)
   NS_DECL_NSIAUTOCOMPLETECONTROLLER
   NS_DECL_NSIAUTOCOMPLETEOBSERVER
   NS_DECL_NSITREEVIEW
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   nsAutoCompleteController();
 
 protected:
   virtual ~nsAutoCompleteController();
 
   nsresult OpenPopup();
   nsresult ClosePopup();
diff --git a/toolkit/components/jsdownloads/src/DownloadCore.jsm b/toolkit/components/jsdownloads/src/DownloadCore.jsm
--- a/toolkit/components/jsdownloads/src/DownloadCore.jsm
+++ b/toolkit/components/jsdownloads/src/DownloadCore.jsm
@@ -1,66 +1,31 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
- * This file includes the following constructors and global objects:
- *
- * Download
- * Represents a single download, with associated state and actions.  This object
- * is transient, though it can be included in a DownloadList so that it can be
- * managed by the user interface and persisted across sessions.
- *
- * DownloadSource
- * Represents the source of a download, for example a document or an URI.
- *
- * DownloadTarget
- * Represents the target of a download, for example a file in the global
- * downloads directory, or a file in the system temporary directory.
- *
- * DownloadError
- * Provides detailed information about a download failure.
- *
- * DownloadSaver
- * Template for an object that actually transfers the data for the download.
- *
- * DownloadCopySaver
- * Saver object that simply copies the entire source file to the target.
- *
- * DownloadLegacySaver
- * Saver object that integrates with the legacy nsITransfer interface.
- *
- * DownloadPDFSaver
- * This DownloadSaver type creates a PDF file from the current document in a
- * given window, specified using the windowRef property of the DownloadSource
- * object associated with the download.
+ * Main implementation of the Downloads API objects. Consumers should get
+ * references to these objects through the "Downloads.jsm" module.
  */
 
 "use strict";
 
 this.EXPORTED_SYMBOLS = [
   "Download",
   "DownloadSource",
   "DownloadTarget",
   "DownloadError",
   "DownloadSaver",
   "DownloadCopySaver",
   "DownloadLegacySaver",
   "DownloadPDFSaver",
 ];
 
-// Globals
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-const Cr = Components.results;
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr } = Components;
 
 Cu.import("resource://gre/modules/Integration.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "FileUtils",
                                   "resource://gre/modules/FileUtils.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "NetUtil",
                                   "resource://gre/modules/NetUtil.jsm");
@@ -133,18 +98,16 @@ function deserializeUnknownProperties(aO
 
 /**
  * This determines the minimum time interval between updates to the number of
  * bytes transferred, and is a limiting factor to the sequence of readings used
  * in calculating the speed of the download.
  */
 const kProgressUpdateIntervalMs = 400;
 
-// Download
-
 /**
  * Represents a single download, with associated state and actions.  This object
  * is transient, though it can be included in a DownloadList so that it can be
  * managed by the user interface and persisted across sessions.
  */
 this.Download = function() {
   this._deferSucceeded = PromiseUtils.defer();
 }
@@ -1220,18 +1183,16 @@ Download.fromSerializable = function(aSe
     property != "source" &&
     property != "target" &&
     property != "error" &&
     property != "saver");
 
   return download;
 };
 
-// DownloadSource
-
 /**
  * Represents the source of a download, for example a document or an URI.
  */
 this.DownloadSource = function() {}
 
 this.DownloadSource.prototype = {
   /**
    * String containing the URI for the download source.
@@ -1345,18 +1306,16 @@ this.DownloadSource.fromSerializable = f
 
     deserializeUnknownProperties(source, aSerializable, property =>
       property != "url" && property != "isPrivate" && property != "referrer");
   }
 
   return source;
 };
 
-// DownloadTarget
-
 /**
  * Represents the target of a download, for example a file in the global
  * downloads directory, or a file in the system temporary directory.
  */
 this.DownloadTarget = function() {}
 
 this.DownloadTarget.prototype = {
   /**
@@ -1472,18 +1431,16 @@ this.DownloadTarget.fromSerializable = f
     }
 
     deserializeUnknownProperties(target, aSerializable, property =>
       property != "path" && property != "partFilePath");
   }
   return target;
 };
 
-// DownloadError
-
 /**
  * Provides detailed information about a download failure.
  *
  * @param aProperties
  *        Object which may contain any of the following properties:
  *          {
  *            result: Result error code, defaulting to Cr.NS_ERROR_FAILURE
  *            message: String error message to be displayed, or null to use the
@@ -1664,18 +1621,16 @@ this.DownloadError.fromSerializable = fu
     property != "becauseBlockedByParentalControls" &&
     property != "becauseBlockedByReputationCheck" &&
     property != "becauseBlockedByRuntimePermissions" &&
     property != "reputationCheckVerdict");
 
   return e;
 };
 
-// DownloadSaver
-
 /**
  * Template for an object that actually transfers the data for the download.
  */
 this.DownloadSaver = function() {}
 
 this.DownloadSaver.prototype = {
   /**
    * Download object for raising notifications and reading properties.
@@ -1814,18 +1769,16 @@ this.DownloadSaver.fromSerializable = fu
       saver = DownloadPDFSaver.fromSerializable(serializable);
       break;
     default:
       throw new Error("Unrecoginzed download saver type.");
   }
   return saver;
 };
 
-// DownloadCopySaver
-
 /**
  * Saver object that simply copies the entire source file to the target.
  */
 this.DownloadCopySaver = function() {}
 
 this.DownloadCopySaver.prototype = {
   __proto__: DownloadSaver.prototype,
 
@@ -2291,18 +2244,16 @@ this.DownloadCopySaver.fromSerializable 
   }
 
   deserializeUnknownProperties(saver, aSerializable, property =>
     property != "entityID" && property != "type");
 
   return saver;
 };
 
-// DownloadLegacySaver
-
 /**
  * Saver object that integrates with the legacy nsITransfer interface.
  *
  * For more background on the process, see the DownloadLegacyTransfer object.
  */
 this.DownloadLegacySaver = function() {
   this.deferExecuted = PromiseUtils.defer();
   this.deferCanceled = PromiseUtils.defer();
@@ -2659,18 +2610,16 @@ this.DownloadLegacySaver.prototype = {
  * Returns a new DownloadLegacySaver object.  This saver type has a
  * deserializable form only when creating a new object in memory, because it
  * cannot be serialized to disk.
  */
 this.DownloadLegacySaver.fromSerializable = function() {
   return new DownloadLegacySaver();
 };
 
-// DownloadPDFSaver
-
 /**
  * This DownloadSaver type creates a PDF file from the current document in a
  * given window, specified using the windowRef property of the DownloadSource
  * object associated with the download.
  *
  * In order to prevent the download from saving a different document than the one
  * originally loaded in the window, any attempt to restart the download will fail.
  *
diff --git a/toolkit/components/jsdownloads/src/DownloadHistory.jsm b/toolkit/components/jsdownloads/src/DownloadHistory.jsm
new file mode 100644
--- /dev/null
+++ b/toolkit/components/jsdownloads/src/DownloadHistory.jsm
@@ -0,0 +1,91 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * Provides access to downloads from previous sessions on platforms that store
+ * them in a different location than session downloads.
+ *
+ * This module works with objects that are compatible with Download, while using
+ * the Places interfaces internally. Some of the Places objects may also be
+ * exposed to allow the consumers to integrate with history view commands.
+ */
+
+"use strict";
+
+this.EXPORTED_SYMBOLS = [
+  "DownloadHistory",
+];
+
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr } = Components;
+
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "PlacesUtils",
+                                  "resource://gre/modules/PlacesUtils.jsm");
+
+const METADATA_ANNO = "downloads/metaData";
+
+const METADATA_STATE_FINISHED = 1;
+const METADATA_STATE_FAILED = 2;
+const METADATA_STATE_CANCELED = 3;
+const METADATA_STATE_BLOCKED_PARENTAL = 6;
+const METADATA_STATE_DIRTY = 8;
+
+/**
+ * Provides methods to retrieve downloads from previous sessions and store
+ * downloads for future sessions.
+ */
+this.DownloadHistory = {
+  /**
+   * Stores new detailed metadata for the given download in history. This is
+   * normally called after a download finishes, fails, or is canceled.
+   *
+   * Failed or canceled downloads with partial data are not stored as paused,
+   * because the information from the session download is required for resuming.
+   *
+   * @param download
+   *        Download object whose metadata should be updated. If the object
+   *        represents a private download, the call has no effect.
+   */
+  updateMetaData(download) {
+    if (download.source.isPrivate || !download.stopped) {
+      return;
+    }
+
+    let state = METADATA_STATE_CANCELED;
+    if (download.succeeded) {
+      state = METADATA_STATE_FINISHED;
+    } else if (download.error) {
+      if (download.error.becauseBlockedByParentalControls) {
+        state = METADATA_STATE_BLOCKED_PARENTAL;
+      } else if (download.error.becauseBlockedByReputationCheck) {
+        state = METADATA_STATE_DIRTY;
+      } else {
+        state = METADATA_STATE_FAILED;
+      }
+    }
+
+    let metaData = { state, endTime: download.endTime };
+    if (download.succeeded) {
+      metaData.fileSize = download.target.size;
+    }
+
+    // The verdict may still be present even if the download succeeded.
+    if (download.error && download.error.reputationCheckVerdict) {
+      metaData.reputationCheckVerdict =
+        download.error.reputationCheckVerdict;
+    }
+
+    try {
+      PlacesUtils.annotations.setPageAnnotation(
+                                 Services.io.newURI(download.source.url),
+                                 METADATA_ANNO,
+                                 JSON.stringify(metaData), 0,
+                                 PlacesUtils.annotations.EXPIRE_WITH_HISTORY);
+    } catch (ex) {
+      Cu.reportError(ex);
+    }
+  },
+};
diff --git a/toolkit/components/jsdownloads/src/DownloadIntegration.jsm b/toolkit/components/jsdownloads/src/DownloadIntegration.jsm
--- a/toolkit/components/jsdownloads/src/DownloadIntegration.jsm
+++ b/toolkit/components/jsdownloads/src/DownloadIntegration.jsm
@@ -1,32 +1,24 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
  * Provides functions to integrate with the host application, handling for
  * example the global prompts on shutdown.
  */
 
 "use strict";
 
 this.EXPORTED_SYMBOLS = [
   "DownloadIntegration",
 ];
 
-////////////////////////////////////////////////////////////////////////////////
-//// Globals
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-const Cr = Components.results;
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr } = Components;
 
 Cu.import("resource://gre/modules/Integration.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "AsyncShutdown",
                                   "resource://gre/modules/AsyncShutdown.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "AppConstants",
                                   "resource://gre/modules/AppConstants.jsm");
@@ -129,19 +121,16 @@ const kVerdictMap = {
   [Ci.nsIApplicationReputationService.VERDICT_UNCOMMON]:
                 Downloads.Error.BLOCK_VERDICT_UNCOMMON,
   [Ci.nsIApplicationReputationService.VERDICT_POTENTIALLY_UNWANTED]:
                 Downloads.Error.BLOCK_VERDICT_POTENTIALLY_UNWANTED,
   [Ci.nsIApplicationReputationService.VERDICT_DANGEROUS_HOST]:
                 Downloads.Error.BLOCK_VERDICT_MALWARE,
 };
 
-////////////////////////////////////////////////////////////////////////////////
-//// DownloadIntegration
-
 /**
  * Provides functions to integrate with the host application, handling for
  * example the global prompts on shutdown.
  */
 this.DownloadIntegration = {
   /**
    * Main DownloadStore object for loading and saving the list of persistent
    * downloads, or null if the download list was never requested and thus it
@@ -794,19 +783,16 @@ this.DownloadIntegration = {
   forceSave() {
     if (this._store) {
       return this._store.save();
     }
     return Promise.resolve();
   },
 };
 
-////////////////////////////////////////////////////////////////////////////////
-//// DownloadObserver
-
 this.DownloadObserver = {
   /**
    * Flag to determine if the observers have been added previously.
    */
   observersAdded: false,
 
   /**
    * Timer used to delay restarting canceled downloads upon waking and returning
@@ -909,19 +895,17 @@ this.DownloadObserver = {
   _resumeOfflineDownloads: function DO_resumeOfflineDownloads() {
     this._wakeTimer = null;
 
     for (let download of this._canceledOfflineDownloads) {
       download.start().catch(() => {});
     }
   },
 
-  ////////////////////////////////////////////////////////////////////////////
-  //// nsIObserver
-
+  // nsIObserver
   observe: function DO_observe(aSubject, aTopic, aData) {
     let downloadsCount;
     let p = DownloadUIHelper.getPrompter();
     switch (aTopic) {
       case "quit-application-requested":
         downloadsCount = this._publicInProgressDownloads.size +
                          this._privateInProgressDownloads.size;
         this._confirmCancelDownloads(aSubject, downloadsCount, p, p.ON_QUIT);
@@ -992,25 +976,19 @@ this.DownloadObserver = {
       case "xpcom-will-shutdown":
         for (let topic of kObserverTopics) {
           Services.obs.removeObserver(this, topic);
         }
         break;
     }
   },
 
-  ////////////////////////////////////////////////////////////////////////////
-  //// nsISupports
-
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver])
 };
 
-////////////////////////////////////////////////////////////////////////////////
-//// DownloadHistoryObserver
-
 /**
  * Registers a Places observer so that operations on download history are
  * reflected on the provided list of downloads.
  *
  * You do not need to keep a reference to this object in order to keep it alive,
  * because the history service already keeps a strong reference to it.
  *
  * @param aList
@@ -1023,44 +1001,37 @@ this.DownloadHistoryObserver = function 
 }
 
 this.DownloadHistoryObserver.prototype = {
   /**
    * DownloadList object linked to this observer.
    */
   _list: null,
 
-  ////////////////////////////////////////////////////////////////////////////
-  //// nsISupports
-
   QueryInterface: XPCOMUtils.generateQI([Ci.nsINavHistoryObserver]),
 
-  ////////////////////////////////////////////////////////////////////////////
-  //// nsINavHistoryObserver
-
+  // nsINavHistoryObserver
   onDeleteURI: function DL_onDeleteURI(aURI, aGUID) {
     this._list.removeFinished(download => aURI.equals(NetUtil.newURI(
                                                       download.source.url)));
   },
 
+  // nsINavHistoryObserver
   onClearHistory: function DL_onClearHistory() {
     this._list.removeFinished();
   },
 
   onTitleChanged: function () {},
   onBeginUpdateBatch: function () {},
   onEndUpdateBatch: function () {},
   onVisit: function () {},
   onPageChanged: function () {},
   onDeleteVisits: function () {},
 };
 
-////////////////////////////////////////////////////////////////////////////////
-//// DownloadAutoSaveView
-
 /**
  * This view can be added to a DownloadList object to trigger a save operation
  * in the given DownloadStore object when a relevant change occurs.  You should
  * call the "initialize" method in order to register the view and load the
  * current state from disk.
  *
  * You do not need to keep a reference to this object in order to keep it alive,
  * because the DownloadList object already keeps a strong reference to it.
@@ -1126,29 +1097,28 @@ this.DownloadAutoSaveView.prototype = {
    * Called when the list of downloads changed, this triggers the asynchronous
    * serialization of the list of downloads.
    */
   saveSoon: function ()
   {
     this._writer.arm();
   },
 
-  //////////////////////////////////////////////////////////////////////////////
-  //// DownloadList view
-
+  // DownloadList callback
   onDownloadAdded: function (aDownload)
   {
     if (gCombinedDownloadIntegration.shouldPersistDownload(aDownload)) {
       this._downloadsMap.set(aDownload, aDownload.getSerializationHash());
       if (this._initialized) {
         this.saveSoon();
       }
     }
   },
 
+  // DownloadList callback
   onDownloadChanged: function (aDownload)
   {
     if (!gCombinedDownloadIntegration.shouldPersistDownload(aDownload)) {
       if (this._downloadsMap.has(aDownload)) {
         this._downloadsMap.delete(aDownload);
         this.saveSoon();
       }
       return;
@@ -1156,16 +1126,17 @@ this.DownloadAutoSaveView.prototype = {
 
     let hash = aDownload.getSerializationHash();
     if (this._downloadsMap.get(aDownload) != hash) {
       this._downloadsMap.set(aDownload, hash);
       this.saveSoon();
     }
   },
 
+  // DownloadList callback
   onDownloadRemoved: function (aDownload)
   {
     if (this._downloadsMap.has(aDownload)) {
       this._downloadsMap.delete(aDownload);
       this.saveSoon();
     }
   },
 };
diff --git a/toolkit/components/jsdownloads/src/DownloadLegacy.js b/toolkit/components/jsdownloads/src/DownloadLegacy.js
--- a/toolkit/components/jsdownloads/src/DownloadLegacy.js
+++ b/toolkit/components/jsdownloads/src/DownloadLegacy.js
@@ -1,42 +1,33 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
  * This component implements the XPCOM interfaces required for integration with
  * the legacy download components.
  *
  * New code is expected to use the "Downloads.jsm" module directly, without
  * going through the interfaces implemented in this XPCOM component.  These
  * interfaces are only maintained for backwards compatibility with components
  * that still work synchronously on the main thread.
  */
 
 "use strict";
 
-// Globals
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-const Cr = Components.results;
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr } = Components;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Downloads",
                                   "resource://gre/modules/Downloads.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "PromiseUtils",
                                   "resource://gre/modules/PromiseUtils.jsm");
 
-// DownloadLegacyTransfer
-
 /**
  * nsITransfer implementation that provides a bridge to a Download object.
  *
  * Legacy downloads work differently than the JavaScript implementation.  In the
  * latter, the caller only provides the properties for the Download object and
  * the entire process is handled by the "start" method.  In the legacy
  * implementation, the caller must create a separate object to execute the
  * download, and then make the download visible to the user by hooking it up to
@@ -62,24 +53,22 @@ XPCOMUtils.defineLazyModuleGetter(this, 
  */
 function DownloadLegacyTransfer() {
   this._deferDownload = PromiseUtils.defer();
 }
 
 DownloadLegacyTransfer.prototype = {
   classID: Components.ID("{1b4c85df-cbdd-4bb6-b04e-613caece083c}"),
 
-  // nsISupports
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener,
                                          Ci.nsIWebProgressListener2,
                                          Ci.nsITransfer]),
 
   // nsIWebProgressListener
-
   onStateChange: function DLT_onStateChange(aWebProgress, aRequest, aStateFlags,
                                             aStatus) {
     if (!Components.isSuccessCode(aStatus)) {
       this._componentFailed = true;
     }
 
     if ((aStateFlags & Ci.nsIWebProgressListener.STATE_START) &&
         (aStateFlags & Ci.nsIWebProgressListener.STATE_IS_NETWORK)) {
@@ -148,28 +137,30 @@ DownloadLegacyTransfer.prototype = {
         download.saver.onTransferFinished(aStatus);
       }).catch(Cu.reportError);
 
       // Release the reference to the component executing the download.
       this._cancelable = null;
     }
   },
 
+  // nsIWebProgressListener
   onProgressChange: function DLT_onProgressChange(aWebProgress, aRequest,
                                                   aCurSelfProgress,
                                                   aMaxSelfProgress,
                                                   aCurTotalProgress,
                                                   aMaxTotalProgress) {
     this.onProgressChange64(aWebProgress, aRequest, aCurSelfProgress,
                             aMaxSelfProgress, aCurTotalProgress,
                             aMaxTotalProgress);
   },
 
   onLocationChange() { },
 
+  // nsIWebProgressListener
   onStatusChange: function DLT_onStatusChange(aWebProgress, aRequest, aStatus,
                                               aMessage) {
     // The status change may optionally be received in addition to the state
     // change, but if no network request actually started, it is possible that
     // we only receive a status change with an error status code.
     if (!Components.isSuccessCode(aStatus)) {
       this._componentFailed = true;
 
@@ -178,37 +169,36 @@ DownloadLegacyTransfer.prototype = {
         aDownload.saver.onTransferFinished(aStatus);
       }).catch(Cu.reportError);
     }
   },
 
   onSecurityChange() { },
 
   // nsIWebProgressListener2
-
   onProgressChange64: function DLT_onProgressChange64(aWebProgress, aRequest,
                                                       aCurSelfProgress,
                                                       aMaxSelfProgress,
                                                       aCurTotalProgress,
                                                       aMaxTotalProgress) {
     // Wait for the associated Download object to be available.
     this._deferDownload.promise.then(function DLT_OPC64_onDownload(aDownload) {
       aDownload.saver.onProgressBytes(aCurTotalProgress, aMaxTotalProgress);
     }).catch(Cu.reportError);
   },
 
+  // nsIWebProgressListener2
   onRefreshAttempted: function DLT_onRefreshAttempted(aWebProgress, aRefreshURI,
                                                       aMillis, aSameURI) {
     // Indicate that refreshes and redirects are allowed by default.  However,
     // note that download components don't usually call this method at all.
     return true;
   },
 
   // nsITransfer
-
   init: function DLT_init(aSource, aTarget, aDisplayName, aMIMEInfo, aStartTime,
                           aTempFile, aCancelable, aIsPrivate) {
     this._cancelable = aCancelable;
 
     let launchWhenSucceeded = false, contentType = null, launcherPath = null;
 
     if (aMIMEInfo instanceof Ci.nsIMIMEInfo) {
       launchWhenSucceeded =
@@ -257,18 +247,16 @@ DownloadLegacyTransfer.prototype = {
   setSignatureInfo(signatureInfo) {
     this._signatureInfo = signatureInfo;
   },
 
   setRedirects(redirects) {
     this._redirects = redirects;
   },
 
-  // Private methods and properties
-
   /**
    * This deferred object contains a promise that is resolved with the Download
    * object associated with this nsITransfer instance, when it is available.
    */
   _deferDownload: null,
 
   /**
    * Reference to the component that is executing the download.  This component
@@ -289,11 +277,9 @@ DownloadLegacyTransfer.prototype = {
   _sha256Hash: null,
 
   /**
    * Save the signature info in a serialized protobuf of the downloaded file.
    */
   _signatureInfo: null,
 };
 
-// Module
-
 this.NSGetFactory = XPCOMUtils.generateNSGetFactory([DownloadLegacyTransfer]);
diff --git a/toolkit/components/jsdownloads/src/DownloadList.jsm b/toolkit/components/jsdownloads/src/DownloadList.jsm
--- a/toolkit/components/jsdownloads/src/DownloadList.jsm
+++ b/toolkit/components/jsdownloads/src/DownloadList.jsm
@@ -1,48 +1,28 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
- * This file includes the following constructors and global objects:
- *
- * DownloadList
- * Represents a collection of Download objects that can be viewed and managed by
- * the user interface, and persisted across sessions.
- *
- * DownloadCombinedList
- * Provides a unified, unordered list combining public and private downloads.
- *
- * DownloadSummary
- * Provides an aggregated view on the contents of a DownloadList.
+ * Provides collections of Download objects and aggregate views on them.
  */
 
 "use strict";
 
 this.EXPORTED_SYMBOLS = [
   "DownloadList",
   "DownloadCombinedList",
   "DownloadSummary",
 ];
 
-// Globals
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-const Cr = Components.results;
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr } = Components;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
-
-// DownloadList
-
 /**
  * Represents a collection of Download objects that can be viewed and managed by
  * the user interface, and persisted across sessions.
  */
 this.DownloadList = function() {
   this._downloads = [];
   this._views = new Set();
 }
@@ -249,18 +229,16 @@ this.DownloadList.prototype = {
           // processing the other downloads in the list.
           download.finalize(true).catch(Cu.reportError);
         }
       }
     })().catch(Cu.reportError);
   },
 };
 
-// DownloadCombinedList
-
 /**
  * Provides a unified, unordered list combining public and private downloads.
  *
  * Download objects added to this list are also added to one of the two
  * underlying lists, based on their "source.isPrivate" property.  Views on this
  * list will receive notifications for both public and private downloads.
  *
  * @param aPublicList
@@ -330,38 +308,37 @@ this.DownloadCombinedList.prototype = {
    */
   remove(aDownload) {
     if (aDownload.source.isPrivate) {
       return this._privateList.remove(aDownload);
     }
     return this._publicList.remove(aDownload);
   },
 
-  // DownloadList view
-
+  // DownloadList callback
   onDownloadAdded(aDownload) {
     this._downloads.push(aDownload);
     this._notifyAllViews("onDownloadAdded", aDownload);
   },
 
+  // DownloadList callback
   onDownloadChanged(aDownload) {
     this._notifyAllViews("onDownloadChanged", aDownload);
   },
 
+  // DownloadList callback
   onDownloadRemoved(aDownload) {
     let index = this._downloads.indexOf(aDownload);
     if (index != -1) {
       this._downloads.splice(index, 1);
     }
     this._notifyAllViews("onDownloadRemoved", aDownload);
   },
 };
 
-// DownloadSummary
-
 /**
  * Provides an aggregated view on the contents of a DownloadList.
  */
 this.DownloadSummary = function() {
   this._downloads = [];
   this._views = new Set();
 }
 
@@ -519,29 +496,30 @@ this.DownloadSummary.prototype = {
           view.onSummaryChanged();
         }
       } catch (ex) {
         Cu.reportError(ex);
       }
     }
   },
 
-  // DownloadList view
-
+  // DownloadList callback
   onDownloadAdded(aDownload) {
     this._downloads.push(aDownload);
     if (this._list) {
       this._onListChanged();
     }
   },
 
+  // DownloadList callback
   onDownloadChanged(aDownload) {
     this._onListChanged();
   },
 
+  // DownloadList callback
   onDownloadRemoved(aDownload) {
     let index = this._downloads.indexOf(aDownload);
     if (index != -1) {
       this._downloads.splice(index, 1);
     }
     this._onListChanged();
   },
 };
diff --git a/toolkit/components/jsdownloads/src/DownloadStore.jsm b/toolkit/components/jsdownloads/src/DownloadStore.jsm
--- a/toolkit/components/jsdownloads/src/DownloadStore.jsm
+++ b/toolkit/components/jsdownloads/src/DownloadStore.jsm
@@ -1,10 +1,8 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
  * Handles serialization of Download objects and persistence into a file, so
  * that the state of downloads can be restored across sessions.
  *
@@ -29,40 +27,33 @@
  */
 
 "use strict";
 
 this.EXPORTED_SYMBOLS = [
   "DownloadStore",
 ];
 
-// Globals
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-const Cr = Components.results;
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr } = Components;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Downloads",
                                   "resource://gre/modules/Downloads.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "OS",
                                   "resource://gre/modules/osfile.jsm")
 
 XPCOMUtils.defineLazyGetter(this, "gTextDecoder", function() {
   return new TextDecoder();
 });
 
 XPCOMUtils.defineLazyGetter(this, "gTextEncoder", function() {
   return new TextEncoder();
 });
 
-// DownloadStore
-
 /**
  * Handles serialization of Download objects and persistence into a file, so
  * that the state of downloads can be restored across sessions.
  *
  * @param aList
  *        DownloadList object to be populated or serialized.
  * @param aPath
  *        String containing the file path where data should be saved.
diff --git a/toolkit/components/jsdownloads/src/DownloadUIHelper.jsm b/toolkit/components/jsdownloads/src/DownloadUIHelper.jsm
--- a/toolkit/components/jsdownloads/src/DownloadUIHelper.jsm
+++ b/toolkit/components/jsdownloads/src/DownloadUIHelper.jsm
@@ -1,30 +1,23 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
  * Provides functions to handle status and messages in the user interface.
  */
 
 "use strict";
 
 this.EXPORTED_SYMBOLS = [
   "DownloadUIHelper",
 ];
 
-// Globals
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-const Cr = Components.results;
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr } = Components;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/AppConstants.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "OS",
                                   "resource://gre/modules/osfile.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
@@ -36,18 +29,16 @@ const kStringsRequiringFormatting = {
   fileExecutableSecurityWarning: true,
   cancelDownloadsOKTextMultiple: true,
   quitCancelDownloadsAlertMsgMultiple: true,
   quitCancelDownloadsAlertMsgMacMultiple: true,
   offlineCancelDownloadsAlertMsgMultiple: true,
   leavePrivateBrowsingWindowsCancelDownloadsAlertMsgMultiple2: true
 };
 
-// DownloadUIHelper
-
 /**
  * Provides functions to handle status and messages in the user interface.
  */
 this.DownloadUIHelper = {
   /**
    * Returns an object that can be used to display prompts related to downloads.
    *
    * The prompts may be either anchored to a specified window, or anchored to
@@ -87,18 +78,16 @@ XPCOMUtils.defineLazyGetter(DownloadUIHe
       };
     } else {
       strings[stringName] = string.value;
     }
   }
   return strings;
 });
 
-// DownloadPrompter
-
 /**
  * Allows displaying prompts related to downloads.
  *
  * @param aParent
  *        The nsIDOMWindow to which prompts should be attached, or null to
  *        attach prompts to the most recently active window.
  */
 this.DownloadPrompter = function(aParent) {
diff --git a/toolkit/components/jsdownloads/src/Downloads.jsm b/toolkit/components/jsdownloads/src/Downloads.jsm
--- a/toolkit/components/jsdownloads/src/Downloads.jsm
+++ b/toolkit/components/jsdownloads/src/Downloads.jsm
@@ -1,30 +1,23 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
  * Main entry point to get references to all the back-end objects.
  */
 
 "use strict";
 
 this.EXPORTED_SYMBOLS = [
   "Downloads",
 ];
 
-// Globals
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-const Cr = Components.results;
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr } = Components;
 
 Cu.import("resource://gre/modules/Integration.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/DownloadCore.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "DownloadCombinedList",
                                   "resource://gre/modules/DownloadList.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "DownloadList",
@@ -33,18 +26,16 @@ XPCOMUtils.defineLazyModuleGetter(this, 
                                   "resource://gre/modules/DownloadList.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "DownloadUIHelper",
                                   "resource://gre/modules/DownloadUIHelper.jsm");
 
 /* global DownloadIntegration */
 Integration.downloads.defineModuleGetter(this, "DownloadIntegration",
             "resource://gre/modules/DownloadIntegration.jsm");
 
-// Downloads
-
 /**
  * This object is exposed directly to the consumers of this JavaScript module,
  * and provides the only entry point to get references to back-end objects.
  */
 this.Downloads = {
   /**
    * Work on downloads that were not started from a private browsing window.
    */
diff --git a/toolkit/components/jsdownloads/src/moz.build b/toolkit/components/jsdownloads/src/moz.build
--- a/toolkit/components/jsdownloads/src/moz.build
+++ b/toolkit/components/jsdownloads/src/moz.build
@@ -17,11 +17,16 @@ EXTRA_JS_MODULES += [
     'DownloadCore.jsm',
     'DownloadIntegration.jsm',
     'DownloadList.jsm',
     'Downloads.jsm',
     'DownloadStore.jsm',
     'DownloadUIHelper.jsm',
 ]
 
+if CONFIG['MOZ_PLACES']:
+    EXTRA_JS_MODULES += [
+        'DownloadHistory.jsm',
+    ]
+
 FINAL_LIBRARY = 'xul'
 
 CXXFLAGS += CONFIG['TK_CFLAGS']
diff --git a/toolkit/components/perfmonitoring/nsPerformanceStats.cpp b/toolkit/components/perfmonitoring/nsPerformanceStats.cpp
--- a/toolkit/components/perfmonitoring/nsPerformanceStats.cpp
+++ b/toolkit/components/perfmonitoring/nsPerformanceStats.cpp
@@ -590,22 +590,16 @@ PendingAlertsCollector::Notify(nsITimer*
 
 NS_IMETHODIMP
 PendingAlertsCollector::GetName(nsACString& aName)
 {
   aName.AssignASCII("PendingAlertsCollector_timer");
   return NS_OK;
 }
 
-NS_IMETHODIMP
-PendingAlertsCollector::SetName(const char* aName)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
 nsresult
 PendingAlertsCollector::Start(uint32_t timerDelayMS) {
   if (mPending) {
     // Collector is already started.
     return NS_OK;
   }
 
   if (!mTimer) {
diff --git a/toolkit/components/places/nsFaviconService.cpp b/toolkit/components/places/nsFaviconService.cpp
--- a/toolkit/components/places/nsFaviconService.cpp
+++ b/toolkit/components/places/nsFaviconService.cpp
@@ -125,16 +125,17 @@ GetFramesInfoForContainer(imgIContainer*
 PLACES_FACTORY_SINGLETON_IMPLEMENTATION(nsFaviconService, gFaviconService)
 
 NS_IMPL_CLASSINFO(nsFaviconService, nullptr, 0, NS_FAVICONSERVICE_CID)
 NS_IMPL_ISUPPORTS_CI(
   nsFaviconService
 , nsIFaviconService
 , mozIAsyncFavicons
 , nsITimerCallback
+, nsINamed
 )
 
 nsFaviconService::nsFaviconService()
   : mFailedFaviconSerial(0)
   , mFailedFavicons(MAX_FAILED_FAVICONS / 2)
   , mUnassociatedIcons(UNASSOCIATED_FAVICONS_LENGTH)
 {
   NS_ASSERTION(!gFaviconService,
@@ -235,16 +236,26 @@ nsFaviconService::Notify(nsITimer* timer
   if (mUnassociatedIcons.Count() > 0) {
     mExpireUnassociatedIconsTimer->InitWithCallback(
       this, UNASSOCIATED_ICON_EXPIRY_INTERVAL, nsITimer::TYPE_ONE_SHOT);
   }
 
   return NS_OK;
 }
 
+////////////////////////////////////////////////////////////////////////
+//// nsINamed
+
+NS_IMETHODIMP
+nsFaviconService::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsFaviconService");
+  return NS_OK;
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 //// nsIFaviconService
 
 NS_IMETHODIMP
 nsFaviconService::GetDefaultFavicon(nsIURI** _retval)
 {
   NS_ENSURE_ARG_POINTER(_retval);
 
diff --git a/toolkit/components/places/nsFaviconService.h b/toolkit/components/places/nsFaviconService.h
--- a/toolkit/components/places/nsFaviconService.h
+++ b/toolkit/components/places/nsFaviconService.h
@@ -11,16 +11,17 @@
 
 #include "nsCOMPtr.h"
 #include "nsString.h"
 #include "nsDataHashtable.h"
 #include "nsServiceManagerUtils.h"
 #include "nsTHashtable.h"
 #include "nsToolkitCompsCID.h"
 #include "nsURIHashKey.h"
+#include "nsINamed.h"
 #include "nsITimer.h"
 #include "Database.h"
 #include "imgITools.h"
 #include "mozilla/storage.h"
 #include "mozilla/Attributes.h"
 
 #include "FaviconHelpers.h"
 
@@ -46,16 +47,17 @@ public:
   }
   mozilla::places::IconData iconData;
   PRTime created;
 };
 
 class nsFaviconService final : public nsIFaviconService
                              , public mozIAsyncFavicons
                              , public nsITimerCallback
+                             , public nsINamed
 {
 public:
   nsFaviconService();
 
   /**
    * Obtains the service's object.
    */
   static already_AddRefed<nsFaviconService> GetSingleton();
@@ -119,16 +121,17 @@ public:
   static mozilla::Atomic<int64_t> sLastInsertedIconId;
   static void StoreLastInsertedId(const nsACString& aTable,
                                   const int64_t aLastInsertedId);
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIFAVICONSERVICE
   NS_DECL_MOZIASYNCFAVICONS
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
 private:
   imgITools* GetImgTools() {
     if (!mImgTools) {
       mImgTools = do_CreateInstance("@mozilla.org/image/tools;1");
     }
     return mImgTools;
   }
diff --git a/toolkit/components/telemetry/TelemetryController.jsm b/toolkit/components/telemetry/TelemetryController.jsm
--- a/toolkit/components/telemetry/TelemetryController.jsm
+++ b/toolkit/components/telemetry/TelemetryController.jsm
@@ -71,16 +71,18 @@ XPCOMUtils.defineLazyModuleGetter(this, 
 XPCOMUtils.defineLazyModuleGetter(this, "TelemetrySession",
                                   "resource://gre/modules/TelemetrySession.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "TelemetrySend",
                                   "resource://gre/modules/TelemetrySend.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "TelemetryReportingPolicy",
                                   "resource://gre/modules/TelemetryReportingPolicy.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "TelemetryModules",
                                   "resource://gre/modules/TelemetryModules.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "TelemetryHealthPing",
+                                  "resource://gre/modules/TelemetryHealthPing.jsm");
 
 /**
  * Setup Telemetry logging. This function also gets called when loggin related
  * preferences change.
  */
 var gLogger = null;
 var gLogAppenderDump = null;
 function configureLogging() {
@@ -783,16 +785,19 @@ var Impl = {
 
       // Stop the datachoices infobar display.
       TelemetryReportingPolicy.shutdown();
       TelemetryEnvironment.shutdown();
 
       // Stop any ping sending.
       await TelemetrySend.shutdown();
 
+      // Send latest data.
+      await TelemetryHealthPing.shutdown();
+
       await TelemetrySession.shutdown();
 
       // First wait for clients processing shutdown.
       await this._shutdownBarrier.wait();
 
       // ... and wait for any outstanding async ping activity.
       await this._connectionsBarrier.wait();
 
diff --git a/toolkit/components/telemetry/TelemetryHealthPing.jsm b/toolkit/components/telemetry/TelemetryHealthPing.jsm
new file mode 100644
--- /dev/null
+++ b/toolkit/components/telemetry/TelemetryHealthPing.jsm
@@ -0,0 +1,248 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+ * This module collects data on send failures and other critical issues with Telemetry submissions.
+ */
+
+"use strict";
+
+this.EXPORTED_SYMBOLS = [
+  "TelemetryHealthPing",
+];
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm", this);
+
+XPCOMUtils.defineLazyModuleGetter(this, "TelemetryController", "resource://gre/modules/TelemetryController.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "setTimeout", "resource://gre/modules/Timer.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "clearTimeout", "resource://gre/modules/Timer.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "TelemetryUtils", "resource://gre/modules/TelemetryUtils.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "TelemetrySend", "resource://gre/modules/TelemetrySend.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "Services", "resource://gre/modules/Services.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "Log", "resource://gre/modules/Log.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "Preferences", "resource://gre/modules/Preferences.jsm");
+
+const Utils = TelemetryUtils;
+
+const MS_IN_A_MINUTE = 60 * 1000;
+const IS_HEALTH_PING_ENABLED = Preferences.get(TelemetryUtils.Preferences.HealthPingEnabled, true);
+
+// Send health ping every hour
+const SEND_TICK_DELAY = 60 * MS_IN_A_MINUTE;
+
+// Send top 10 discarded pings only to minimize health ping size
+const MAX_SEND_DISCARDED_PINGS = 10;
+
+const LOGGER_NAME = "Toolkit.Telemetry";
+const LOGGER_PREFIX = "TelemetryHealthPing::";
+
+var Policy = {
+  setSchedulerTickTimeout: (callback, delayMs) => setTimeout(callback, delayMs),
+  clearSchedulerTickTimeout: (id) => clearTimeout(id)
+};
+
+this.TelemetryHealthPing = {
+  Reason: Object.freeze({
+    IMMEDIATE: "immediate", // Ping was sent immediately after recording with no delay.
+    DELAYED: "delayed",     // Recorded data was sent after a delay.
+    SHUT_DOWN: "shutdown",  // Recorded data was sent on shutdown.
+  }),
+
+  FailureType: Object.freeze({
+    DISCARDED_FOR_SIZE: "pingDiscardedForSize",
+    SEND_FAILURE: "sendFailure",
+  }),
+
+  OsInfo: Object.freeze({
+    "name": Services.appinfo.OS,
+    "version": Services.sysinfo.get("kernel_version") || Services.sysinfo.get("version")
+  }),
+
+  HEALTH_PING_TYPE: "health",
+
+  _logger: null,
+
+  // The health ping is sent every every SEND_TICK_DELAY.
+  // Initialize this so that first failures are sent immediately.
+  _lastSendTime: -SEND_TICK_DELAY,
+
+  /**
+   * This stores reported send failures with the following structure:
+   * {
+   *  type1: {
+   *    subtype1: value,
+   *    ...
+   *    subtypeN: value
+   *  },
+   *  ...
+   * }
+   */
+  _failures: {},
+  _timeoutId: null,
+
+  /**
+   * Record a failure to send a ping out.
+   * @param {String} failureType The type of failure (e.g. "timeout", ...).
+   * @returns {Promise} Test-only, resolved when the ping is stored or sent.
+   */
+  recordSendFailure(failureType) {
+    return this._addToFailure(this.FailureType.SEND_FAILURE, failureType);
+  },
+
+  /**
+   * Record that a ping was discarded and its type.
+   * @param {String} pingType The type of discarded ping (e.g. "main", ...).
+   * @returns {Promise} Test-only, resolved when the ping is stored or sent.
+   */
+  recordDiscardedPing(pingType) {
+    return this._addToFailure(this.FailureType.DISCARDED_FOR_SIZE, pingType);
+  },
+
+  /**
+   * Assemble payload.
+   * @param {String} reason A string indicating the triggering reason (e.g. "immediate", "delayed", "shutdown").
+   * @returns {Object} The assembled payload.
+   */
+  _assemblePayload(reason) {
+    this._log.trace("_assemblePayload()");
+    let payload = {
+      os: this.OsInfo,
+      reason
+    };
+
+    for (let key of Object.keys(this._failures)) {
+      if (key === this.FailureType.DISCARDED_FOR_SIZE) {
+        payload[key] = this._getTopDiscardFailures(this._failures[key]);
+      } else {
+        payload[key] = this._failures[key];
+      }
+    }
+
+    return payload;
+  },
+
+  /**
+   * Sort input dictionary descending by value.
+   * @param {Object} failures A dictionary of failures subtype and count.
+   * @returns {Object} Sorted failures by value.
+   */
+  _getTopDiscardFailures(failures) {
+    this._log.trace("_getTopDiscardFailures()");
+    let sortedItems = Object.entries(failures).sort((first, second) => {
+      return second[1] - first[1];
+    });
+
+    let result = {};
+    sortedItems.slice(0, MAX_SEND_DISCARDED_PINGS).forEach(([key, value]) => {
+      result[key] = value;
+    });
+
+    return result;
+  },
+
+  /**
+   * Assemble the failure information and submit it.
+   * @param {String} reason A string indicating the triggering reason (e.g. "immediate", "delayed", "shutdown").
+   * @returns {Promise} Test-only promise that resolves when the ping was stored or sent (if any).
+   */
+  _submitPing(reason) {
+    if (!IS_HEALTH_PING_ENABLED || !this._hasDataToSend()) {
+      return Promise.resolve();
+    }
+
+    this._log.trace("_submitPing(" + reason + ")");
+    let payload = this._assemblePayload(reason);
+    this._clearData();
+    this._lastSendTime = Utils.monotonicNow();
+
+    return new Promise(r =>
+      // If we submit the health ping immediately, the send task would be triggered again
+      // before discarding oversized pings from the queue.
+      // To work around this, we send the ping on the next tick.
+      Services.tm.dispatchToMainThread(() => r(
+        TelemetryController
+          .submitExternalPing(this.HEALTH_PING_TYPE, payload, {addClientId: true}))));
+  },
+
+  /**
+   * Accumulate failure information and trigger a ping immediately or on timeout.
+   * @param {String} failureType The type of failure (e.g. "timeout", ...).
+   * @param {String} failureSubType The subtype of failure (e.g. ping type, ...).
+   * @returns {Promise} Test-only, resolved when the ping is stored or sent.
+   */
+  _addToFailure(failureType, failureSubType) {
+    this._log.trace("_addToFailure() - with type and subtype: " + failureType + " : " + failureSubType);
+
+    if (!(failureType in this._failures)) {
+      this._failures[failureType] = {};
+    }
+
+    let current = this._failures[failureType][failureSubType] || 0;
+    this._failures[failureType][failureSubType] = current + 1;
+
+    const now = Utils.monotonicNow();
+    if ((now - this._lastSendTime) >= SEND_TICK_DELAY) {
+      return this._submitPing(this.Reason.IMMEDIATE);
+    }
+
+    let submissionDelay = SEND_TICK_DELAY - now - this._lastSendTime;
+    this._timeoutId =
+      Policy.setSchedulerTickTimeout(() => TelemetryHealthPing._submitPing(this.Reason.DELAYED), submissionDelay);
+    return Promise.resolve();
+  },
+
+  /**
+   * @returns {boolean} Check the availability of recorded failures data.
+   */
+  _hasDataToSend() {
+    return Object.keys(this._failures).length !== 0;
+  },
+
+  /**
+   * Clear recorded failures data.
+   */
+  _clearData() {
+    this._log.trace("_clearData()");
+    this._failures = {};
+  },
+
+  /**
+   * Clear and reset timeout.
+   */
+  _resetTimeout() {
+    if (this._timeoutId) {
+      Policy.clearSchedulerTickTimeout(this._timeoutId);
+      this._timeoutId = null;
+    }
+  },
+
+  /**
+   * Submit latest ping on shutdown.
+   * @returns {Promise} Test-only, resolved when the ping is stored or sent.
+   */
+  shutdown() {
+    this._log.trace("shutdown()");
+    this._resetTimeout();
+    return this._submitPing(this.Reason.SHUT_DOWN);
+  },
+
+  /**
+   * Test-only, restore to initial state.
+   */
+  testReset() {
+    this._lastSendTime = -SEND_TICK_DELAY;
+    this._clearData();
+    this._resetTimeout();
+  },
+
+  get _log() {
+    if (!this._logger) {
+      this._logger = Log.repository.getLoggerWithMessagePrefix(LOGGER_NAME, LOGGER_PREFIX + "::");
+    }
+
+    return this._logger;
+  },
+};
diff --git a/toolkit/components/telemetry/TelemetrySend.jsm b/toolkit/components/telemetry/TelemetrySend.jsm
--- a/toolkit/components/telemetry/TelemetrySend.jsm
+++ b/toolkit/components/telemetry/TelemetrySend.jsm
@@ -34,16 +34,19 @@ XPCOMUtils.defineLazyModuleGetter(this, 
                                   "resource://gre/modules/TelemetryStorage.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "TelemetryReportingPolicy",
                                   "resource://gre/modules/TelemetryReportingPolicy.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "OS",
                                   "resource://gre/modules/osfile.jsm");
 XPCOMUtils.defineLazyServiceGetter(this, "Telemetry",
                                    "@mozilla.org/base/telemetry;1",
                                    "nsITelemetry");
+XPCOMUtils.defineLazyModuleGetter(this, "TelemetryHealthPing",
+                                  "resource://gre/modules/TelemetryHealthPing.jsm");
+
 
 const Utils = TelemetryUtils;
 
 const LOGGER_NAME = "Toolkit.Telemetry";
 const LOGGER_PREFIX = "TelemetrySend::";
 
 const TOPIC_IDLE_DAILY = "idle-daily";
 // The following topics are notified when Firefox is closing
@@ -90,25 +93,16 @@ const OVERDUE_PING_FILE_AGE = 7 * 24 * 6
 const XHR_ERROR_TYPE = [
   "eOK",
   "eRequest",
   "eUnreachable",
   "eChannelOpen",
   "eRedirect",
 ];
 
-function monotonicNow() {
-  try {
-    return Telemetry.msSinceProcessStart();
-  } catch (ex) {
-    // If this fails fall back to the (non-monotonic) Date value.
-    return Date.now();
-  }
-}
-
 /**
  * This is a policy object used to override behavior within this module.
  * Tests override properties on this object to allow for control of behavior
  * that would otherwise be very hard to cover.
  */
 var Policy = {
   now: () => new Date(),
   midnightPingFuzzingDelay: () => MIDNIGHT_FUZZING_DELAY_MS,
@@ -181,16 +175,24 @@ this.TelemetrySend = {
   get OVERDUE_PING_FILE_AGE() {
     return OVERDUE_PING_FILE_AGE;
   },
 
   get pendingPingCount() {
     return TelemetrySendImpl.pendingPingCount;
   },
 
+  testSetTimeoutForPingSubmit(timeoutInMS) {
+    TelemetrySendImpl._pingSubmissionTimeout = timeoutInMS;
+  },
+
+  testResetTimeOutToDefault() {
+    TelemetrySendImpl._pingSubmissionTimeout = PING_SUBMIT_TIMEOUT_MS;
+  },
+
   /**
    * Partial setup that runs immediately at startup. This currently triggers
    * the crash report annotations.
    */
   earlyInit() {
     TelemetrySendImpl.earlyInit();
   },
 
@@ -587,16 +589,18 @@ var TelemetrySendImpl = {
   _testMode: false,
   // This holds pings that we currently try and haven't persisted yet.
   _currentPings: new Map(),
   // Used to skip spawning the pingsender if OS is shutting down.
   _isOSShutdown: false,
   // Count of pending pings that were overdue.
   _overduePingCount: 0,
 
+  _pingSubmissionTimeout: PING_SUBMIT_TIMEOUT_MS,
+
   OBSERVER_TOPICS: [
     TOPIC_IDLE_DAILY,
     TOPIC_QUIT_APPLICATION_GRANTED,
     TOPIC_QUIT_APPLICATION_FORCED,
   ],
 
   OBSERVED_PREFERENCES: [
     TelemetryUtils.Preferences.TelemetryEnabled,
@@ -1002,17 +1006,17 @@ var TelemetrySendImpl = {
 
   _onPingRequestFinished(success, startTime, id, isPersisted) {
     this._log.trace("_onPingRequestFinished - success: " + success + ", persisted: " + isPersisted);
 
     let sendId = success ? "TELEMETRY_SEND_SUCCESS" : "TELEMETRY_SEND_FAILURE";
     let hsend = Telemetry.getHistogramById(sendId);
     let hsuccess = Telemetry.getHistogramById("TELEMETRY_SUCCESS");
 
-    hsend.add(monotonicNow() - startTime);
+    hsend.add(Utils.monotonicNow() - startTime);
     hsuccess.add(success);
 
     if (!success) {
       // Let the scheduler know about send failures for triggering backoff timeouts.
       SendScheduler.notifySendsFailed();
     }
 
     if (success && isPersisted) {
@@ -1071,29 +1075,29 @@ var TelemetrySendImpl = {
 
     this._log.trace("_doPing - server: " + this._server + ", persisted: " + isPersisted +
                     ", id: " + id);
 
     const url = this._buildSubmissionURL(ping);
 
     let request = new ServiceRequest();
     request.mozBackgroundRequest = true;
-    request.timeout = PING_SUBMIT_TIMEOUT_MS;
+    request.timeout = this._pingSubmissionTimeout;
 
     request.open("POST", url, true);
     request.overrideMimeType("text/plain");
     request.setRequestHeader("Content-Type", "application/json; charset=UTF-8");
     request.setRequestHeader("Date", Policy.now().toUTCString());
 
     this._pendingPingRequests.set(id, request);
 
     // Prevent the request channel from running though URLClassifier (bug 1296802)
     request.channel.loadFlags &= ~Ci.nsIChannel.LOAD_CLASSIFY_URI;
 
-    const monotonicStartTime = monotonicNow();
+    const monotonicStartTime = Utils.monotonicNow();
     let deferred = PromiseUtils.defer();
 
     let onRequestFinished = (success, event) => {
       let onCompletion = () => {
         if (success) {
           let histogram = Telemetry.getHistogramById("TELEMETRY_SUCCESSFUL_SEND_PINGS_SIZE_KB");
           histogram.add(compressedPingSizeKB);
           deferred.resolve();
@@ -1113,16 +1117,18 @@ var TelemetrySendImpl = {
               });
     };
 
     let errorhandler = (event) => {
       let failure = event.type;
       if (failure === "error") {
         failure = XHR_ERROR_TYPE[request.errorCode];
       }
+
+      TelemetryHealthPing.recordSendFailure(failure);
       Telemetry.getHistogramById("TELEMETRY_SEND_FAILURE_TYPE").add(failure);
 
       this._log.error("_doPing - error making request to " + url + ": " + failure);
       onRequestFinished(false, event);
     };
     request.onerror = errorhandler;
     request.ontimeout = errorhandler;
     request.onabort = errorhandler;
@@ -1158,40 +1164,42 @@ var TelemetrySendImpl = {
     };
 
     // If that's a legacy ping format, just send its payload.
     let networkPayload = isV4PingFormat(ping) ? ping : ping.payload;
     request.setRequestHeader("Content-Encoding", "gzip");
     let converter = Cc["@mozilla.org/intl/scriptableunicodeconverter"]
                     .createInstance(Ci.nsIScriptableUnicodeConverter);
     converter.charset = "UTF-8";
-    let startTime = monotonicNow();
+    let startTime = Utils.monotonicNow();
     let utf8Payload = converter.ConvertFromUnicode(JSON.stringify(networkPayload));
     utf8Payload += converter.Finish();
-    Telemetry.getHistogramById("TELEMETRY_STRINGIFY").add(monotonicNow() - startTime);
+    Telemetry.getHistogramById("TELEMETRY_STRINGIFY").add(Utils.monotonicNow() - startTime);
 
     // Check the size and drop pings which are too big.
     const pingSizeBytes = utf8Payload.length;
     if (pingSizeBytes > TelemetryStorage.MAXIMUM_PING_SIZE) {
       this._log.error("_doPing - submitted ping exceeds the size limit, size: " + pingSizeBytes);
       Telemetry.getHistogramById("TELEMETRY_PING_SIZE_EXCEEDED_SEND").add();
       Telemetry.getHistogramById("TELEMETRY_DISCARDED_SEND_PINGS_SIZE_MB")
                .add(Math.floor(pingSizeBytes / 1024 / 1024));
       // We don't need to call |request.abort()| as it was not sent yet.
       this._pendingPingRequests.delete(id);
+
+      TelemetryHealthPing.recordDiscardedPing(ping.type);
       return TelemetryStorage.removePendingPing(id);
     }
 
     let payloadStream = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
-    startTime = monotonicNow();
+    startTime = Utils.monotonicNow();
     payloadStream.data = gzipCompressString(utf8Payload);
 
     const compressedPingSizeKB = Math.floor(payloadStream.data.length / 1024);
-    Telemetry.getHistogramById("TELEMETRY_COMPRESS").add(monotonicNow() - startTime);
+    Telemetry.getHistogramById("TELEMETRY_COMPRESS").add(Utils.monotonicNow() - startTime);
     request.send(payloadStream);
 
     return deferred.promise;
   },
 
   /**
    * Check if sending is temporarily disabled.
    * @return {Boolean} True if we can send pings to the server right now, false if
diff --git a/toolkit/components/telemetry/TelemetrySession.jsm b/toolkit/components/telemetry/TelemetrySession.jsm
--- a/toolkit/components/telemetry/TelemetrySession.jsm
+++ b/toolkit/components/telemetry/TelemetrySession.jsm
@@ -1795,20 +1795,21 @@ var Impl = {
     // on both to be saved after kicking off their collection.
     let p = [];
 
     if (IS_UNIFIED_TELEMETRY) {
       let shutdownPayload = this.getSessionPayload(REASON_SHUTDOWN, false);
 
       // Only send the shutdown ping using the pingsender from the second
       // browsing session on, to mitigate issues with "bot" profiles (see bug 1354482).
-      // Note: sending the "shutdown" ping using the pingsender is currently disabled
-      // due to a crash happening on OSX platforms. See bug 1357745 for context.
+      const sendOnThisSession =
+        Preferences.get(Utils.Preferences.ShutdownPingSenderFirstSession, false) ||
+        !TelemetryReportingPolicy.isFirstRun();
       let sendWithPingsender = Preferences.get(TelemetryUtils.Preferences.ShutdownPingSender, false) &&
-                               !TelemetryReportingPolicy.isFirstRun();
+                               sendOnThisSession;
 
       let options = {
         addClientId: true,
         addEnvironment: true,
         usePingSender: sendWithPingsender,
       };
       p.push(TelemetryController.submitExternalPing(getPingType(shutdownPayload), shutdownPayload, options)
                                 .catch(e => this._log.error("saveShutdownPings - failed to submit shutdown ping", e)));
diff --git a/toolkit/components/telemetry/TelemetryUtils.jsm b/toolkit/components/telemetry/TelemetryUtils.jsm
--- a/toolkit/components/telemetry/TelemetryUtils.jsm
+++ b/toolkit/components/telemetry/TelemetryUtils.jsm
@@ -6,16 +6,17 @@
 
 this.EXPORTED_SYMBOLS = [
   "TelemetryUtils"
 ];
 
 const {classes: Cc, interfaces: Ci, results: Cr, utils: Cu} = Components;
 
 Cu.import("resource://gre/modules/Preferences.jsm", this);
+Cu.import("resource://gre/modules/Services.jsm", this);
 
 const MILLISECONDS_PER_DAY = 24 * 60 * 60 * 1000;
 
 const PREF_TELEMETRY_ENABLED = "toolkit.telemetry.enabled";
 
 const IS_CONTENT_PROCESS = (function() {
   // We cannot use Services.appinfo here because in telemetry xpcshell tests,
   // appinfo is initially unavailable, and becomes available only later on.
@@ -24,19 +25,21 @@ const IS_CONTENT_PROCESS = (function() {
 })();
 
 this.TelemetryUtils = {
   Preferences: Object.freeze({
     // General Preferences
     ArchiveEnabled: "toolkit.telemetry.archive.enabled",
     CachedClientId: "toolkit.telemetry.cachedClientID",
     FirstRun: "toolkit.telemetry.reportingpolicy.firstRun",
+    HealthPingEnabled: "toolkit.telemetry.healthping.enabled",
     OverrideOfficialCheck: "toolkit.telemetry.send.overrideOfficialCheck",
     Server: "toolkit.telemetry.server",
     ShutdownPingSender: "toolkit.telemetry.shutdownPingSender.enabled",
+    ShutdownPingSenderFirstSession: "toolkit.telemetry.shutdownPingSender.enabledFirstSession",
     TelemetryEnabled: "toolkit.telemetry.enabled",
     Unified: "toolkit.telemetry.unified",
     NewProfilePingEnabled: "toolkit.telemetry.newProfilePing.enabled",
     NewProfilePingDelay: "toolkit.telemetry.newProfilePing.delay",
     PreviousBuildID: "toolkit.telemetry.previousBuildID",
 
     // Log Preferences
     LogLevel: "toolkit.telemetry.log.level",
@@ -179,9 +182,21 @@ this.TelemetryUtils = {
       + "-" + padNumber(date.getDate(), 2)
       + "T" + padNumber(date.getHours(), 2)
       + ":" + padNumber(date.getMinutes(), 2)
       + ":" + padNumber(date.getSeconds(), 2)
       + "." + date.getMilliseconds()
       + sign(tzOffset) + padNumber(Math.floor(Math.abs(tzOffset / 60)), 2)
       + ":" + padNumber(Math.abs(tzOffset % 60), 2);
   },
+
+  /**
+   * @returns {number} The monotonic time since the process start
+   * or (non-monotonic) Date value if this fails back.
+   */
+  monotonicNow() {
+    try {
+      return Services.telemetry.msSinceProcessStart();
+    } catch (ex) {
+      return Date.now();
+    }
+  }
 };
diff --git a/toolkit/components/telemetry/docs/data/health-ping.rst b/toolkit/components/telemetry/docs/data/health-ping.rst
new file mode 100644
--- /dev/null
+++ b/toolkit/components/telemetry/docs/data/health-ping.rst
@@ -0,0 +1,80 @@
+
+"health" ping
+============
+
+This ping is intended to provide data about problems arise when submitting other pings.
+The ping is submitted at most once per hour. On shutdown an additional ping is submitted
+to avoid losing collected data.
+
+This ping is intended to be really small.
+The client id is submitted with this ping.
+
+.. code-block:: js
+
+    {
+      "type": "health", // type
+      ... common ping data
+      "clientId": <UUID>, // client id, e.g.
+                            // "c641eacf-c30c-4171-b403-f077724e848a"
+      "payload": {
+        "os": {
+            "name": <string>, // OS name
+            "version": <string> // OS version
+        },
+        "reason": <string>, // When ping was triggered, e.g. "immediate" or "shutdown".
+        "pingDiscardedForSize": {
+            "main": <number>, // Amount of occurrences for a specific ping type.
+            "core": <number>
+            ...
+        },
+        "sendFailure": {
+            "timeout": <number>, // Amount of occurrences for a specific failure.
+            "abort": <number>
+            ...
+        }
+      }
+    }
+
+Send behavior
+-------------
+
+``TelemetryHealthPing.jsm`` tracks several problems:
+
+* The size of other assembled ping exceed the ping limit.
+* There was a failure while sending other ping.
+
+After recording the data, ping will be sent:
+
+* immediately, with the reason ``immediate`` , if it is first ping in the session or it passed at least one hour from the previous submission.
+* after 1 hour minus the time passed from previous submission, with the reason ``delayed`` , if less than an hour passed from the previous submission.
+* on shutdown, with the reason ``shutdown`` , if recorded data is not empty.
+
+Field details
+-------------
+
+reason
+~~~~~~
+The ``reason`` field contains the information about when "health" ping was submitted. Now it supports three types:
+
+* immediate: The health ping was submitted immediately after recording a failure.
+* delayed: The health ping was submitted after a delay.
+* shutdown: The health ping was submitted on shutdown.
+
+pingDiscardedForSize
+~~~~~~~~~~~~~~~~~~~~
+The ``pingDiscardedForSize`` field contains the information about top ten pings, whose size exceeded the
+ping size limit (1 mb). This field lists the number of discarded pings per ping type.
+
+This field is optional.
+
+sendFailure
+~~~~~~~~~~~
+The ``sendFailure`` field contains the information about pings, which had failures on sending.
+This field lists the number of failed pings per ping send failure type.
+
+This field is optional.
+
+.. note::
+
+    Although both ``pingDiscardedForSize`` and ``sendFailure`` fields are optional, the health ping will only
+    be submitted if one of this field not empty.
diff --git a/toolkit/components/telemetry/docs/internals/preferences.rst b/toolkit/components/telemetry/docs/internals/preferences.rst
--- a/toolkit/components/telemetry/docs/internals/preferences.rst
+++ b/toolkit/components/telemetry/docs/internals/preferences.rst
@@ -49,16 +49,20 @@ Preferences
 ``toolkit.telemetry.log.dump``
 
   Sets whether to dump Telemetry log messages to ``stdout`` too.
 
 ``toolkit.telemetry.shutdownPingSender.enabled``
 
   Allow the ``shutdown`` ping to be sent when the browser shuts down, from the second browsing session on, instead of the next restart, using the :doc:`ping sender <pingsender>`.
 
+``toolkit.telemetry.shutdownPingSender.enabledFirstSession``
+
+  Allow the ``shutdown`` ping to be sent using the :doc:`ping sender <pingsender>` from the first browsing session.
+
 ``toolkit.telemetry.newProfilePing.enabled``
 
   Enable the :doc:`../data/new-profile` ping on new profiles.
 
 ``toolkit.telemetry.newProfilePing.delay``
 
   Controls the delay after which the :doc:`../data/new-profile` is sent on new profiles.
 
@@ -132,8 +136,12 @@ The following prefs are for testing purp
 
 ``toolkit.telemetry.modulesPing.interval``
 
   Interval between "modules" ping transmissions.
 
 ``toolkit.telemetry.send.overrideOfficialCheck``
 
   If true, allows sending pings on unofficial builds. Requires a restart.
+
+``toolkit.telemetry.healthping.enabled``
+
+  If false, sending health pings is disabled. Defaults to true.
diff --git a/toolkit/components/telemetry/moz.build b/toolkit/components/telemetry/moz.build
--- a/toolkit/components/telemetry/moz.build
+++ b/toolkit/components/telemetry/moz.build
@@ -79,16 +79,17 @@ EXTRA_COMPONENTS += [
     'TelemetryStartup.manifest'
 ]
 
 EXTRA_JS_MODULES += [
     'GCTelemetry.jsm',
     'TelemetryArchive.jsm',
     'TelemetryController.jsm',
     'TelemetryEnvironment.jsm',
+    'TelemetryHealthPing.jsm',
     'TelemetryLog.jsm',
     'TelemetryModules.jsm',
     'TelemetryReportingPolicy.jsm',
     'TelemetrySend.jsm',
     'TelemetrySession.jsm',
     'TelemetryStopwatch.jsm',
     'TelemetryStorage.jsm',
     'TelemetryTimestamps.jsm',
diff --git a/toolkit/components/telemetry/tests/unit/head.js b/toolkit/components/telemetry/tests/unit/head.js
--- a/toolkit/components/telemetry/tests/unit/head.js
+++ b/toolkit/components/telemetry/tests/unit/head.js
@@ -296,34 +296,40 @@ function setEmptyPrefWatchlist() {
   let TelemetryEnvironment =
     Cu.import("resource://gre/modules/TelemetryEnvironment.jsm").TelemetryEnvironment;
   return TelemetryEnvironment.onInitialized().then(() => {
     TelemetryEnvironment.testWatchPreferences(new Map());
 
   });
 }
 
+function histogramValueCount(histogramSnapshot) {
+  return histogramSnapshot.counts.reduce((a, b) => a + b);
+}
+
 if (runningInParent) {
   // Set logging preferences for all the tests.
   Services.prefs.setCharPref("toolkit.telemetry.log.level", "Trace");
   // Telemetry archiving should be on.
   Services.prefs.setBoolPref(TelemetryUtils.Preferences.ArchiveEnabled, true);
   // Telemetry xpcshell tests cannot show the infobar.
   Services.prefs.setBoolPref(TelemetryUtils.Preferences.BypassNotification, true);
   // FHR uploads should be enabled.
   Services.prefs.setBoolPref(TelemetryUtils.Preferences.FhrUploadEnabled, true);
   // Many tests expect the shutdown and the new-profile to not be sent on shutdown
   // and will fail if receive an unexpected ping. Let's globally disable these features:
   // the relevant tests will enable these prefs when needed.
   Services.prefs.setBoolPref(TelemetryUtils.Preferences.ShutdownPingSender, false);
+  Services.prefs.setBoolPref(TelemetryUtils.Preferences.ShutdownPingSenderFirstSession, false);
   Services.prefs.setBoolPref("toolkit.telemetry.newProfilePing.enabled", false);
   // Ensure browser experiments are also disabled, to avoid network activity
   // when toggling PREF_ENABLED.
   Services.prefs.setBoolPref("experiments.enabled", false);
-
+  // Turn off Health Ping submission.
+  Services.prefs.setBoolPref(TelemetryUtils.Preferences.HealthPingEnabled, false);
 
   fakePingSendTimer((callback, timeout) => {
     Services.tm.dispatchToMainThread(() => callback());
   },
   () => {});
 
   // This gets imported via fakeNow();
   /* global TelemetrySend */
diff --git a/toolkit/components/telemetry/tests/unit/test_TelemetryHealthPing.js b/toolkit/components/telemetry/tests/unit/test_TelemetryHealthPing.js
new file mode 100644
--- /dev/null
+++ b/toolkit/components/telemetry/tests/unit/test_TelemetryHealthPing.js
@@ -0,0 +1,184 @@
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+// This tests the public Telemetry API for submitting Health pings.
+
+"use strict";
+
+Cu.import("resource://gre/modules/TelemetryController.jsm", this);
+Cu.import("resource://gre/modules/TelemetryStorage.jsm", this);
+Cu.import("resource://gre/modules/TelemetryUtils.jsm", this);
+Cu.import("resource://gre/modules/Preferences.jsm", this);
+Cu.import("resource://gre/modules/XPCOMUtils.jsm", this);
+
+XPCOMUtils.defineLazyModuleGetter(this, "TelemetryHealthPing",
+                                  "resource://gre/modules/TelemetryHealthPing.jsm");
+
+function checkHealthPingStructure(ping, expectedFailuresDict) {
+  let payload = ping.payload;
+  Assert.equal(ping.type, TelemetryHealthPing.HEALTH_PING_TYPE, "Should have recorded a health ping.");
+
+  for (let [key, value] of Object.entries(expectedFailuresDict)) {
+    Assert.deepEqual(payload[key], value, "Should have recorded correct entry with key: " + key);
+  }
+}
+
+function fakeHealthSchedulerTimer(set, clear) {
+  let telemetryHealthPing = Cu.import("resource://gre/modules/TelemetryHealthPing.jsm", {});
+  telemetryHealthPing.Policy.setSchedulerTickTimeout = set;
+  telemetryHealthPing.Policy.clearSchedulerTickTimeout = clear;
+}
+
+add_task(async function setup() {
+  // Trigger a proper telemetry init.
+  do_get_profile(true);
+  // Make sure we don't generate unexpected pings due to pref changes.
+  await setEmptyPrefWatchlist();
+  Services.prefs.setBoolPref("toolkit.telemetry.enabled", true);
+  Preferences.set(TelemetryUtils.Preferences.HealthPingEnabled, true);
+
+  await TelemetryController.testSetup();
+  PingServer.start();
+  TelemetrySend.setServer("http://localhost:" + PingServer.port);
+});
+
+add_task(async function test_sendImmediately() {
+  PingServer.clearRequests();
+  TelemetryHealthPing.testReset();
+
+  await TelemetryHealthPing.recordSendFailure("testProblem");
+  let ping = await PingServer.promiseNextPing();
+  checkHealthPingStructure(ping, {
+    [TelemetryHealthPing.FailureType.SEND_FAILURE]: {
+      "testProblem": 1
+    },
+    "os": TelemetryHealthPing.OsInfo,
+    "reason": TelemetryHealthPing.Reason.IMMEDIATE
+  });
+});
+
+add_task(async function test_sendOnDelay() {
+  PingServer.clearRequests();
+  TelemetryHealthPing.testReset();
+
+  // This first failure should immediately trigger a ping. After this, subsequent failures should be throttled.
+  await TelemetryHealthPing.recordSendFailure("testFailure");
+  let testPing = await PingServer.promiseNextPing();
+  Assert.equal(testPing.type, TelemetryHealthPing.HEALTH_PING_TYPE, "Should have recorded a health ping.");
+
+  // Retrieve delayed call back.
+  let pingSubmissionCallBack = null;
+  fakeHealthSchedulerTimer((callBack) => pingSubmissionCallBack = callBack, () => {
+  });
+
+  // Record two failures, health ping must not be send now.
+  await TelemetryHealthPing.recordSendFailure("testFailure");
+  await TelemetryHealthPing.recordSendFailure("testFailure");
+
+  // Wait for sending delayed health ping.
+  await pingSubmissionCallBack();
+
+  let ping = await PingServer.promiseNextPing();
+  checkHealthPingStructure(ping, {
+    [TelemetryHealthPing.FailureType.SEND_FAILURE]: {
+      "testFailure": 2
+    },
+    "os": TelemetryHealthPing.OsInfo,
+    "reason": TelemetryHealthPing.Reason.DELAYED
+  });
+});
+
+add_task(async function test_sendOverSizedPing() {
+  TelemetryHealthPing.testReset();
+  PingServer.clearRequests();
+  let OVER_SIZED_PING_TYPE = "over-sized-ping";
+  let overSizedData = generateRandomString(2 * 1024 * 1024);
+
+  await TelemetryController.submitExternalPing(OVER_SIZED_PING_TYPE, {"data": overSizedData});
+  let ping = await PingServer.promiseNextPing();
+
+  checkHealthPingStructure(ping, {
+    [TelemetryHealthPing.FailureType.DISCARDED_FOR_SIZE]: {
+      [OVER_SIZED_PING_TYPE]: 1
+    },
+    "os": TelemetryHealthPing.OsInfo,
+    "reason": TelemetryHealthPing.Reason.IMMEDIATE
+  });
+});
+
+add_task(async function test_sendOnTimeout() {
+  TelemetryHealthPing.testReset();
+  PingServer.clearRequests();
+  let PING_TYPE = "ping-on-timeout";
+
+  // Set up small ping submission timeout to always have timeout error.
+  TelemetrySend.testSetTimeoutForPingSubmit(2);
+
+  // Reset the timeout after receiving the first ping to be able to send health ping.
+  PingServer.registerPingHandler((request, result) => {
+    PingServer.resetPingHandler();
+    TelemetrySend.testResetTimeOutToDefault();
+  });
+
+  await TelemetryController.submitExternalPing(PING_TYPE, {});
+  let ping = await PingServer.promiseNextPing();
+  checkHealthPingStructure(ping, {
+    [TelemetryHealthPing.FailureType.SEND_FAILURE]: {
+      "timeout": 1
+    },
+    "os": TelemetryHealthPing.OsInfo,
+    "reason": TelemetryHealthPing.Reason.IMMEDIATE
+  });
+
+  // Clear pending pings to avoid resending pings which fail with time out error.
+  await TelemetryStorage.testClearPendingPings();
+});
+
+add_task(async function test_sendOnlyTopTenDiscardedPings() {
+  TelemetryHealthPing.testReset();
+  PingServer.clearRequests();
+  let PING_TYPE = "sort-discarded";
+
+  // This first failure should immediately trigger a ping. After this, subsequent failures should be throttled.
+  await TelemetryHealthPing.recordSendFailure("testFailure");
+  let testPing = await PingServer.promiseNextPing();
+  Assert.equal(testPing.type, TelemetryHealthPing.HEALTH_PING_TYPE, "Should have recorded a health ping.");
+
+
+  // Retrieve delayed call back.
+  let pingSubmissionCallBack = null;
+  fakeHealthSchedulerTimer((callBack) => pingSubmissionCallBack = callBack, () => {
+  });
+
+  // Add failures
+  for (let i = 1; i < 12; i++) {
+    for (let j = 1; j < i; j++) {
+      await TelemetryHealthPing.recordDiscardedPing(PING_TYPE + i);
+    }
+  }
+
+  await pingSubmissionCallBack();
+  let ping = await PingServer.promiseNextPing();
+
+  checkHealthPingStructure(ping, {
+    "os": TelemetryHealthPing.OsInfo,
+    "reason": TelemetryHealthPing.Reason.DELAYED,
+    [TelemetryHealthPing.FailureType.DISCARDED_FOR_SIZE]: {
+      [PING_TYPE + 11]: 10,
+      [PING_TYPE + 10]: 9,
+      [PING_TYPE + 9]: 8,
+      [PING_TYPE + 8]: 7,
+      [PING_TYPE + 7]: 6,
+      [PING_TYPE + 6]: 5,
+      [PING_TYPE + 5]: 4,
+      [PING_TYPE + 4]: 3,
+      [PING_TYPE + 3]: 2,
+      [PING_TYPE + 2]: 1
+    }
+  });
+});
+
+add_task(async function cleanup() {
+  await PingServer.stop();
+});
diff --git a/toolkit/components/telemetry/tests/unit/test_TelemetrySend.js b/toolkit/components/telemetry/tests/unit/test_TelemetrySend.js
--- a/toolkit/components/telemetry/tests/unit/test_TelemetrySend.js
+++ b/toolkit/components/telemetry/tests/unit/test_TelemetrySend.js
@@ -10,16 +10,20 @@ Cu.import("resource://gre/modules/Teleme
 Cu.import("resource://testing-common/ContentTaskUtils.jsm", this);
 Cu.import("resource://gre/modules/TelemetrySession.jsm", this);
 Cu.import("resource://gre/modules/TelemetrySend.jsm", this);
 Cu.import("resource://gre/modules/TelemetryStorage.jsm", this);
 Cu.import("resource://gre/modules/TelemetryUtils.jsm", this);
 Cu.import("resource://gre/modules/Services.jsm", this);
 Cu.import("resource://gre/modules/Preferences.jsm", this);
 Cu.import("resource://gre/modules/osfile.jsm", this);
+Cu.import("resource://gre/modules/XPCOMUtils.jsm", this);
+
+XPCOMUtils.defineLazyModuleGetter(this, "TelemetryHealthPing",
+  "resource://gre/modules/TelemetryHealthPing.jsm");
 
 const MS_IN_A_MINUTE = 60 * 1000;
 
 function countPingTypes(pings) {
   let countByType = new Map();
   for (let p of pings) {
     countByType.set(p.type, 1 + (countByType.get(p.type) || 0));
   }
@@ -74,16 +78,17 @@ function histogramValueCount(h) {
 }
 
 add_task(async function test_setup() {
   // Trigger a proper telemetry init.
   do_get_profile(true);
   // Make sure we don't generate unexpected pings due to pref changes.
   await setEmptyPrefWatchlist();
   Services.prefs.setBoolPref(TelemetryUtils.Preferences.TelemetryEnabled, true);
+  Preferences.set(TelemetryUtils.Preferences.HealthPingEnabled, true);
 });
 
 // Test the ping sending logic.
 add_task(async function test_sendPendingPings() {
   const TYPE_PREFIX = "test-sendPendingPings-";
   const TEST_TYPE_A = TYPE_PREFIX + "A";
   const TEST_TYPE_B = TYPE_PREFIX + "B";
 
@@ -321,34 +326,41 @@ add_task(async function test_discardBigP
   }
 
   // Generate a 2MB string and create an oversized payload.
   const OVERSIZED_PAYLOAD = {"data": generateRandomString(2 * 1024 * 1024)};
 
   // Submit a ping of a normal size and check that we don't count it in the histogram.
   await TelemetryController.submitExternalPing(TEST_PING_TYPE, { test: "test" });
   await TelemetrySend.testWaitOnOutgoingPings();
+  await PingServer.promiseNextPing();
 
   Assert.equal(histSizeExceeded.snapshot().sum, 0, "Telemetry must report no oversized ping submitted.");
   Assert.equal(histDiscardedSize.snapshot().sum, 0, "Telemetry must report no oversized pings.");
   Assert.deepEqual(histSuccess.snapshot().counts, [0, 1, 0], "Should have recorded sending success.");
   Assert.equal(histogramValueCount(histSendTimeSuccess.snapshot()), 1, "Should have recorded send success time.");
   Assert.greater(histSendTimeSuccess.snapshot().sum, 0, "Should have recorded send success time.");
   Assert.equal(histogramValueCount(histSendTimeFail.snapshot()), 0, "Should not have recorded send failure time.");
 
   // Submit an oversized ping and check that it gets discarded.
+  TelemetryHealthPing.testReset();
   await TelemetryController.submitExternalPing(TEST_PING_TYPE, OVERSIZED_PAYLOAD);
-  await TelemetrySend.testWaitOnOutgoingPings();
+  let ping = await PingServer.promiseNextPing();
 
   Assert.equal(histSizeExceeded.snapshot().sum, 1, "Telemetry must report 1 oversized ping submitted.");
   Assert.equal(histDiscardedSize.snapshot().counts[2], 1, "Telemetry must report a 2MB, oversized, ping submitted.");
-  Assert.deepEqual(histSuccess.snapshot().counts, [0, 1, 0], "Should have recorded sending success.");
-  Assert.equal(histogramValueCount(histSendTimeSuccess.snapshot()), 1, "Should have recorded send success time.");
+  Assert.deepEqual(histSuccess.snapshot().counts, [0, 2, 0], "Should have recorded sending success.");
+  Assert.equal(histogramValueCount(histSendTimeSuccess.snapshot()), 2, "Should have recorded send success time.");
   Assert.greater(histSendTimeSuccess.snapshot().sum, 0, "Should have recorded send success time.");
   Assert.equal(histogramValueCount(histSendTimeFail.snapshot()), 0, "Should not have recorded send failure time.");
+
+  Assert.equal(ping.type, TelemetryHealthPing.HEALTH_PING_TYPE, "Should have received a health ping.");
+  Assert.deepEqual(ping.payload[TelemetryHealthPing.FailureType.DISCARDED_FOR_SIZE],
+    {[TEST_PING_TYPE]: 1}, "Should have recorded correct type of oversized ping.");
+  Assert.deepEqual(ping.payload["os"], TelemetryHealthPing.OsInfo, "Should have correct os info.")
 });
 
 add_task(async function test_evictedOnServerErrors() {
   const TEST_TYPE = "test-evicted";
 
   await TelemetrySend.reset();
 
   let histEvicted = Telemetry.getHistogramById("TELEMETRY_PING_EVICTED_FOR_SERVER_ERRORS");
diff --git a/toolkit/components/telemetry/tests/unit/test_TelemetrySession.js b/toolkit/components/telemetry/tests/unit/test_TelemetrySession.js
--- a/toolkit/components/telemetry/tests/unit/test_TelemetrySession.js
+++ b/toolkit/components/telemetry/tests/unit/test_TelemetrySession.js
@@ -1403,17 +1403,17 @@ add_task(async function test_sendShutdow
   // Make sure the reporting policy picks up the updated pref.
   TelemetryReportingPolicy.testUpdateFirstRun();
   PingServer.clearRequests();
   Telemetry.clearScalars();
 
   // Shutdown telemetry and wait for an incoming ping.
   let nextPing = PingServer.promiseNextPing();
   await TelemetryController.testShutdown();
-  const ping = await nextPing;
+  let ping = await nextPing;
 
   // Check that we received a shutdown ping.
   checkPingFormat(ping, ping.type, true, true);
   Assert.equal(ping.payload.info.reason, REASON_SHUTDOWN);
   Assert.equal(ping.clientId, gClientID);
   Assert.ok(!(OSSHUTDOWN_SCALAR in ping.payload.processes.parent.scalars),
             "The OS shutdown scalar must not be set.");
   // Try again, this time disable ping upload. The PingSender
@@ -1465,18 +1465,40 @@ add_task(async function test_sendShutdow
   // subsession.
   Preferences.set(TelemetryUtils.Preferences.FirstRun, true);
   // Make sure the reporting policy picks up the updated pref.
   TelemetryReportingPolicy.testUpdateFirstRun();
 
   await TelemetryController.testReset();
   await TelemetryController.testShutdown();
 
+  // Clear the state and prepare for the next test.
+  await TelemetryStorage.testClearPendingPings();
+  PingServer.clearRequests();
+  PingServer.resetPingHandler();
+
+  // Check that we're able to send the shutdown ping using the pingsender
+  // from the first session if the related pref is on.
+  Preferences.set(TelemetryUtils.Preferences.ShutdownPingSenderFirstSession, true);
+  Preferences.set(TelemetryUtils.Preferences.FirstRun, true);
+  TelemetryReportingPolicy.testUpdateFirstRun();
+
+  // Restart/shutdown telemetry and wait for an incoming ping.
+  await TelemetryController.testReset();
+  await TelemetryController.testShutdown();
+  ping = await PingServer.promiseNextPing();
+
+  // Check that we received a shutdown ping.
+  checkPingFormat(ping, ping.type, true, true);
+  Assert.equal(ping.payload.info.reason, REASON_SHUTDOWN);
+  Assert.equal(ping.clientId, gClientID);
+
   // Reset the pref and restart Telemetry.
   Preferences.set(TelemetryUtils.Preferences.ShutdownPingSender, false);
+  Preferences.set(TelemetryUtils.Preferences.ShutdownPingSenderFirstSession, false);
   Preferences.reset(TelemetryUtils.Preferences.FirstRun);
   PingServer.resetPingHandler();
 });
 
 add_task(async function test_savedSessionData() {
   // Create the directory which will contain the data file, if it doesn't already
   // exist.
   await OS.File.makeDir(DATAREPORTING_PATH);
diff --git a/toolkit/components/telemetry/tests/unit/xpcshell.ini b/toolkit/components/telemetry/tests/unit/xpcshell.ini
--- a/toolkit/components/telemetry/tests/unit/xpcshell.ini
+++ b/toolkit/components/telemetry/tests/unit/xpcshell.ini
@@ -34,16 +34,17 @@ skip-if = os == "android"
 tags = addons
 [test_PingAPI.js]
 skip-if = os == "android"
 [test_TelemetryFlagClear.js]
 [test_TelemetryLateWrites.js]
 [test_TelemetryLockCount.js]
 [test_TelemetryLog.js]
 [test_TelemetryController.js]
+[test_TelemetryHealthPing.js]
 tags = addons
 [test_TelemetryController_idle.js]
 [test_TelemetryControllerShutdown.js]
 tags = addons
 [test_TelemetryStopwatch.js]
 [test_TelemetryControllerBuildID.js]
 [test_TelemetrySendOldPings.js]
 skip-if = os == "android" # Disabled due to intermittent orange on Android
diff --git a/toolkit/components/url-classifier/content/listmanager.js b/toolkit/components/url-classifier/content/listmanager.js
deleted file mode 100644
--- a/toolkit/components/url-classifier/content/listmanager.js
+++ /dev/null
@@ -1,633 +0,0 @@
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-var Cu = Components.utils;
-Cu.import("resource://gre/modules/Services.jsm");
-
-// This is the only implementation of nsIUrlListManager.
-// A class that manages lists, namely white and black lists for
-// phishing or malware protection. The ListManager knows how to fetch,
-// update, and store lists.
-//
-// There is a single listmanager for the whole application.
-//
-// TODO more comprehensive update tests, for example add unittest check
-//      that the listmanagers tables are properly written on updates
-
-// Lower and upper limits on the server-provided polling frequency
-const minDelayMs = 5 * 60 * 1000;
-const maxDelayMs = 24 * 60 * 60 * 1000;
-const defaultUpdateIntervalMs = 30 * 60 * 1000;
-const PREF_DEBUG_ENABLED = "browser.safebrowsing.debug";
-
-let loggingEnabled = false;
-
-// Log only if browser.safebrowsing.debug is true
-this.log = function log(...stuff) {
-  if (!loggingEnabled) {
-    return;
-  }
-
-  var d = new Date();
-  let msg = "listmanager: " + d.toTimeString() + ": " + stuff.join(" ");
-  msg = Services.urlFormatter.trimSensitiveURLs(msg);
-  Services.console.logStringMessage(msg);
-  dump(msg + "\n");
-}
-
-/**
- * A ListManager keeps track of black and white lists and knows
- * how to update them.
- *
- * @constructor
- */
-this.PROT_ListManager = function PROT_ListManager() {
-  loggingEnabled = Services.prefs.getBoolPref(PREF_DEBUG_ENABLED);
-
-  log("Initializing list manager");
-  this.updateInterval = defaultUpdateIntervalMs;
-
-  // A map of tableNames to objects of type
-  // { updateUrl: <updateUrl>, gethashUrl: <gethashUrl> }
-  this.tablesData = {};
-  // A map of updateUrls to maps of tables requiring updates, e.g.
-  // { safebrowsing-update-url: { goog-phish-shavar: true,
-  //                              goog-malware-shavar: true }
-  this.needsUpdate_ = {};
-
-  // A map of updateUrls to single-use nsITimer. An entry exists if and only if
-  // there is at least one table with updates enabled for that url. nsITimers
-  // are reset when enabling/disabling updates or on update callbacks (update
-  // success, update failure, download error).
-  this.updateCheckers_ = {};
-  this.requestBackoffs_ = {};
-  this.dbService_ = Cc["@mozilla.org/url-classifier/dbservice;1"]
-                   .getService(Ci.nsIUrlClassifierDBService);
-
-  Services.obs.addObserver(this, "quit-application");
-  Services.prefs.addObserver(PREF_DEBUG_ENABLED, this);
-}
-
-/**
- * Register a new table table
- * @param tableName - the name of the table
- * @param updateUrl - the url for updating the table
- * @param gethashUrl - the url for fetching hash completions
- * @returns true if the table could be created; false otherwise
- */
-PROT_ListManager.prototype.registerTable = function(tableName,
-                                                    providerName,
-                                                    updateUrl,
-                                                    gethashUrl) {
-  this.tablesData[tableName] = {};
-  if (!updateUrl) {
-    log("Can't register table " + tableName + " without updateUrl");
-    return false;
-  }
-  log("registering " + tableName + " with " + updateUrl);
-  this.tablesData[tableName].updateUrl = updateUrl;
-  this.tablesData[tableName].gethashUrl = gethashUrl;
-  this.tablesData[tableName].provider = providerName;
-
-  // Keep track of all of our update URLs.
-  if (!this.needsUpdate_[updateUrl]) {
-    this.needsUpdate_[updateUrl] = {};
-
-    // Using the V4 backoff algorithm for both V2 and V4. See bug 1273398.
-    this.requestBackoffs_[updateUrl] = new RequestBackoffV4(
-                                            4 /* num requests */,
-                                   60*60*1000 /* request time, 60 min */);
-  }
-  this.needsUpdate_[updateUrl][tableName] = false;
-
-  return true;
-}
-
-/**
- * Delete all of our data tables which seem to leak otherwise.
- * Remove observers
- */
-PROT_ListManager.prototype.shutdown_ = function() {
-  this.stopUpdateCheckers();
-  for (var name in this.tablesData) {
-    delete this.tablesData[name];
-  }
-  Services.obs.removeObserver(this, "quit-application");
-  Services.prefs.removeObserver(PREF_DEBUG_ENABLED, this);
-}
-
-/**
- * xpcom-shutdown callback
- */
-PROT_ListManager.prototype.observe = function(aSubject, aTopic, aData) {
-  switch (aTopic) {
-  case "quit-application":
-    this.shutdown_();
-    break;
-  case "nsPref:changed":
-    if (aData == PREF_DEBUG_ENABLED) {
-      loggingEnabled = Services.prefs.getBoolPref(PREF_DEBUG_ENABLED);
-    }
-    break;
-  }
-}
-
-
-PROT_ListManager.prototype.getGethashUrl = function(tableName) {
-  if (this.tablesData[tableName] && this.tablesData[tableName].gethashUrl) {
-    return this.tablesData[tableName].gethashUrl;
-  }
-  return "";
-}
-
-PROT_ListManager.prototype.getUpdateUrl = function(tableName) {
-  if (this.tablesData[tableName] && this.tablesData[tableName].updateUrl) {
-    return this.tablesData[tableName].updateUrl;
-  }
-  return "";
-}
-
-/**
- * Enable updates for some tables
- * @param tables - an array of table names that need updating
- */
-PROT_ListManager.prototype.enableUpdate = function(tableName) {
-  var table = this.tablesData[tableName];
-  if (table) {
-    log("Enabling table updates for " + tableName);
-    this.needsUpdate_[table.updateUrl][tableName] = true;
-  }
-}
-
-/**
- * Returns true if any table associated with the updateUrl requires updates.
- * @param updateUrl - the updateUrl
- */
-PROT_ListManager.prototype.updatesNeeded_ = function(updateUrl) {
-  let updatesNeeded = false;
-  for (var tableName in this.needsUpdate_[updateUrl]) {
-    if (this.needsUpdate_[updateUrl][tableName]) {
-      updatesNeeded = true;
-    }
-  }
-  return updatesNeeded;
-}
-
-/**
- * Disables updates for some tables
- * @param tables - an array of table names that no longer need updating
- */
-PROT_ListManager.prototype.disableUpdate = function(tableName) {
-  var table = this.tablesData[tableName];
-  if (table) {
-    log("Disabling table updates for " + tableName);
-    this.needsUpdate_[table.updateUrl][tableName] = false;
-    if (!this.updatesNeeded_(table.updateUrl) &&
-        this.updateCheckers_[table.updateUrl]) {
-      this.updateCheckers_[table.updateUrl].cancel();
-      this.updateCheckers_[table.updateUrl] = null;
-    }
-  }
-}
-
-/**
- * Determine if we have some tables that need updating.
- */
-PROT_ListManager.prototype.requireTableUpdates = function() {
-  for (var name in this.tablesData) {
-    // Tables that need updating even if other tables don't require it
-    if (this.needsUpdate_[this.tablesData[name].updateUrl][name]) {
-      return true;
-    }
-  }
-
-  return false;
-}
-
-/**
- *  Set timer to check update after delay
- */
-PROT_ListManager.prototype.setUpdateCheckTimer = function (updateUrl,
-                                                           delay)
-{
-  this.updateCheckers_[updateUrl] = Cc["@mozilla.org/timer;1"]
-                                    .createInstance(Ci.nsITimer);
-  this.updateCheckers_[updateUrl].initWithCallback(() => {
-    this.updateCheckers_[updateUrl] = null;
-    this.checkForUpdates(updateUrl);
-  }, delay, Ci.nsITimer.TYPE_ONE_SHOT);
-}
-/**
- * Acts as a nsIUrlClassifierCallback for getTables.
- */
-PROT_ListManager.prototype.kickoffUpdate_ = function (onDiskTableData)
-{
-  this.startingUpdate_ = false;
-  var initialUpdateDelay = 3000;
-  // Add a fuzz of 0-1 minutes for both v2 and v4 according to Bug 1305478.
-  initialUpdateDelay += Math.floor(Math.random() * (1 * 60 * 1000));
-
-  // If the user has never downloaded tables, do the check now.
-  log("needsUpdate: " + JSON.stringify(this.needsUpdate_, undefined, 2));
-  for (var updateUrl in this.needsUpdate_) {
-    // If we haven't already kicked off updates for this updateUrl, set a
-    // non-repeating timer for it. The timer delay will be reset either on
-    // updateSuccess to this.updateInterval, or backed off on downloadError.
-    // Don't set the updateChecker unless at least one table has updates
-    // enabled.
-    if (this.updatesNeeded_(updateUrl) && !this.updateCheckers_[updateUrl]) {
-      let provider = null;
-      Object.keys(this.tablesData).forEach(function(table) {
-        if (this.tablesData[table].updateUrl === updateUrl) {
-          let newProvider = this.tablesData[table].provider;
-          if (provider) {
-            if (newProvider !== provider) {
-              log("Multiple tables for the same updateURL have a different provider?!");
-            }
-          } else {
-            provider = newProvider;
-          }
-        }
-      }, this);
-      log("Initializing update checker for " + updateUrl
-          + " provided by " + provider);
-
-      // Use the initialUpdateDelay + fuzz unless we had previous updates
-      // and the server told us when to try again.
-      let updateDelay = initialUpdateDelay;
-      let nextUpdatePref = "browser.safebrowsing.provider." + provider +
-                           ".nextupdatetime";
-      let nextUpdate;
-      try {
-        nextUpdate = Services.prefs.getCharPref(nextUpdatePref);
-      } catch (ex) {
-      }
-
-      if (nextUpdate) {
-        updateDelay = Math.min(maxDelayMs, Math.max(0, nextUpdate - Date.now()));
-        log("Next update at " + nextUpdate);
-      }
-      log("Next update " + updateDelay / 60000 + "min from now");
-
-      this.setUpdateCheckTimer(updateUrl, updateDelay);
-    } else {
-      log("No updates needed or already initialized for " + updateUrl);
-    }
-  }
-}
-
-PROT_ListManager.prototype.stopUpdateCheckers = function() {
-  log("Stopping updates");
-  for (var updateUrl in this.updateCheckers_) {
-    if (this.updateCheckers_[updateUrl]) {
-      this.updateCheckers_[updateUrl].cancel();
-      this.updateCheckers_[updateUrl] = null;
-    }
-  }
-}
-
-/**
- * Determine if we have any tables that require updating.  Different
- * Wardens may call us with new tables that need to be updated.
- */
-PROT_ListManager.prototype.maybeToggleUpdateChecking = function() {
-  // We update tables if we have some tables that want updates.  If there
-  // are no tables that want to be updated - we dont need to check anything.
-  if (this.requireTableUpdates()) {
-    log("Starting managing lists");
-
-    // Get the list of existing tables from the DBService before making any
-    // update requests.
-    if (!this.startingUpdate_) {
-      this.startingUpdate_ = true;
-      // check the current state of tables in the database
-      this.dbService_.getTables(this.kickoffUpdate_.bind(this));
-    }
-  } else {
-    log("Stopping managing lists (if currently active)");
-    this.stopUpdateCheckers();                    // Cancel pending updates
-  }
-}
-
-/**
- * Updates our internal tables from the update server
- *
- * @param updateUrl: request updates for tables associated with that url, or
- * for all tables if the url is empty.
- */
-PROT_ListManager.prototype.checkForUpdates = function(updateUrl) {
-  log("checkForUpdates with " + updateUrl);
-  // See if we've triggered the request backoff logic.
-  if (!updateUrl) {
-    return false;
-  }
-  if (!this.requestBackoffs_[updateUrl] ||
-      !this.requestBackoffs_[updateUrl].canMakeRequest()) {
-    log("Can't make update request");
-    return false;
-  }
-  // Grab the current state of the tables from the database
-  this.dbService_.getTables(BindToObject(this.makeUpdateRequest_, this,
-                            updateUrl));
-  return true;
-}
-
-/**
- * Method that fires the actual HTTP update request.
- * First we reset any tables that have disappeared.
- * @param tableData List of table data already in the database, in the form
- *        tablename;<chunk ranges>\n
- */
-PROT_ListManager.prototype.makeUpdateRequest_ = function(updateUrl, tableData) {
-  log("this.tablesData: " + JSON.stringify(this.tablesData, undefined, 2));
-  log("existing chunks: " + tableData + "\n");
-  // Disallow blank updateUrls
-  if (!updateUrl) {
-    return;
-  }
-  // An object of the form
-  // { tableList: comma-separated list of tables to request,
-  //   tableNames: map of tables that need updating,
-  //   request: list of tables and existing chunk ranges from tableData
-  // }
-  var streamerMap = { tableList: null,
-                      tableNames: {},
-                      requestPayload: "",
-                      isPostRequest: true };
-
-  let useProtobuf = false;
-  let onceThru = false;
-  for (var tableName in this.tablesData) {
-    // Skip tables not matching this update url
-    if (this.tablesData[tableName].updateUrl != updateUrl) {
-      continue;
-    }
-
-    // Check if |updateURL| is for 'proto'. (only v4 uses protobuf for now.)
-    // We use the table name 'goog-*-proto' and an additional provider "google4"
-    // to describe the v4 settings.
-    let isCurTableProto = tableName.endsWith('-proto');
-    if (!onceThru) {
-      useProtobuf = isCurTableProto;
-      onceThru = true;
-    } else if (useProtobuf !== isCurTableProto) {
-      log('ERROR: Cannot mix "proto" tables with other types ' +
-          'within the same provider.');
-    }
-
-    if (this.needsUpdate_[this.tablesData[tableName].updateUrl][tableName]) {
-      streamerMap.tableNames[tableName] = true;
-    }
-    if (!streamerMap.tableList) {
-      streamerMap.tableList = tableName;
-    } else {
-      streamerMap.tableList += "," + tableName;
-    }
-  }
-
-  if (useProtobuf) {
-    let tableArray = [];
-    Object.keys(streamerMap.tableNames).forEach(aTableName => {
-      if (streamerMap.tableNames[aTableName]) {
-        tableArray.push(aTableName);
-      }
-    });
-
-    // Build the <tablename, stateBase64> mapping.
-    let tableState = {};
-    tableData.split("\n").forEach(line => {
-      let p = line.indexOf(";");
-      if (-1 === p) {
-        return;
-      }
-      let tableName = line.substring(0, p);
-      if (tableName in streamerMap.tableNames) {
-        let metadata = line.substring(p + 1).split(":");
-        let stateBase64 = metadata[0];
-        log(tableName + " ==> " + stateBase64);
-        tableState[tableName] = stateBase64;
-      }
-    });
-
-    // The state is a byte stream which server told us from the
-    // last table update. The state would be used to do the partial
-    // update and the empty string means the table has
-    // never been downloaded. See Bug 1287058 for supporting
-    // partial update.
-    let stateArray = [];
-    tableArray.forEach(listName => {
-      stateArray.push(tableState[listName] || "");
-    });
-
-    log("stateArray: " + stateArray);
-
-    let urlUtils = Cc["@mozilla.org/url-classifier/utils;1"]
-                     .getService(Ci.nsIUrlClassifierUtils);
-
-    streamerMap.requestPayload = urlUtils.makeUpdateRequestV4(tableArray,
-                                                              stateArray,
-                                                              tableArray.length);
-    streamerMap.isPostRequest = false;
-  } else {
-    // Build the request. For each table already in the database, include the
-    // chunk data from the database
-    var lines = tableData.split("\n");
-    for (var i = 0; i < lines.length; i++) {
-      var fields = lines[i].split(";");
-      var name = fields[0];
-      if (streamerMap.tableNames[name]) {
-        streamerMap.requestPayload += lines[i] + "\n";
-        delete streamerMap.tableNames[name];
-      }
-    }
-    // For each requested table that didn't have chunk data in the database,
-    // request it fresh
-    for (let tableName in streamerMap.tableNames) {
-      streamerMap.requestPayload += tableName + ";\n";
-    }
-
-    streamerMap.isPostRequest = true;
-  }
-
-  log("update request: " + JSON.stringify(streamerMap, undefined, 2) + "\n");
-
-  // Don't send an empty request.
-  if (streamerMap.requestPayload.length > 0) {
-    this.makeUpdateRequestForEntry_(updateUrl, streamerMap.tableList,
-                                    streamerMap.requestPayload,
-                                    streamerMap.isPostRequest);
-  } else {
-    // We were disabled between kicking off getTables and now.
-    log("Not sending empty request");
-  }
-}
-
-PROT_ListManager.prototype.makeUpdateRequestForEntry_ = function(updateUrl,
-                                                                 tableList,
-                                                                 requestPayload,
-                                                                 isPostRequest) {
-  log("makeUpdateRequestForEntry_: requestPayload " + requestPayload +
-      " update: " + updateUrl + " tablelist: " + tableList + "\n");
-  var streamer = Cc["@mozilla.org/url-classifier/streamupdater;1"]
-                 .getService(Ci.nsIUrlClassifierStreamUpdater);
-
-  this.requestBackoffs_[updateUrl].noteRequest();
-
-  if (!streamer.downloadUpdates(
-        tableList,
-        requestPayload,
-        isPostRequest,
-        updateUrl,
-        BindToObject(this.updateSuccess_, this, tableList, updateUrl),
-        BindToObject(this.updateError_, this, tableList, updateUrl),
-        BindToObject(this.downloadError_, this, tableList, updateUrl))) {
-    // Our alarm gets reset in one of the 3 callbacks.
-    log("pending update, queued request until later");
-  } else {
-    let table = Object.keys(this.tablesData).find(key => {
-      return this.tablesData[key].updateUrl === updateUrl;
-    });
-    let provider = this.tablesData[table].provider;
-    Services.obs.notifyObservers(null, "safebrowsing-update-begin", provider);
-  }
-}
-
-/**
- * Callback function if the update request succeeded.
- * @param waitForUpdate String The number of seconds that the client should
- *        wait before requesting again.
- */
-PROT_ListManager.prototype.updateSuccess_ = function(tableList, updateUrl,
-                                                     waitForUpdateSec) {
-  log("update success for " + tableList + " from " + updateUrl + ": " +
-      waitForUpdateSec + "\n");
-
-  // The time unit below are all milliseconds if not specified.
-
-  var delay = 0;
-  if (waitForUpdateSec) {
-    delay = parseInt(waitForUpdateSec, 10) * 1000;
-  }
-  // As long as the delay is something sane (5 min to 1 day), update
-  // our delay time for requesting updates. We always use a non-repeating
-  // timer since the delay is set differently at every callback.
-  if (delay > maxDelayMs) {
-    log("Ignoring delay from server (too long), waiting " +
-        maxDelayMs / 60000 + "min");
-    delay = maxDelayMs;
-  } else if (delay < minDelayMs) {
-    log("Ignoring delay from server (too short), waiting " +
-        this.updateInterval / 60000 + "min");
-    delay = this.updateInterval;
-  } else {
-    log("Waiting " + delay / 60000 + "min");
-  }
-
-  this.setUpdateCheckTimer(updateUrl, delay);
-
-  // Let the backoff object know that we completed successfully.
-  this.requestBackoffs_[updateUrl].noteServerResponse(200);
-
-  // Set last update time for provider
-  // Get the provider for these tables, check for consistency
-  let tables = tableList.split(",");
-  let provider = null;
-  for (let table of tables) {
-    let newProvider = this.tablesData[table].provider;
-    if (provider) {
-      if (newProvider !== provider) {
-        log("Multiple tables for the same updateURL have a different provider?!");
-      }
-    } else {
-      provider = newProvider;
-    }
-  }
-
-  // Store the last update time (needed to know if the table is "fresh")
-  // and the next update time (to know when to update next).
-  let lastUpdatePref = "browser.safebrowsing.provider." + provider + ".lastupdatetime";
-  let now = Date.now();
-  log("Setting last update of " + provider + " to " + now);
-  Services.prefs.setCharPref(lastUpdatePref, now.toString());
-
-  let nextUpdatePref = "browser.safebrowsing.provider." + provider + ".nextupdatetime";
-  let targetTime = now + delay;
-  log("Setting next update of " + provider + " to " + targetTime
-      + " (" + delay / 60000 + "min from now)");
-  Services.prefs.setCharPref(nextUpdatePref, targetTime.toString());
-
-  Services.obs.notifyObservers(null, "safebrowsing-update-finished", "success");
-}
-
-/**
- * Callback function if the update request succeeded.
- * @param result String The error code of the failure
- */
-PROT_ListManager.prototype.updateError_ = function(table, updateUrl, result) {
-  log("update error for " + table + " from " + updateUrl + ": " + result + "\n");
-  // There was some trouble applying the updates. Don't try again for at least
-  // updateInterval milliseconds.
-  this.setUpdateCheckTimer(updateUrl, this.updateInterval);
-
-  Services.obs.notifyObservers(null, "safebrowsing-update-finished",
-                               "update error: " + result);
-}
-
-/**
- * Callback function when the download failed
- * @param status String http status or an empty string if connection refused.
- */
-PROT_ListManager.prototype.downloadError_ = function(table, updateUrl, status) {
-  log("download error for " + table + ": " + status + "\n");
-  // If status is empty, then we assume that we got an NS_CONNECTION_REFUSED
-  // error.  In this case, we treat this is a http 500 error.
-  if (!status) {
-    status = 500;
-  }
-  status = parseInt(status, 10);
-  this.requestBackoffs_[updateUrl].noteServerResponse(status);
-  var delay = this.updateInterval;
-  if (this.requestBackoffs_[updateUrl].isErrorStatus(status)) {
-    // Schedule an update for when our backoff is complete
-    delay = this.requestBackoffs_[updateUrl].nextRequestDelay();
-  } else {
-    log("Got non error status for error callback?!");
-  }
-
-  this.setUpdateCheckTimer(updateUrl, delay);
-
-  Services.obs.notifyObservers(null, "safebrowsing-update-finished",
-                               "download error: " + status);
-}
-
-/**
- * Get back-off time for the given provider.
- * Return 0 if we are not in back-off mode.
- */
-PROT_ListManager.prototype.getBackOffTime = function(provider) {
-  let updateUrl = "";
-  for (var table in this.tablesData) {
-    if (this.tablesData[table].provider == provider) {
-      updateUrl = this.tablesData[table].updateUrl;
-      break;
-    }
-  }
-
-  if (!updateUrl || !this.requestBackoffs_[updateUrl]) {
-    return 0;
-  }
-
-  let delay = this.requestBackoffs_[updateUrl].nextRequestDelay();
-  return delay == 0 ? 0 : Date.now() + delay;
-}
-
-PROT_ListManager.prototype.QueryInterface = function(iid) {
-  if (iid.equals(Ci.nsISupports) ||
-      iid.equals(Ci.nsIUrlListManager) ||
-      iid.equals(Ci.nsIObserver) ||
-      iid.equals(Ci.nsITimerCallback))
-    return this;
-
-  throw Components.results.NS_ERROR_NO_INTERFACE;
-}
diff --git a/toolkit/components/url-classifier/content/moz/lang.js b/toolkit/components/url-classifier/content/moz/lang.js
deleted file mode 100644
--- a/toolkit/components/url-classifier/content/moz/lang.js
+++ /dev/null
@@ -1,50 +0,0 @@
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-
-/**
- * lang.js - Some missing JavaScript language features
- */
-
-/**
- * Partially applies a function to a particular "this object" and zero or
- * more arguments. The result is a new function with some arguments of the first
- * function pre-filled and the value of |this| "pre-specified".
- *
- * Remaining arguments specified at call-time are appended to the pre-
- * specified ones.
- *
- * Usage:
- * var barMethBound = BindToObject(myFunction, myObj, "arg1", "arg2");
- * barMethBound("arg3", "arg4");
- *
- * @param fn {string} Reference to the function to be bound
- *
- * @param self {object} Specifies the object which |this| should point to
- * when the function is run. If the value is null or undefined, it will default
- * to the global object.
- *
- * @returns {function} A partially-applied form of the speficied function.
- */
-this.BindToObject = function BindToObject(fn, self, opt_args) {
-  var boundargs = fn.boundArgs_ || [];
-  boundargs = boundargs.concat(Array.slice(arguments, 2, arguments.length));
-
-  if (fn.boundSelf_)
-    self = fn.boundSelf_;
-  if (fn.boundFn_)
-    fn = fn.boundFn_;
-
-  var newfn = function() {
-    // Combine the static args and the new args into one big array
-    var args = boundargs.concat(Array.slice(arguments));
-    return fn.apply(self, args);
-  }
-
-  newfn.boundArgs_ = boundargs;
-  newfn.boundSelf_ = self;
-  newfn.boundFn_ = fn;
-
-  return newfn;
-}
diff --git a/toolkit/components/url-classifier/content/request-backoff.js b/toolkit/components/url-classifier/content/request-backoff.js
deleted file mode 100644
--- a/toolkit/components/url-classifier/content/request-backoff.js
+++ /dev/null
@@ -1,116 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-// This implements logic for stopping requests if the server starts to return
-// too many errors.  If we get MAX_ERRORS errors in ERROR_PERIOD minutes, we
-// back off for TIMEOUT_INCREMENT minutes.  If we get another error
-// immediately after we restart, we double the timeout and add
-// TIMEOUT_INCREMENT minutes, etc.
-// 
-// This is similar to the logic used by the search suggestion service.
-
-// HTTP responses that count as an error.  We also include any 5xx response
-// as an error.
-this.HTTP_FOUND                 = 302;
-this.HTTP_SEE_OTHER             = 303;
-this.HTTP_TEMPORARY_REDIRECT    = 307;
-
-/**
- * @param maxErrors Number of times to request before backing off.
- * @param retryIncrement Time (ms) for each retry before backing off.
- * @param maxRequests Number the number of requests needed to trigger backoff
- * @param requestPeriod Number time (ms) in which maxRequests have to occur to
- *     trigger the backoff behavior (0 to disable maxRequests)
- * @param timeoutIncrement Number time (ms) the starting timeout period
- *     we double this time for consecutive errors
- * @param maxTimeout Number time (ms) maximum timeout period
- */
-this.RequestBackoff =
-function RequestBackoff(maxErrors, retryIncrement,
-                        maxRequests, requestPeriod,
-                        timeoutIncrement, maxTimeout) {
-  this.MAX_ERRORS_ = maxErrors;
-  this.RETRY_INCREMENT_ = retryIncrement;
-  this.MAX_REQUESTS_ = maxRequests;
-  this.REQUEST_PERIOD_ = requestPeriod;
-  this.TIMEOUT_INCREMENT_ = timeoutIncrement;
-  this.MAX_TIMEOUT_ = maxTimeout;
-
-  // Queue of ints keeping the time of all requests
-  this.requestTimes_ = [];
-
-  this.numErrors_ = 0;
-  this.errorTimeout_ = 0;
-  this.nextRequestTime_ = 0;
-}
-
-/**
- * Reset the object for reuse. This deliberately doesn't clear requestTimes_.
- */
-RequestBackoff.prototype.reset = function() {
-  this.numErrors_ = 0;
-  this.errorTimeout_ = 0;
-  this.nextRequestTime_ = 0;
-}
-
-/**
- * Check to see if we can make a request.
- */
-RequestBackoff.prototype.canMakeRequest = function() {
-  var now = Date.now();
-  if (now < this.nextRequestTime_) {
-    return false;
-  }
-
-  return (this.requestTimes_.length < this.MAX_REQUESTS_ ||
-          (now - this.requestTimes_[0]) > this.REQUEST_PERIOD_);
-}
-
-RequestBackoff.prototype.noteRequest = function() {
-  var now = Date.now();
-  this.requestTimes_.push(now);
-
-  // We only care about keeping track of MAX_REQUESTS
-  if (this.requestTimes_.length > this.MAX_REQUESTS_)
-    this.requestTimes_.shift();
-}
-
-RequestBackoff.prototype.nextRequestDelay = function() {
-  return Math.max(0, this.nextRequestTime_ - Date.now());
-}
-
-/**
- * Notify this object of the last server response.  If it's an error,
- */
-RequestBackoff.prototype.noteServerResponse = function(status) {
-  if (this.isErrorStatus(status)) {
-    this.numErrors_++;
-
-    if (this.numErrors_ < this.MAX_ERRORS_)
-      this.errorTimeout_ = this.RETRY_INCREMENT_;
-    else if (this.numErrors_ == this.MAX_ERRORS_)
-      this.errorTimeout_ = this.TIMEOUT_INCREMENT_;
-    else
-      this.errorTimeout_ *= 2;
-
-    this.errorTimeout_ = Math.min(this.errorTimeout_, this.MAX_TIMEOUT_);
-    this.nextRequestTime_ = Date.now() + this.errorTimeout_;
-  } else {
-    // Reset error timeout, allow requests to go through.
-    this.reset();
-  }
-}
-
-/**
- * We consider 302, 303, 307, 4xx, and 5xx http responses to be errors.
- * @param status Number http status
- * @return Boolean true if we consider this http status an error
- */
-RequestBackoff.prototype.isErrorStatus = function(status) {
-  return ((400 <= status && status <= 599) ||
-          HTTP_FOUND == status ||
-          HTTP_SEE_OTHER == status ||
-          HTTP_TEMPORARY_REDIRECT == status);
-}
-
diff --git a/toolkit/components/url-classifier/moz.build b/toolkit/components/url-classifier/moz.build
--- a/toolkit/components/url-classifier/moz.build
+++ b/toolkit/components/url-classifier/moz.build
@@ -49,20 +49,16 @@ SOURCES += [
 # contains variables that conflict with LookupCache.cpp
 SOURCES += [
     'HashStore.cpp',
 ]
 
 EXTRA_COMPONENTS += [
     'nsURLClassifier.manifest',
     'nsUrlClassifierHashCompleter.js',
-]
-
-# Same as JS components that are run through the pre-processor.
-EXTRA_PP_COMPONENTS += [
     'nsUrlClassifierLib.js',
     'nsUrlClassifierListManager.js',
 ]
 
 EXTRA_JS_MODULES += [
     'SafeBrowsing.jsm',
 ]
 
diff --git a/toolkit/components/url-classifier/nsUrlClassifierLib.js b/toolkit/components/url-classifier/nsUrlClassifierLib.js
--- a/toolkit/components/url-classifier/nsUrlClassifierLib.js
+++ b/toolkit/components/url-classifier/nsUrlClassifierLib.js
@@ -1,24 +1,175 @@
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // We wastefully reload the same JS files across components.  This puts all
 // the common JS files used by safebrowsing and url-classifier into a
 // single component.
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const G_GDEBUG = false;
 
 Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
 
-#include ./content/moz/lang.js
-#include ./content/request-backoff.js
+/**
+ * Partially applies a function to a particular "this object" and zero or
+ * more arguments. The result is a new function with some arguments of the first
+ * function pre-filled and the value of |this| "pre-specified".
+ *
+ * Remaining arguments specified at call-time are appended to the pre-
+ * specified ones.
+ *
+ * Usage:
+ * var barMethBound = BindToObject(myFunction, myObj, "arg1", "arg2");
+ * barMethBound("arg3", "arg4");
+ *
+ * @param fn {string} Reference to the function to be bound
+ *
+ * @param self {object} Specifies the object which |this| should point to
+ * when the function is run. If the value is null or undefined, it will default
+ * to the global object.
+ *
+ * @returns {function} A partially-applied form of the speficied function.
+ */
+this.BindToObject = function BindToObject(fn, self, opt_args) {
+  var boundargs = fn.boundArgs_ || [];
+  boundargs = boundargs.concat(Array.slice(arguments, 2, arguments.length));
+
+  if (fn.boundSelf_)
+    self = fn.boundSelf_;
+  if (fn.boundFn_)
+    fn = fn.boundFn_;
+
+  var newfn = function() {
+    // Combine the static args and the new args into one big array
+    var args = boundargs.concat(Array.slice(arguments));
+    return fn.apply(self, args);
+  }
+
+  newfn.boundArgs_ = boundargs;
+  newfn.boundSelf_ = self;
+  newfn.boundFn_ = fn;
+
+  return newfn;
+}
+
+// This implements logic for stopping requests if the server starts to return
+// too many errors.  If we get MAX_ERRORS errors in ERROR_PERIOD minutes, we
+// back off for TIMEOUT_INCREMENT minutes.  If we get another error
+// immediately after we restart, we double the timeout and add
+// TIMEOUT_INCREMENT minutes, etc.
+// 
+// This is similar to the logic used by the search suggestion service.
+
+// HTTP responses that count as an error.  We also include any 5xx response
+// as an error.
+this.HTTP_FOUND                 = 302;
+this.HTTP_SEE_OTHER             = 303;
+this.HTTP_TEMPORARY_REDIRECT    = 307;
+
+/**
+ * @param maxErrors Number of times to request before backing off.
+ * @param retryIncrement Time (ms) for each retry before backing off.
+ * @param maxRequests Number the number of requests needed to trigger backoff
+ * @param requestPeriod Number time (ms) in which maxRequests have to occur to
+ *     trigger the backoff behavior (0 to disable maxRequests)
+ * @param timeoutIncrement Number time (ms) the starting timeout period
+ *     we double this time for consecutive errors
+ * @param maxTimeout Number time (ms) maximum timeout period
+ */
+this.RequestBackoff =
+function RequestBackoff(maxErrors, retryIncrement,
+                        maxRequests, requestPeriod,
+                        timeoutIncrement, maxTimeout) {
+  this.MAX_ERRORS_ = maxErrors;
+  this.RETRY_INCREMENT_ = retryIncrement;
+  this.MAX_REQUESTS_ = maxRequests;
+  this.REQUEST_PERIOD_ = requestPeriod;
+  this.TIMEOUT_INCREMENT_ = timeoutIncrement;
+  this.MAX_TIMEOUT_ = maxTimeout;
+
+  // Queue of ints keeping the time of all requests
+  this.requestTimes_ = [];
+
+  this.numErrors_ = 0;
+  this.errorTimeout_ = 0;
+  this.nextRequestTime_ = 0;
+}
+
+/**
+ * Reset the object for reuse. This deliberately doesn't clear requestTimes_.
+ */
+RequestBackoff.prototype.reset = function() {
+  this.numErrors_ = 0;
+  this.errorTimeout_ = 0;
+  this.nextRequestTime_ = 0;
+}
+
+/**
+ * Check to see if we can make a request.
+ */
+RequestBackoff.prototype.canMakeRequest = function() {
+  var now = Date.now();
+  if (now < this.nextRequestTime_) {
+    return false;
+  }
+
+  return (this.requestTimes_.length < this.MAX_REQUESTS_ ||
+          (now - this.requestTimes_[0]) > this.REQUEST_PERIOD_);
+}
+
+RequestBackoff.prototype.noteRequest = function() {
+  var now = Date.now();
+  this.requestTimes_.push(now);
+
+  // We only care about keeping track of MAX_REQUESTS
+  if (this.requestTimes_.length > this.MAX_REQUESTS_)
+    this.requestTimes_.shift();
+}
+
+RequestBackoff.prototype.nextRequestDelay = function() {
+  return Math.max(0, this.nextRequestTime_ - Date.now());
+}
+
+/**
+ * Notify this object of the last server response.  If it's an error,
+ */
+RequestBackoff.prototype.noteServerResponse = function(status) {
+  if (this.isErrorStatus(status)) {
+    this.numErrors_++;
+
+    if (this.numErrors_ < this.MAX_ERRORS_)
+      this.errorTimeout_ = this.RETRY_INCREMENT_;
+    else if (this.numErrors_ == this.MAX_ERRORS_)
+      this.errorTimeout_ = this.TIMEOUT_INCREMENT_;
+    else
+      this.errorTimeout_ *= 2;
+
+    this.errorTimeout_ = Math.min(this.errorTimeout_, this.MAX_TIMEOUT_);
+    this.nextRequestTime_ = Date.now() + this.errorTimeout_;
+  } else {
+    // Reset error timeout, allow requests to go through.
+    this.reset();
+  }
+}
+
+/**
+ * We consider 302, 303, 307, 4xx, and 5xx http responses to be errors.
+ * @param status Number http status
+ * @return Boolean true if we consider this http status an error
+ */
+RequestBackoff.prototype.isErrorStatus = function(status) {
+  return ((400 <= status && status <= 599) ||
+          HTTP_FOUND == status ||
+          HTTP_SEE_OTHER == status ||
+          HTTP_TEMPORARY_REDIRECT == status);
+}
 
 // Wrap a general-purpose |RequestBackoff| to a v4-specific one
 // since both listmanager and hashcompleter would use it.
 // Note that |maxRequests| and |requestPeriod| is still configurable
 // to throttle pending requests.
 function RequestBackoffV4(maxRequests, requestPeriod) {
   let rand = Math.random();
   let retryInterval = Math.floor(15 * 60 * 1000 * (rand + 1));   // 15 ~ 30 min.
diff --git a/toolkit/components/url-classifier/nsUrlClassifierListManager.js b/toolkit/components/url-classifier/nsUrlClassifierListManager.js
--- a/toolkit/components/url-classifier/nsUrlClassifierListManager.js
+++ b/toolkit/components/url-classifier/nsUrlClassifierListManager.js
@@ -1,18 +1,645 @@
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
+const Cu = Components.utils;
 
-Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+
+// This is the only implementation of nsIUrlListManager.
+// A class that manages lists, namely white and black lists for
+// phishing or malware protection. The ListManager knows how to fetch,
+// update, and store lists.
+//
+// There is a single listmanager for the whole application.
+//
+// TODO more comprehensive update tests, for example add unittest check
+//      that the listmanagers tables are properly written on updates
+
+// Lower and upper limits on the server-provided polling frequency
+const minDelayMs = 5 * 60 * 1000;
+const maxDelayMs = 24 * 60 * 60 * 1000;
+const defaultUpdateIntervalMs = 30 * 60 * 1000;
+const PREF_DEBUG_ENABLED = "browser.safebrowsing.debug";
+
+let loggingEnabled = false;
+
+// Log only if browser.safebrowsing.debug is true
+this.log = function log(...stuff) {
+  if (!loggingEnabled) {
+    return;
+  }
+
+  var d = new Date();
+  let msg = "listmanager: " + d.toTimeString() + ": " + stuff.join(" ");
+  msg = Services.urlFormatter.trimSensitiveURLs(msg);
+  Services.console.logStringMessage(msg);
+  dump(msg + "\n");
+}
+
+/**
+ * A ListManager keeps track of black and white lists and knows
+ * how to update them.
+ *
+ * @constructor
+ */
+this.PROT_ListManager = function PROT_ListManager() {
+  loggingEnabled = Services.prefs.getBoolPref(PREF_DEBUG_ENABLED);
+
+  log("Initializing list manager");
+  this.updateInterval = defaultUpdateIntervalMs;
+
+  // A map of tableNames to objects of type
+  // { updateUrl: <updateUrl>, gethashUrl: <gethashUrl> }
+  this.tablesData = {};
+  // A map of updateUrls to maps of tables requiring updates, e.g.
+  // { safebrowsing-update-url: { goog-phish-shavar: true,
+  //                              goog-malware-shavar: true }
+  this.needsUpdate_ = {};
+
+  // A map of updateUrls to single-use nsITimer. An entry exists if and only if
+  // there is at least one table with updates enabled for that url. nsITimers
+  // are reset when enabling/disabling updates or on update callbacks (update
+  // success, update failure, download error).
+  this.updateCheckers_ = {};
+  this.requestBackoffs_ = {};
+  this.dbService_ = Cc["@mozilla.org/url-classifier/dbservice;1"]
+                   .getService(Ci.nsIUrlClassifierDBService);
+
+  Services.obs.addObserver(this, "quit-application");
+  Services.prefs.addObserver(PREF_DEBUG_ENABLED, this);
+}
+
+/**
+ * Register a new table table
+ * @param tableName - the name of the table
+ * @param updateUrl - the url for updating the table
+ * @param gethashUrl - the url for fetching hash completions
+ * @returns true if the table could be created; false otherwise
+ */
+PROT_ListManager.prototype.registerTable = function(tableName,
+                                                    providerName,
+                                                    updateUrl,
+                                                    gethashUrl) {
+  this.tablesData[tableName] = {};
+  if (!updateUrl) {
+    log("Can't register table " + tableName + " without updateUrl");
+    return false;
+  }
+  log("registering " + tableName + " with " + updateUrl);
+  this.tablesData[tableName].updateUrl = updateUrl;
+  this.tablesData[tableName].gethashUrl = gethashUrl;
+  this.tablesData[tableName].provider = providerName;
+
+  // Keep track of all of our update URLs.
+  if (!this.needsUpdate_[updateUrl]) {
+    this.needsUpdate_[updateUrl] = {};
+
+    // Using the V4 backoff algorithm for both V2 and V4. See bug 1273398.
+    this.requestBackoffs_[updateUrl] = new RequestBackoffV4(
+                                            4 /* num requests */,
+                                   60*60*1000 /* request time, 60 min */);
+  }
+  this.needsUpdate_[updateUrl][tableName] = false;
+
+  return true;
+}
+
+/**
+ * Delete all of our data tables which seem to leak otherwise.
+ * Remove observers
+ */
+PROT_ListManager.prototype.shutdown_ = function() {
+  this.stopUpdateCheckers();
+  for (var name in this.tablesData) {
+    delete this.tablesData[name];
+  }
+  Services.obs.removeObserver(this, "quit-application");
+  Services.prefs.removeObserver(PREF_DEBUG_ENABLED, this);
+}
+
+/**
+ * xpcom-shutdown callback
+ */
+PROT_ListManager.prototype.observe = function(aSubject, aTopic, aData) {
+  switch (aTopic) {
+  case "quit-application":
+    this.shutdown_();
+    break;
+  case "nsPref:changed":
+    if (aData == PREF_DEBUG_ENABLED) {
+      loggingEnabled = Services.prefs.getBoolPref(PREF_DEBUG_ENABLED);
+    }
+    break;
+  }
+}
+
+
+PROT_ListManager.prototype.getGethashUrl = function(tableName) {
+  if (this.tablesData[tableName] && this.tablesData[tableName].gethashUrl) {
+    return this.tablesData[tableName].gethashUrl;
+  }
+  return "";
+}
+
+PROT_ListManager.prototype.getUpdateUrl = function(tableName) {
+  if (this.tablesData[tableName] && this.tablesData[tableName].updateUrl) {
+    return this.tablesData[tableName].updateUrl;
+  }
+  return "";
+}
+
+/**
+ * Enable updates for some tables
+ * @param tables - an array of table names that need updating
+ */
+PROT_ListManager.prototype.enableUpdate = function(tableName) {
+  var table = this.tablesData[tableName];
+  if (table) {
+    log("Enabling table updates for " + tableName);
+    this.needsUpdate_[table.updateUrl][tableName] = true;
+  }
+}
+
+/**
+ * Returns true if any table associated with the updateUrl requires updates.
+ * @param updateUrl - the updateUrl
+ */
+PROT_ListManager.prototype.updatesNeeded_ = function(updateUrl) {
+  let updatesNeeded = false;
+  for (var tableName in this.needsUpdate_[updateUrl]) {
+    if (this.needsUpdate_[updateUrl][tableName]) {
+      updatesNeeded = true;
+    }
+  }
+  return updatesNeeded;
+}
+
+/**
+ * Disables updates for some tables
+ * @param tables - an array of table names that no longer need updating
+ */
+PROT_ListManager.prototype.disableUpdate = function(tableName) {
+  var table = this.tablesData[tableName];
+  if (table) {
+    log("Disabling table updates for " + tableName);
+    this.needsUpdate_[table.updateUrl][tableName] = false;
+    if (!this.updatesNeeded_(table.updateUrl) &&
+        this.updateCheckers_[table.updateUrl]) {
+      this.updateCheckers_[table.updateUrl].cancel();
+      this.updateCheckers_[table.updateUrl] = null;
+    }
+  }
+}
+
+/**
+ * Determine if we have some tables that need updating.
+ */
+PROT_ListManager.prototype.requireTableUpdates = function() {
+  for (var name in this.tablesData) {
+    // Tables that need updating even if other tables don't require it
+    if (this.needsUpdate_[this.tablesData[name].updateUrl][name]) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+/**
+ *  Set timer to check update after delay
+ */
+PROT_ListManager.prototype.setUpdateCheckTimer = function (updateUrl,
+                                                           delay)
+{
+  this.updateCheckers_[updateUrl] = Cc["@mozilla.org/timer;1"]
+                                    .createInstance(Ci.nsITimer);
+  this.updateCheckers_[updateUrl].initWithCallback(() => {
+    this.updateCheckers_[updateUrl] = null;
+    this.checkForUpdates(updateUrl);
+  }, delay, Ci.nsITimer.TYPE_ONE_SHOT);
+}
+/**
+ * Acts as a nsIUrlClassifierCallback for getTables.
+ */
+PROT_ListManager.prototype.kickoffUpdate_ = function (onDiskTableData)
+{
+  this.startingUpdate_ = false;
+  var initialUpdateDelay = 3000;
+  // Add a fuzz of 0-1 minutes for both v2 and v4 according to Bug 1305478.
+  initialUpdateDelay += Math.floor(Math.random() * (1 * 60 * 1000));
+
+  // If the user has never downloaded tables, do the check now.
+  log("needsUpdate: " + JSON.stringify(this.needsUpdate_, undefined, 2));
+  for (var updateUrl in this.needsUpdate_) {
+    // If we haven't already kicked off updates for this updateUrl, set a
+    // non-repeating timer for it. The timer delay will be reset either on
+    // updateSuccess to this.updateInterval, or backed off on downloadError.
+    // Don't set the updateChecker unless at least one table has updates
+    // enabled.
+    if (this.updatesNeeded_(updateUrl) && !this.updateCheckers_[updateUrl]) {
+      let provider = null;
+      Object.keys(this.tablesData).forEach(function(table) {
+        if (this.tablesData[table].updateUrl === updateUrl) {
+          let newProvider = this.tablesData[table].provider;
+          if (provider) {
+            if (newProvider !== provider) {
+              log("Multiple tables for the same updateURL have a different provider?!");
+            }
+          } else {
+            provider = newProvider;
+          }
+        }
+      }, this);
+      log("Initializing update checker for " + updateUrl
+          + " provided by " + provider);
+
+      // Use the initialUpdateDelay + fuzz unless we had previous updates
+      // and the server told us when to try again.
+      let updateDelay = initialUpdateDelay;
+      let nextUpdatePref = "browser.safebrowsing.provider." + provider +
+                           ".nextupdatetime";
+      let nextUpdate;
+      try {
+        nextUpdate = Services.prefs.getCharPref(nextUpdatePref);
+      } catch (ex) {
+      }
+
+      if (nextUpdate) {
+        updateDelay = Math.min(maxDelayMs, Math.max(0, nextUpdate - Date.now()));
+        log("Next update at " + nextUpdate);
+      }
+      log("Next update " + updateDelay / 60000 + "min from now");
+
+      this.setUpdateCheckTimer(updateUrl, updateDelay);
+    } else {
+      log("No updates needed or already initialized for " + updateUrl);
+    }
+  }
+}
+
+PROT_ListManager.prototype.stopUpdateCheckers = function() {
+  log("Stopping updates");
+  for (var updateUrl in this.updateCheckers_) {
+    if (this.updateCheckers_[updateUrl]) {
+      this.updateCheckers_[updateUrl].cancel();
+      this.updateCheckers_[updateUrl] = null;
+    }
+  }
+}
+
+/**
+ * Determine if we have any tables that require updating.  Different
+ * Wardens may call us with new tables that need to be updated.
+ */
+PROT_ListManager.prototype.maybeToggleUpdateChecking = function() {
+  // We update tables if we have some tables that want updates.  If there
+  // are no tables that want to be updated - we dont need to check anything.
+  if (this.requireTableUpdates()) {
+    log("Starting managing lists");
+
+    // Get the list of existing tables from the DBService before making any
+    // update requests.
+    if (!this.startingUpdate_) {
+      this.startingUpdate_ = true;
+      // check the current state of tables in the database
+      this.dbService_.getTables(this.kickoffUpdate_.bind(this));
+    }
+  } else {
+    log("Stopping managing lists (if currently active)");
+    this.stopUpdateCheckers();                    // Cancel pending updates
+  }
+}
 
-#include ./content/listmanager.js
+/**
+ * Updates our internal tables from the update server
+ *
+ * @param updateUrl: request updates for tables associated with that url, or
+ * for all tables if the url is empty.
+ */
+PROT_ListManager.prototype.checkForUpdates = function(updateUrl) {
+  log("checkForUpdates with " + updateUrl);
+  // See if we've triggered the request backoff logic.
+  if (!updateUrl) {
+    return false;
+  }
+  if (!this.requestBackoffs_[updateUrl] ||
+      !this.requestBackoffs_[updateUrl].canMakeRequest()) {
+    log("Can't make update request");
+    return false;
+  }
+  // Grab the current state of the tables from the database
+  this.dbService_.getTables(BindToObject(this.makeUpdateRequest_, this,
+                            updateUrl));
+  return true;
+}
+
+/**
+ * Method that fires the actual HTTP update request.
+ * First we reset any tables that have disappeared.
+ * @param tableData List of table data already in the database, in the form
+ *        tablename;<chunk ranges>\n
+ */
+PROT_ListManager.prototype.makeUpdateRequest_ = function(updateUrl, tableData) {
+  log("this.tablesData: " + JSON.stringify(this.tablesData, undefined, 2));
+  log("existing chunks: " + tableData + "\n");
+  // Disallow blank updateUrls
+  if (!updateUrl) {
+    return;
+  }
+  // An object of the form
+  // { tableList: comma-separated list of tables to request,
+  //   tableNames: map of tables that need updating,
+  //   request: list of tables and existing chunk ranges from tableData
+  // }
+  var streamerMap = { tableList: null,
+                      tableNames: {},
+                      requestPayload: "",
+                      isPostRequest: true };
+
+  let useProtobuf = false;
+  let onceThru = false;
+  for (var tableName in this.tablesData) {
+    // Skip tables not matching this update url
+    if (this.tablesData[tableName].updateUrl != updateUrl) {
+      continue;
+    }
+
+    // Check if |updateURL| is for 'proto'. (only v4 uses protobuf for now.)
+    // We use the table name 'goog-*-proto' and an additional provider "google4"
+    // to describe the v4 settings.
+    let isCurTableProto = tableName.endsWith('-proto');
+    if (!onceThru) {
+      useProtobuf = isCurTableProto;
+      onceThru = true;
+    } else if (useProtobuf !== isCurTableProto) {
+      log('ERROR: Cannot mix "proto" tables with other types ' +
+          'within the same provider.');
+    }
+
+    if (this.needsUpdate_[this.tablesData[tableName].updateUrl][tableName]) {
+      streamerMap.tableNames[tableName] = true;
+    }
+    if (!streamerMap.tableList) {
+      streamerMap.tableList = tableName;
+    } else {
+      streamerMap.tableList += "," + tableName;
+    }
+  }
+
+  if (useProtobuf) {
+    let tableArray = [];
+    Object.keys(streamerMap.tableNames).forEach(aTableName => {
+      if (streamerMap.tableNames[aTableName]) {
+        tableArray.push(aTableName);
+      }
+    });
+
+    // Build the <tablename, stateBase64> mapping.
+    let tableState = {};
+    tableData.split("\n").forEach(line => {
+      let p = line.indexOf(";");
+      if (-1 === p) {
+        return;
+      }
+      let tableName = line.substring(0, p);
+      if (tableName in streamerMap.tableNames) {
+        let metadata = line.substring(p + 1).split(":");
+        let stateBase64 = metadata[0];
+        log(tableName + " ==> " + stateBase64);
+        tableState[tableName] = stateBase64;
+      }
+    });
+
+    // The state is a byte stream which server told us from the
+    // last table update. The state would be used to do the partial
+    // update and the empty string means the table has
+    // never been downloaded. See Bug 1287058 for supporting
+    // partial update.
+    let stateArray = [];
+    tableArray.forEach(listName => {
+      stateArray.push(tableState[listName] || "");
+    });
+
+    log("stateArray: " + stateArray);
+
+    let urlUtils = Cc["@mozilla.org/url-classifier/utils;1"]
+                     .getService(Ci.nsIUrlClassifierUtils);
+
+    streamerMap.requestPayload = urlUtils.makeUpdateRequestV4(tableArray,
+                                                              stateArray,
+                                                              tableArray.length);
+    streamerMap.isPostRequest = false;
+  } else {
+    // Build the request. For each table already in the database, include the
+    // chunk data from the database
+    var lines = tableData.split("\n");
+    for (var i = 0; i < lines.length; i++) {
+      var fields = lines[i].split(";");
+      var name = fields[0];
+      if (streamerMap.tableNames[name]) {
+        streamerMap.requestPayload += lines[i] + "\n";
+        delete streamerMap.tableNames[name];
+      }
+    }
+    // For each requested table that didn't have chunk data in the database,
+    // request it fresh
+    for (let tableName in streamerMap.tableNames) {
+      streamerMap.requestPayload += tableName + ";\n";
+    }
+
+    streamerMap.isPostRequest = true;
+  }
+
+  log("update request: " + JSON.stringify(streamerMap, undefined, 2) + "\n");
+
+  // Don't send an empty request.
+  if (streamerMap.requestPayload.length > 0) {
+    this.makeUpdateRequestForEntry_(updateUrl, streamerMap.tableList,
+                                    streamerMap.requestPayload,
+                                    streamerMap.isPostRequest);
+  } else {
+    // We were disabled between kicking off getTables and now.
+    log("Not sending empty request");
+  }
+}
+
+PROT_ListManager.prototype.makeUpdateRequestForEntry_ = function(updateUrl,
+                                                                 tableList,
+                                                                 requestPayload,
+                                                                 isPostRequest) {
+  log("makeUpdateRequestForEntry_: requestPayload " + requestPayload +
+      " update: " + updateUrl + " tablelist: " + tableList + "\n");
+  var streamer = Cc["@mozilla.org/url-classifier/streamupdater;1"]
+                 .getService(Ci.nsIUrlClassifierStreamUpdater);
+
+  this.requestBackoffs_[updateUrl].noteRequest();
+
+  if (!streamer.downloadUpdates(
+        tableList,
+        requestPayload,
+        isPostRequest,
+        updateUrl,
+        BindToObject(this.updateSuccess_, this, tableList, updateUrl),
+        BindToObject(this.updateError_, this, tableList, updateUrl),
+        BindToObject(this.downloadError_, this, tableList, updateUrl))) {
+    // Our alarm gets reset in one of the 3 callbacks.
+    log("pending update, queued request until later");
+  } else {
+    let table = Object.keys(this.tablesData).find(key => {
+      return this.tablesData[key].updateUrl === updateUrl;
+    });
+    let provider = this.tablesData[table].provider;
+    Services.obs.notifyObservers(null, "safebrowsing-update-begin", provider);
+  }
+}
+
+/**
+ * Callback function if the update request succeeded.
+ * @param waitForUpdate String The number of seconds that the client should
+ *        wait before requesting again.
+ */
+PROT_ListManager.prototype.updateSuccess_ = function(tableList, updateUrl,
+                                                     waitForUpdateSec) {
+  log("update success for " + tableList + " from " + updateUrl + ": " +
+      waitForUpdateSec + "\n");
+
+  // The time unit below are all milliseconds if not specified.
+
+  var delay = 0;
+  if (waitForUpdateSec) {
+    delay = parseInt(waitForUpdateSec, 10) * 1000;
+  }
+  // As long as the delay is something sane (5 min to 1 day), update
+  // our delay time for requesting updates. We always use a non-repeating
+  // timer since the delay is set differently at every callback.
+  if (delay > maxDelayMs) {
+    log("Ignoring delay from server (too long), waiting " +
+        maxDelayMs / 60000 + "min");
+    delay = maxDelayMs;
+  } else if (delay < minDelayMs) {
+    log("Ignoring delay from server (too short), waiting " +
+        this.updateInterval / 60000 + "min");
+    delay = this.updateInterval;
+  } else {
+    log("Waiting " + delay / 60000 + "min");
+  }
+
+  this.setUpdateCheckTimer(updateUrl, delay);
+
+  // Let the backoff object know that we completed successfully.
+  this.requestBackoffs_[updateUrl].noteServerResponse(200);
+
+  // Set last update time for provider
+  // Get the provider for these tables, check for consistency
+  let tables = tableList.split(",");
+  let provider = null;
+  for (let table of tables) {
+    let newProvider = this.tablesData[table].provider;
+    if (provider) {
+      if (newProvider !== provider) {
+        log("Multiple tables for the same updateURL have a different provider?!");
+      }
+    } else {
+      provider = newProvider;
+    }
+  }
+
+  // Store the last update time (needed to know if the table is "fresh")
+  // and the next update time (to know when to update next).
+  let lastUpdatePref = "browser.safebrowsing.provider." + provider + ".lastupdatetime";
+  let now = Date.now();
+  log("Setting last update of " + provider + " to " + now);
+  Services.prefs.setCharPref(lastUpdatePref, now.toString());
+
+  let nextUpdatePref = "browser.safebrowsing.provider." + provider + ".nextupdatetime";
+  let targetTime = now + delay;
+  log("Setting next update of " + provider + " to " + targetTime
+      + " (" + delay / 60000 + "min from now)");
+  Services.prefs.setCharPref(nextUpdatePref, targetTime.toString());
+
+  Services.obs.notifyObservers(null, "safebrowsing-update-finished", "success");
+}
+
+/**
+ * Callback function if the update request succeeded.
+ * @param result String The error code of the failure
+ */
+PROT_ListManager.prototype.updateError_ = function(table, updateUrl, result) {
+  log("update error for " + table + " from " + updateUrl + ": " + result + "\n");
+  // There was some trouble applying the updates. Don't try again for at least
+  // updateInterval milliseconds.
+  this.setUpdateCheckTimer(updateUrl, this.updateInterval);
+
+  Services.obs.notifyObservers(null, "safebrowsing-update-finished",
+                               "update error: " + result);
+}
+
+/**
+ * Callback function when the download failed
+ * @param status String http status or an empty string if connection refused.
+ */
+PROT_ListManager.prototype.downloadError_ = function(table, updateUrl, status) {
+  log("download error for " + table + ": " + status + "\n");
+  // If status is empty, then we assume that we got an NS_CONNECTION_REFUSED
+  // error.  In this case, we treat this is a http 500 error.
+  if (!status) {
+    status = 500;
+  }
+  status = parseInt(status, 10);
+  this.requestBackoffs_[updateUrl].noteServerResponse(status);
+  var delay = this.updateInterval;
+  if (this.requestBackoffs_[updateUrl].isErrorStatus(status)) {
+    // Schedule an update for when our backoff is complete
+    delay = this.requestBackoffs_[updateUrl].nextRequestDelay();
+  } else {
+    log("Got non error status for error callback?!");
+  }
+
+  this.setUpdateCheckTimer(updateUrl, delay);
+
+  Services.obs.notifyObservers(null, "safebrowsing-update-finished",
+                               "download error: " + status);
+}
+
+/**
+ * Get back-off time for the given provider.
+ * Return 0 if we are not in back-off mode.
+ */
+PROT_ListManager.prototype.getBackOffTime = function(provider) {
+  let updateUrl = "";
+  for (var table in this.tablesData) {
+    if (this.tablesData[table].provider == provider) {
+      updateUrl = this.tablesData[table].updateUrl;
+      break;
+    }
+  }
+
+  if (!updateUrl || !this.requestBackoffs_[updateUrl]) {
+    return 0;
+  }
+
+  let delay = this.requestBackoffs_[updateUrl].nextRequestDelay();
+  return delay == 0 ? 0 : Date.now() + delay;
+}
+
+PROT_ListManager.prototype.QueryInterface = function(iid) {
+  if (iid.equals(Ci.nsISupports) ||
+      iid.equals(Ci.nsIUrlListManager) ||
+      iid.equals(Ci.nsIObserver) ||
+      iid.equals(Ci.nsITimerCallback))
+    return this;
+
+  throw Components.results.NS_ERROR_NO_INTERFACE;
+}
 
 var modScope = this;
 function Init() {
   // Pull the library in.
   var jslib = Cc["@mozilla.org/url-classifier/jslib;1"]
               .getService().wrappedJSObject;
   modScope.BindToObject = jslib.BindToObject;
   modScope.RequestBackoffV4 = jslib.RequestBackoffV4;
diff --git a/toolkit/components/url-classifier/nsUrlClassifierStreamUpdater.cpp b/toolkit/components/url-classifier/nsUrlClassifierStreamUpdater.cpp
--- a/toolkit/components/url-classifier/nsUrlClassifierStreamUpdater.cpp
+++ b/toolkit/components/url-classifier/nsUrlClassifierStreamUpdater.cpp
@@ -93,17 +93,18 @@ nsUrlClassifierStreamUpdater::nsUrlClass
 
 NS_IMPL_ISUPPORTS(nsUrlClassifierStreamUpdater,
                   nsIUrlClassifierStreamUpdater,
                   nsIUrlClassifierUpdateObserver,
                   nsIRequestObserver,
                   nsIStreamListener,
                   nsIObserver,
                   nsIInterfaceRequestor,
-                  nsITimerCallback)
+                  nsITimerCallback,
+                  nsINamed)
 
 /**
  * Clear out the update.
  */
 void
 nsUrlClassifierStreamUpdater::DownloadDone()
 {
   LOG(("nsUrlClassifierStreamUpdater::DownloadDone [this=%p]", this));
@@ -1007,8 +1008,18 @@ nsUrlClassifierStreamUpdater::Notify(nsI
 
     return NS_OK;
   }
 
   MOZ_ASSERT_UNREACHABLE("A timer is fired from nowhere.");
   return NS_OK;
 }
 
+////////////////////////////////////////////////////////////////////////
+//// nsINamed
+
+NS_IMETHODIMP
+nsUrlClassifierStreamUpdater::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsUrlClassifierStreamUpdater");
+  return NS_OK;
+}
+
diff --git a/toolkit/components/url-classifier/nsUrlClassifierStreamUpdater.h b/toolkit/components/url-classifier/nsUrlClassifierStreamUpdater.h
--- a/toolkit/components/url-classifier/nsUrlClassifierStreamUpdater.h
+++ b/toolkit/components/url-classifier/nsUrlClassifierStreamUpdater.h
@@ -4,45 +4,48 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsUrlClassifierStreamUpdater_h_
 #define nsUrlClassifierStreamUpdater_h_
 
 #include <nsISupportsUtils.h>
 
 #include "nsCOMPtr.h"
+#include "nsINamed.h"
 #include "nsIObserver.h"
 #include "nsIUrlClassifierStreamUpdater.h"
 #include "nsIStreamListener.h"
 #include "nsIChannel.h"
 #include "nsTArray.h"
 #include "nsITimer.h"
 #include "mozilla/Attributes.h"
 
 // Forward declare pointers
 class nsIURI;
 
 class nsUrlClassifierStreamUpdater final : public nsIUrlClassifierStreamUpdater,
                                            public nsIUrlClassifierUpdateObserver,
                                            public nsIStreamListener,
                                            public nsIObserver,
                                            public nsIInterfaceRequestor,
-                                           public nsITimerCallback
+                                           public nsITimerCallback,
+                                           public nsINamed
 {
 public:
   nsUrlClassifierStreamUpdater();
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIURLCLASSIFIERSTREAMUPDATER
   NS_DECL_NSIURLCLASSIFIERUPDATEOBSERVER
   NS_DECL_NSIINTERFACEREQUESTOR
   NS_DECL_NSIREQUESTOBSERVER
   NS_DECL_NSISTREAMLISTENER
   NS_DECL_NSIOBSERVER
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
 private:
   // No subclassing
   ~nsUrlClassifierStreamUpdater() {}
 
   // When the dbservice sends an UpdateComplete or UpdateFailure, we call this
   // to reset the stream updater.
   void DownloadDone();
diff --git a/toolkit/crashreporter/client/crashreporter.cpp b/toolkit/crashreporter/client/crashreporter.cpp
--- a/toolkit/crashreporter/client/crashreporter.cpp
+++ b/toolkit/crashreporter/client/crashreporter.cpp
@@ -434,22 +434,16 @@ void SendCompleted(bool success, const s
       UIPruneSavedDumps(directory);
       WriteSubmissionEvent(Failed, "");
     }
   } else {
     WriteSubmissionEvent(Failed, "");
   }
 }
 
-bool ShouldEnableSending()
-{
-  srand(time(0));
-  return ((rand() % 100) < MOZ_CRASHREPORTER_ENABLE_PERCENT);
-}
-
 static string ComputeDumpHash() {
 #ifdef XP_LINUX
   // On Linux we rely on the system-provided libcurl which uses nss so we have
   // to also use the system-provided nss instead of the ones we have bundled.
   const char* libnssNames[] = {
     "libnss3.so",
 #ifndef HAVE_64BIT_BUILD
     // 32-bit versions on 64-bit hosts
diff --git a/toolkit/crashreporter/client/crashreporter.h b/toolkit/crashreporter/client/crashreporter.h
--- a/toolkit/crashreporter/client/crashreporter.h
+++ b/toolkit/crashreporter/client/crashreporter.h
@@ -110,17 +110,16 @@ namespace CrashReporter {
                     StringTable& strings,
                     bool escape);
   bool WriteStringsToFile(const std::string& path,
                           const std::string& header,
                           StringTable& strings,
                           bool escape);
   void LogMessage(const std::string& message);
   void DeleteDump();
-  bool ShouldEnableSending();
 
   // Telemetry ping
   bool SendCrashPing(StringTable& strings, const std::string& hash,
                      std::string& pingUuid, const std::string& pingDir);
 
   static const unsigned int kSaveCount = 10;
 }
 
diff --git a/toolkit/crashreporter/client/crashreporter_linux.cpp b/toolkit/crashreporter/client/crashreporter_linux.cpp
--- a/toolkit/crashreporter/client/crashreporter_linux.cpp
+++ b/toolkit/crashreporter/client/crashreporter_linux.cpp
@@ -53,21 +53,19 @@ static void LoadSettings()
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gEmailMeCheck),
                                    settings["EmailMe"][0] != '0');
     }
     if (settings.find("IncludeURL") != settings.end() &&
         gIncludeURLCheck != 0) {
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gIncludeURLCheck),
                                    settings["IncludeURL"][0] != '0');
     }
-    bool enabled;
+    bool enabled = true;
     if (settings.find("SubmitReport") != settings.end())
       enabled = settings["SubmitReport"][0] != '0';
-    else
-      enabled = ShouldEnableSending();
     gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gSubmitReportCheck),
                                  enabled);
   }
 }
 
 void SaveSettings()
 {
   /*
diff --git a/toolkit/crashreporter/client/crashreporter_osx.mm b/toolkit/crashreporter/client/crashreporter_osx.mm
--- a/toolkit/crashreporter/client/crashreporter_osx.mm
+++ b/toolkit/crashreporter/client/crashreporter_osx.mm
@@ -164,24 +164,22 @@ static bool RestartApplication()
   }
 
   // resize some buttons horizontally and possibly some controls vertically
   [self doInitialResizing];
 
   // load default state of submit checkbox
   // we don't just do this via IB because we want the default to be
   // off a certain percentage of the time
-  BOOL submitChecked = NO;
+  BOOL submitChecked = YES;
   NSUserDefaults* userDefaults = [NSUserDefaults standardUserDefaults];
   if (nil != [userDefaults objectForKey:@"submitReport"]) {
-    submitChecked =  [userDefaults boolForKey:@"submitReport"];
+    submitChecked = [userDefaults boolForKey:@"submitReport"];
   }
   else {
-    // use compile-time specified enable percentage
-    submitChecked = ShouldEnableSending();
     [userDefaults setBool:submitChecked forKey:@"submitReport"];
   }
   [mSubmitReportButton setState:(submitChecked ? NSOnState : NSOffState)];
   
   [self updateSubmit];
   [self updateURL];
   [self updateEmail];
 
diff --git a/toolkit/crashreporter/client/crashreporter_win.cpp b/toolkit/crashreporter/client/crashreporter_win.cpp
--- a/toolkit/crashreporter/client/crashreporter_win.cpp
+++ b/toolkit/crashreporter/client/crashreporter_win.cpp
@@ -907,17 +907,17 @@ static BOOL CALLBACK CrashReporterDialog
     GetRelativeRect(hwnd, hwndDlg, &rect);
     long maxdiff = ResizeControl(hwnd, rect, Str(ST_CHECKSUBMIT), false,
                                 gCheckboxPadding);
     SetDlgItemText(hwndDlg, IDC_SUBMITREPORTCHECK,
                    Str(ST_CHECKSUBMIT).c_str());
 
     if (!CheckBoolKey(gCrashReporterKey.c_str(),
                       SUBMIT_REPORT_VALUE, &enabled))
-      enabled = ShouldEnableSending();
+      enabled = true;
 
     CheckDlgButton(hwndDlg, IDC_SUBMITREPORTCHECK, enabled ? BST_CHECKED
                                                            : BST_UNCHECKED);
     SubmitReportChecked(hwndDlg);
 
     HWND hwndComment = GetDlgItem(hwndDlg, IDC_COMMENTTEXT);
     WNDPROC OldWndProc = (WNDPROC)SetWindowLongPtr(hwndComment,
                                                    GWLP_WNDPROC,
diff --git a/toolkit/mozapps/downloads/moz.build b/toolkit/mozapps/downloads/moz.build
--- a/toolkit/mozapps/downloads/moz.build
+++ b/toolkit/mozapps/downloads/moz.build
@@ -5,22 +5,19 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 with Files('**'):
     BUG_COMPONENT = ('Toolkit', 'Downloads API')
 
 TEST_DIRS += ['tests']
 
 EXTRA_COMPONENTS += [
+    'nsHelperAppDlg.js',
     'nsHelperAppDlg.manifest',
 ]
 
-EXTRA_PP_COMPONENTS += [
-    'nsHelperAppDlg.js',
-]
-
 EXTRA_JS_MODULES += [
     'DownloadLastDir.jsm',
     'DownloadPaths.jsm',
     'DownloadUtils.jsm',
 ]
 
 JAR_MANIFESTS += ['jar.mn']
diff --git a/toolkit/mozapps/downloads/nsHelperAppDlg.js b/toolkit/mozapps/downloads/nsHelperAppDlg.js
--- a/toolkit/mozapps/downloads/nsHelperAppDlg.js
+++ b/toolkit/mozapps/downloads/nsHelperAppDlg.js
@@ -1063,34 +1063,32 @@ nsUnknownContentTypeDialog.prototype = {
                               params);
 
       if (params.handlerApp &&
           params.handlerApp.executable &&
           params.handlerApp.executable.isFile()) {
         // Remember the file they chose to run.
         this.chosenApp = params.handlerApp;
       }
-    }
-    else {
-#if MOZ_WIDGET_GTK == 3
+    } else if ("@mozilla.org/applicationchooser;1" in Components.classes) {
       var nsIApplicationChooser = Components.interfaces.nsIApplicationChooser;
       var appChooser = Components.classes["@mozilla.org/applicationchooser;1"]
                                  .createInstance(nsIApplicationChooser);
       appChooser.init(this.mDialog, this.dialogElement("strings").getString("chooseAppFilePickerTitle"));
       var contentTypeDialogObj = this;
       let appChooserCallback = function appChooserCallback_done(aResult) {
         if (aResult) {
            contentTypeDialogObj.chosenApp = aResult.QueryInterface(Components.interfaces.nsILocalHandlerApp);
         }
         contentTypeDialogObj.finishChooseApp();
       };
       appChooser.open(this.mLauncher.MIMEInfo.MIMEType, appChooserCallback);
       // The finishChooseApp is called from appChooserCallback
       return;
-#else
+    } else {
       var nsIFilePicker = Components.interfaces.nsIFilePicker;
       var fp = Components.classes["@mozilla.org/filepicker;1"]
                          .createInstance(nsIFilePicker);
       fp.init(this.mDialog,
               this.dialogElement("strings").getString("chooseAppFilePickerTitle"),
               nsIFilePicker.modeOpen);
 
       fp.appendFilters(nsIFilePicker.filterApps);
@@ -1098,18 +1096,18 @@ nsUnknownContentTypeDialog.prototype = {
       if (fp.show() == nsIFilePicker.returnOK && fp.file) {
         // Remember the file they chose to run.
         var localHandlerApp =
           Components.classes["@mozilla.org/uriloader/local-handler-app;1"].
                      createInstance(Components.interfaces.nsILocalHandlerApp);
         localHandlerApp.executable = fp.file;
         this.chosenApp = localHandlerApp;
       }
-#endif // MOZ_WIDGET_GTK == 3
     }
+
     this.finishChooseApp();
   },
 
   // Turn this on to get debugging messages.
   debug: false,
 
   // Dump text (if debug is on).
   dump: function( text ) {
diff --git a/tools/profiler/core/platform.cpp b/tools/profiler/core/platform.cpp
--- a/tools/profiler/core/platform.cpp
+++ b/tools/profiler/core/platform.cpp
@@ -71,29 +71,46 @@
 #include "GeckoTaskTracer.h"
 #endif
 
 #if defined(GP_OS_android)
 # include "FennecJNINatives.h"
 # include "FennecJNIWrappers.h"
 #endif
 
-#if defined(MOZ_PROFILING) && \
-    (defined(GP_OS_windows) || defined(GP_OS_darwin))
+// Win32 builds always have frame pointers, so FramePointerStackWalk() always
+// works.
+#if defined(GP_PLAT_x86_windows)
+# define HAVE_NATIVE_UNWIND
+# define USE_FRAME_POINTER_STACK_WALK
+#endif
+
+// Win64 builds always omit frame pointers, so we use the slower
+// MozStackWalk(), which works in that case.
+#if defined(GP_PLAT_amd64_windows)
 # define HAVE_NATIVE_UNWIND
-# define USE_NS_STACKWALK
+# define USE_MOZ_STACK_WALK
 #endif
 
-// This should also work on ARM Linux, but not tested there yet.
+// Mac builds only have frame pointers when MOZ_PROFILING is specified, so
+// FramePointerStackWalk() only works in that case. We don't use MozStackWalk()
+// on Mac.
+#if defined(GP_OS_darwin) && defined(MOZ_PROFILING)
+# define HAVE_NATIVE_UNWIND
+# define USE_FRAME_POINTER_STACK_WALK
+#endif
+
+// Android builds use the ARM Exception Handling ABI to unwind.
 #if defined(GP_PLAT_arm_android)
 # define HAVE_NATIVE_UNWIND
 # define USE_EHABI_STACKWALK
 # include "EHABIStackWalk.h"
 #endif
 
+// Linux builds use LUL, which uses DWARF info to unwind stacks.
 #if defined(GP_PLAT_amd64_linux) || defined(GP_PLAT_x86_linux)
 # define HAVE_NATIVE_UNWIND
 # define USE_LUL_STACKWALK
 # include "lul/LulMain.h"
 # include "lul/platform-linux-lul.h"
 #endif
 
 #ifdef MOZ_VALGRIND
@@ -982,17 +999,17 @@ MergeStacks(uint32_t aFeatures, bool aIs
                                                lapCount);
   }
 }
 
 #if defined(GP_OS_windows)
 static uintptr_t GetThreadHandle(PlatformData* aData);
 #endif
 
-#ifdef USE_NS_STACKWALK
+#if defined(USE_FRAME_POINTER_STACK_WALK) || defined(USE_MOZ_STACK_WALK)
 static void
 StackWalkCallback(uint32_t aFrameNumber, void* aPC, void* aSP, void* aClosure)
 {
   NativeStack* nativeStack = static_cast<NativeStack*>(aClosure);
   MOZ_ASSERT(nativeStack->mCount < MAX_NATIVE_FRAMES);
   nativeStack->mSPs[nativeStack->mCount] = aSP;
   nativeStack->mPCs[nativeStack->mCount] = aPC;
   nativeStack->mCount++;
@@ -1009,30 +1026,30 @@ DoNativeBacktrace(PSLockRef aLock, const
   // Start with the current function. We use 0 as the frame number here because
   // the FramePointerStackWalk() and MozStackWalk() calls below will use 1..N.
   // This is a bit weird but it doesn't matter because StackWalkCallback()
   // doesn't use the frame number argument.
   StackWalkCallback(/* frameNum */ 0, aRegs.mPC, aRegs.mSP, &aNativeStack);
 
   uint32_t maxFrames = uint32_t(MAX_NATIVE_FRAMES - aNativeStack.mCount);
 
-#if defined(GP_OS_darwin) || (defined(GP_PLAT_x86_windows))
+#if defined(USE_FRAME_POINTER_STACK_WALK)
   void* stackEnd = aThreadInfo.StackTop();
   if (aRegs.mFP >= aRegs.mSP && aRegs.mFP <= stackEnd) {
     FramePointerStackWalk(StackWalkCallback, /* skipFrames */ 0, maxFrames,
                           &aNativeStack, reinterpret_cast<void**>(aRegs.mFP),
                           stackEnd);
   }
-#else
-  // Win64 always omits frame pointers so for it we use the slower
-  // MozStackWalk().
+#elif defined(USE_MOZ_STACK_WALK)
   uintptr_t thread = GetThreadHandle(aThreadInfo.GetPlatformData());
   MOZ_ASSERT(thread);
   MozStackWalk(StackWalkCallback, /* skipFrames */ 0, maxFrames, &aNativeStack,
                thread, /* platformData */ nullptr);
+#else
+# error "bad configuration"
 #endif
 }
 #endif
 
 #ifdef USE_EHABI_STACKWALK
 static void
 DoNativeBacktrace(PSLockRef aLock, const ThreadInfo& aThreadInfo,
                   const Registers& aRegs, NativeStack& aNativeStack)
@@ -1269,16 +1286,17 @@ DoSharedSample(PSLockRef aLock, bool aIs
     MergeStacks(ActivePS::Features(aLock), aIsSynchronous, aThreadInfo, aRegs,
                 nativeStack, aBuffer);
   } else
 #endif
   {
     MergeStacks(ActivePS::Features(aLock), aIsSynchronous, aThreadInfo, aRegs,
                 nativeStack, aBuffer);
 
+    // We can't walk the whole native stack, but we can record the top frame.
     if (ActivePS::FeatureLeaf(aLock)) {
       aBuffer.AddEntry(ProfileBufferEntry::NativeLeafAddr((void*)aRegs.mPC));
     }
   }
 }
 
 // Writes the components of a synchronous sample to the given ProfileBuffer.
 static void
diff --git a/tools/profiler/gecko/ThreadResponsiveness.cpp b/tools/profiler/gecko/ThreadResponsiveness.cpp
--- a/tools/profiler/gecko/ThreadResponsiveness.cpp
+++ b/tools/profiler/gecko/ThreadResponsiveness.cpp
@@ -44,18 +44,17 @@ public:
   void DoFirstDispatchIfNeeded()
   {
     if (mHasEverBeenSuccessfullyDispatched) {
       return;
     }
 
     // Dispatching can fail during early startup, particularly when
     // MOZ_PROFILER_STARTUP is used.
-    nsresult rv = SystemGroup::Dispatch("CheckResponsivenessTask",
-                                        TaskCategory::Other,
+    nsresult rv = SystemGroup::Dispatch(TaskCategory::Other,
                                         do_AddRef(this));
     if (NS_SUCCEEDED(rv)) {
       mHasEverBeenSuccessfullyDispatched = true;
     }
   }
 
   // Can only run on the main thread.
   NS_IMETHOD Run() override
@@ -76,18 +75,17 @@ public:
     }
     mTimer->InitWithCallback(this, 16, nsITimer::TYPE_ONE_SHOT);
 
     return NS_OK;
   }
 
   NS_IMETHOD Notify(nsITimer* aTimer) final
   {
-    SystemGroup::Dispatch("CheckResponsivenessTask",
-                          TaskCategory::Other,
+    SystemGroup::Dispatch(TaskCategory::Other,
                           do_AddRef(this));
     return NS_OK;
   }
 
   void Terminate() {
     MutexAutoLock mon(mMutex);
     mStop = true;
   }
diff --git a/tools/rewriting/ThirdPartyPaths.txt b/tools/rewriting/ThirdPartyPaths.txt
--- a/tools/rewriting/ThirdPartyPaths.txt
+++ b/tools/rewriting/ThirdPartyPaths.txt
@@ -6,17 +6,17 @@ gfx/angle/
 gfx/cairo/
 gfx/graphite2/
 gfx/harfbuzz/
 gfx/ots/
 gfx/qcms/
 gfx/skia/
 gfx/vr/openvr/
 gfx/webrender
-gfx/webrender_traits
+gfx/webrender_api
 gfx/ycbcr/
 intl/hyphenation/hyphen/
 intl/icu/
 ipc/chromium/
 js/src/ctypes/libffi/
 js/src/dtoa.c
 js/src/jit/arm64/vixl/
 media/ffvpx/
diff --git a/uriloader/exthandler/nsExternalHelperAppService.cpp b/uriloader/exthandler/nsExternalHelperAppService.cpp
--- a/uriloader/exthandler/nsExternalHelperAppService.cpp
+++ b/uriloader/exthandler/nsExternalHelperAppService.cpp
@@ -1191,16 +1191,17 @@ NS_IMPL_RELEASE(nsExternalAppHandler)
 NS_INTERFACE_MAP_BEGIN(nsExternalAppHandler)
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStreamListener)
    NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
    NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
    NS_INTERFACE_MAP_ENTRY(nsIHelperAppLauncher)
    NS_INTERFACE_MAP_ENTRY(nsICancelable)
    NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
    NS_INTERFACE_MAP_ENTRY(nsIBackgroundFileSaverObserver)
+   NS_INTERFACE_MAP_ENTRY(nsINamed)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 nsExternalAppHandler::nsExternalAppHandler(nsIMIMEInfo * aMIMEInfo,
                                            const nsACString& aTempFileExtension,
                                            nsIInterfaceRequestor* aContentContext,
                                            nsIInterfaceRequestor* aWindowContext,
                                            nsExternalHelperAppService *aExtProtSvc,
                                            const nsAString& aSuggestedFilename,
@@ -2557,16 +2558,24 @@ nsExternalAppHandler::Notify(nsITimer* t
   NS_ASSERTION(mWindowToClose, "No window to close after timer fired");
 
   mWindowToClose->Close();
   mWindowToClose = nullptr;
   mTimer = nullptr;
 
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsExternalAppHandler::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsExternalAppHandler");
+  return NS_OK;
+}
+
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////
 // The following section contains our nsIMIMEService implementation and related methods.
 //
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
 // nsIMIMEService methods
 NS_IMETHODIMP nsExternalHelperAppService::GetFromTypeAndExtension(const nsACString& aMIMEType, const nsACString& aFileExt, nsIMIMEInfo **_retval) 
 {
diff --git a/uriloader/exthandler/nsExternalHelperAppService.h b/uriloader/exthandler/nsExternalHelperAppService.h
--- a/uriloader/exthandler/nsExternalHelperAppService.h
+++ b/uriloader/exthandler/nsExternalHelperAppService.h
@@ -11,16 +11,17 @@
 
 #include "nsIExternalHelperAppService.h"
 #include "nsIExternalProtocolService.h"
 #include "nsIWebProgressListener2.h"
 #include "nsIHelperAppLauncherDialog.h"
 
 #include "nsIMIMEInfo.h"
 #include "nsIMIMEService.h"
+#include "nsINamed.h"
 #include "nsIStreamListener.h"
 #include "nsIFile.h"
 #include "nsIFileStreams.h"
 #include "nsIOutputStream.h"
 #include "nsString.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsIChannel.h"
@@ -206,26 +207,28 @@ private:
  * is bound to an application when it is created. When it receives an
  * OnStopRequest it launches the application using the temp file it has
  * stored the data into.  We create a handler every time we have to process
  * data using a helper app.
  */
 class nsExternalAppHandler final : public nsIStreamListener,
                                    public nsIHelperAppLauncher,
                                    public nsITimerCallback,
-                                   public nsIBackgroundFileSaverObserver
+                                   public nsIBackgroundFileSaverObserver,
+                                   public nsINamed
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSISTREAMLISTENER
   NS_DECL_NSIREQUESTOBSERVER
   NS_DECL_NSIHELPERAPPLAUNCHER
   NS_DECL_NSICANCELABLE
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSIBACKGROUNDFILESAVEROBSERVER
+  NS_DECL_NSINAMED
 
   /**
    * @param aMIMEInfo       MIMEInfo object, representing the type of the
    *                        content that should be handled
    * @param aFileExtension  The extension we need to append to our temp file,
    *                        INCLUDING the ".". e.g. .mp3
    * @param aContentContext dom Window context, as passed to DoContent.
    * @param aWindowContext  Top level window context used in dialog parenting,
diff --git a/widget/EventMessageList.h b/widget/EventMessageList.h
--- a/widget/EventMessageList.h
+++ b/widget/EventMessageList.h
@@ -450,16 +450,19 @@ NS_EVENT_MESSAGE_FIRST_LAST(eGamepadEven
 
 // input and beforeinput events.
 NS_EVENT_MESSAGE(eEditorInput)
 
 // selection events
 NS_EVENT_MESSAGE(eSelectStart)
 NS_EVENT_MESSAGE(eSelectionChange)
 
+// visibility change
+NS_EVENT_MESSAGE(eVisibilityChange)
+
 // Details element events.
 NS_EVENT_MESSAGE(eToggle)
 
 // Dialog element events.
 NS_EVENT_MESSAGE(eClose)
 
 #ifdef UNDEF_NS_EVENT_MESSAGE_FIRST_LAST
 #undef UNDEF_NS_EVENT_MESSAGE_FIRST_LAST
diff --git a/widget/PuppetWidget.cpp b/widget/PuppetWidget.cpp
--- a/widget/PuppetWidget.cpp
+++ b/widget/PuppetWidget.cpp
@@ -305,17 +305,17 @@ PuppetWidget::Invalidate(const LayoutDev
     return;
   }
 
   mDirtyRegion.Or(mDirtyRegion, aRect);
 
   if (mTabChild && !mDirtyRegion.IsEmpty() && !mPaintTask.IsPending()) {
     mPaintTask = new PaintTask(this);
     nsCOMPtr<nsIRunnable> event(mPaintTask.get());
-    mTabChild->TabGroup()->Dispatch("PuppetWidget::Invalidate", TaskCategory::Other, event.forget());
+    mTabChild->TabGroup()->Dispatch(TaskCategory::Other, event.forget());
     return;
   }
 }
 
 void
 PuppetWidget::InitEvent(WidgetGUIEvent& aEvent, LayoutDeviceIntPoint* aPoint)
 {
   if (nullptr == aPoint) {
diff --git a/widget/cocoa/nsPrintSettingsX.h b/widget/cocoa/nsPrintSettingsX.h
--- a/widget/cocoa/nsPrintSettingsX.h
+++ b/widget/cocoa/nsPrintSettingsX.h
@@ -40,17 +40,17 @@ public:
   virtual nsresult WritePageFormatToPrefs();
   virtual nsresult GetEffectivePageSize(double *aWidth,
       double *aHeight) override;
   void GetFilePageSize(double *aWidth, double *aHeight);
 
   // In addition to setting the paper width and height, these
   // overrides set the adjusted width and height returned from
   // GetEffectivePageSize. This is needed when a paper size is
-  // set manually without using a print dialog a la reftest-print.
+  // set manually without using a print dialog a la reftest-paged.
   virtual nsresult SetPaperWidth(double aPaperWidth) override;
   virtual nsresult SetPaperHeight(double aPaperWidth) override;
 
   PMPrintSettings GetPMPrintSettings();
   PMPrintSession GetPMPrintSession();
   PMPageFormat GetPMPageFormat();
   void SetPMPageFormat(PMPageFormat aPageFormat);
 
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -6244,23 +6244,29 @@ nsWindow::GetNativeTextEventDispatcherLi
 
 void
 nsWindow::GetEditCommandsRemapped(NativeKeyBindingsType aType,
                                   const WidgetKeyboardEvent& aEvent,
                                   nsTArray<CommandInt>& aCommands,
                                   uint32_t aGeckoKeyCode,
                                   uint32_t aNativeKeyCode)
 {
+    // If aEvent.mNativeKeyEvent is nullptr, the event was created by chrome
+    // script.  In such case, we shouldn't expose the OS settings to it.
+    // So, just ignore such events here.
+    if (!aEvent.mNativeKeyEvent) {
+        return;
+    }
     WidgetKeyboardEvent modifiedEvent(aEvent);
     modifiedEvent.mKeyCode = aGeckoKeyCode;
     static_cast<GdkEventKey*>(modifiedEvent.mNativeKeyEvent)->keyval =
         aNativeKeyCode;
 
     NativeKeyBindings* keyBindings = NativeKeyBindings::GetInstance(aType);
-    return keyBindings->GetEditCommands(modifiedEvent, aCommands);
+    keyBindings->GetEditCommands(modifiedEvent, aCommands);
 }
 
 void
 nsWindow::GetEditCommands(NativeKeyBindingsType aType,
                           const WidgetKeyboardEvent& aEvent,
                           nsTArray<CommandInt>& aCommands)
 {
     // Validate the arguments.
diff --git a/widget/nsNativeTheme.cpp b/widget/nsNativeTheme.cpp
--- a/widget/nsNativeTheme.cpp
+++ b/widget/nsNativeTheme.cpp
@@ -33,17 +33,17 @@
 using namespace mozilla;
 using namespace mozilla::dom;
 
 nsNativeTheme::nsNativeTheme()
 : mAnimatedContentTimeout(UINT32_MAX)
 {
 }
 
-NS_IMPL_ISUPPORTS(nsNativeTheme, nsITimerCallback)
+NS_IMPL_ISUPPORTS(nsNativeTheme, nsITimerCallback, nsINamed)
 
 nsIPresShell *
 nsNativeTheme::GetPresShell(nsIFrame* aFrame)
 {
   if (!aFrame)
     return nullptr;
 
   nsPresContext* context = aFrame->PresContext();
@@ -681,16 +681,23 @@ nsNativeTheme::Notify(nsITimer* aTimer)
     }
   }
 
   mAnimatedContentList.Clear();
   mAnimatedContentTimeout = UINT32_MAX;
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsNativeTheme::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("nsNativeTheme");
+  return NS_OK;
+}
+
 nsIFrame*
 nsNativeTheme::GetAdjacentSiblingFrameWithSameAppearance(nsIFrame* aFrame,
                                                          bool aNextSibling)
 {
   if (!aFrame)
     return nullptr;
 
   // Find the next visible sibling.
diff --git a/widget/nsNativeTheme.h b/widget/nsNativeTheme.h
--- a/widget/nsNativeTheme.h
+++ b/widget/nsNativeTheme.h
@@ -8,34 +8,36 @@
 
 #include "nsAlgorithm.h"
 #include "nsIAtom.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
 #include "nsMargin.h"
 #include "nsGkAtoms.h"
 #include "nsTArray.h"
+#include "nsINamed.h"
 #include "nsITimer.h"
 #include "nsIContent.h"
 
 class nsIFrame;
 class nsIPresShell;
 class nsPresContext;
 
 namespace mozilla {
 class EventStates;
 } // namespace mozilla
 
-class nsNativeTheme : public nsITimerCallback
+class nsNativeTheme : public nsITimerCallback, public nsINamed
 {
  protected:
   virtual ~nsNativeTheme() {}
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSINAMED
 
   enum ScrollbarButtonType {
     eScrollbarButton_UpTop   = 0,
     eScrollbarButton_Down    = 1 << 0,
     eScrollbarButton_Bottom  = 1 << 1
   };
 
   enum TreeSortDirection {
diff --git a/widget/windows/nsAppShell.cpp b/widget/windows/nsAppShell.cpp
--- a/widget/windows/nsAppShell.cpp
+++ b/widget/windows/nsAppShell.cpp
@@ -18,16 +18,17 @@
 #include "mozilla/HangMonitor.h"
 #include "nsIDOMWakeLockListener.h"
 #include "nsIPowerManagerService.h"
 #include "mozilla/StaticPtr.h"
 #include "nsTHashtable.h"
 #include "nsHashKeys.h"
 #include "GeckoProfiler.h"
 #include "nsComponentManagerUtils.h"
+#include "nsINamed.h"
 #include "nsITimer.h"
 #include "ScreenHelperWin.h"
 #include "mozilla/widget/ScreenManager.h"
 
 // These are two messages that the code in winspool.drv on Windows 7 explicitly
 // waits for while it is pumping other Windows messages, during display of the
 // Printer Properties dialog.
 #define MOZ_WM_PRINTER_PROPERTIES_COMPLETION 0x5b7a
@@ -38,25 +39,31 @@ using namespace mozilla::widget;
 
 #define WAKE_LOCK_LOG(...) MOZ_LOG(gWinWakeLockLog, mozilla::LogLevel::Debug, (__VA_ARGS__))
 static mozilla::LazyLogModule gWinWakeLockLog("WinWakeLock");
 
 // A wake lock listener that disables screen saver when requested by
 // Gecko. For example when we're playing video in a foreground tab we
 // don't want the screen saver to turn on.
 class WinWakeLockListener final : public nsIDOMMozWakeLockListener
-                                , public nsITimerCallback {
+                                , public nsITimerCallback
+                                , public nsINamed {
 public:
   NS_DECL_ISUPPORTS;
 
   NS_IMETHOD Notify(nsITimer *timer) override {
     WAKE_LOCK_LOG("WinWakeLock: periodic timer fired");
     ResetScreenSaverTimeout();
     return NS_OK;
   }
+
+  NS_IMETHOD GetName(nsACString& aName) override {
+    aName.AssignLiteral("WinWakeLockListener");
+    return NS_OK;
+  }
 private:
   ~WinWakeLockListener() {}
 
   NS_IMETHOD Callback(const nsAString& aTopic, const nsAString& aState) {
     if (!aTopic.EqualsASCII("screen")) {
       return NS_OK;
     }
     // Note the wake lock code ensures that we're not sent duplicate
@@ -129,17 +136,17 @@ private:
     }
     WAKE_LOCK_LOG("WinWakeLock: ResetScreenSaverTimeout() mScreenSaverTimeout=%d", mScreenSaverTimeout);
   }
 
   UINT mScreenSaverTimeout = 60;
   nsCOMPtr<nsITimer> mTimer;
 };
 
-NS_IMPL_ISUPPORTS(WinWakeLockListener, nsIDOMMozWakeLockListener, nsITimerCallback)
+NS_IMPL_ISUPPORTS(WinWakeLockListener, nsIDOMMozWakeLockListener, nsITimerCallback, nsINamed)
 StaticRefPtr<WinWakeLockListener> sWakeLockListener;
 
 static void
 AddScreenWakeLockListener()
 {
   nsCOMPtr<nsIPowerManagerService> sPowerManagerService = do_GetService(POWERMANAGERSERVICE_CONTRACTID);
   if (sPowerManagerService) {
     sWakeLockListener = new WinWakeLockListener();
diff --git a/xpcom/base/DebuggerOnGCRunnable.cpp b/xpcom/base/DebuggerOnGCRunnable.cpp
--- a/xpcom/base/DebuggerOnGCRunnable.cpp
+++ b/xpcom/base/DebuggerOnGCRunnable.cpp
@@ -20,17 +20,17 @@ DebuggerOnGCRunnable::Enqueue(JSContext*
   auto gcEvent = aDesc.toGCEvent(aCx);
   if (!gcEvent) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   RefPtr<DebuggerOnGCRunnable> runOnGC =
     new DebuggerOnGCRunnable(Move(gcEvent));
   if (NS_IsMainThread()) {
-    return SystemGroup::Dispatch("DebuggerOnGCRunnable", TaskCategory::GarbageCollection, runOnGC.forget());
+    return SystemGroup::Dispatch(TaskCategory::GarbageCollection, runOnGC.forget());
   } else {
     return NS_DispatchToCurrentThread(runOnGC);
   }
 }
 
 NS_IMETHODIMP
 DebuggerOnGCRunnable::Run()
 {
diff --git a/xpcom/base/nsConsoleService.cpp b/xpcom/base/nsConsoleService.cpp
--- a/xpcom/base/nsConsoleService.cpp
+++ b/xpcom/base/nsConsoleService.cpp
@@ -326,17 +326,17 @@ nsConsoleService::LogMessageWithMode(nsI
     NS_ReleaseOnMainThreadSystemGroup(
       "nsConsoleService::retiredMessage", retiredMessage.forget());
   }
 
   if (r) {
     // avoid failing in XPCShell tests
     nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
     if (mainThread) {
-      SystemGroup::Dispatch("LogMessageRunnable", TaskCategory::Other, r.forget());
+      SystemGroup::Dispatch(TaskCategory::Other, r.forget());
     }
   }
 
   return NS_OK;
 }
 
 void
 nsConsoleService::CollectCurrentListeners(
diff --git a/xpcom/base/nsMessageLoop.cpp b/xpcom/base/nsMessageLoop.cpp
--- a/xpcom/base/nsMessageLoop.cpp
+++ b/xpcom/base/nsMessageLoop.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsMessageLoop.h"
 #include "mozilla/WeakPtr.h"
 #include "base/message_loop.h"
 #include "base/task.h"
+#include "nsINamed.h"
 #include "nsIRunnable.h"
 #include "nsITimer.h"
 #include "nsCOMPtr.h"
 #include "nsAutoPtr.h"
 #include "nsComponentManagerUtils.h"
 #include "nsThreadUtils.h"
 
 using namespace mozilla;
@@ -51,24 +52,30 @@ private:
  * not a refcounted object; it's owned by the MessageLoop.)
  *
  * We keep a weak reference to the MessageLoopIdleTask, although a raw pointer
  * should in theory suffice: When the MessageLoopIdleTask runs (right before
  * the MessageLoop deletes it), it cancels its timer.  But the weak pointer
  * saves us from worrying about an edge case somehow messing us up here.
  */
 class MessageLoopTimerCallback
-  : public nsITimerCallback
+  : public nsITimerCallback, public nsINamed
 {
 public:
   explicit MessageLoopTimerCallback(MessageLoopIdleTask* aTask);
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
 
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("MessageLoopTimerCallback");
+    return NS_OK;
+  }
+
 private:
   WeakPtr<MessageLoopIdleTask> mTask;
 
   virtual ~MessageLoopTimerCallback() {}
 };
 
 MessageLoopIdleTask::MessageLoopIdleTask(nsIRunnable* aTask,
                                          uint32_t aEnsureRunsAfterMS)
@@ -137,17 +144,17 @@ MessageLoopTimerCallback::Notify(nsITime
   NS_WARNING_ASSERTION(mTask, "This timer shouldn't have fired.");
 
   if (mTask) {
     mTask->Run();
   }
   return NS_OK;
 }
 
-NS_IMPL_ISUPPORTS(MessageLoopTimerCallback, nsITimerCallback)
+NS_IMPL_ISUPPORTS(MessageLoopTimerCallback, nsITimerCallback, nsINamed)
 
 } // namespace
 
 NS_IMPL_ISUPPORTS(nsMessageLoop, nsIMessageLoop)
 
 NS_IMETHODIMP
 nsMessageLoop::PostIdleTask(nsIRunnable* aTask, uint32_t aEnsureRunsAfterMS)
 {
diff --git a/xpcom/components/nsComponentManagerUtils.cpp b/xpcom/components/nsComponentManagerUtils.cpp
--- a/xpcom/components/nsComponentManagerUtils.cpp
+++ b/xpcom/components/nsComponentManagerUtils.cpp
@@ -44,28 +44,28 @@ CallGetService(const char* aContractID, 
 #else
 
 #include "nsComponentManager.h"
 
 nsresult
 CallGetService(const nsCID& aCID, const nsIID& aIID, void** aResult)
 {
   nsComponentManagerImpl* compMgr = nsComponentManagerImpl::gComponentManager;
-  if (NS_WARN_IF(!compMgr)) {
+  if (!compMgr) {
     return NS_ERROR_NOT_INITIALIZED;
   }
 
   return compMgr->nsComponentManagerImpl::GetService(aCID, aIID, aResult);
 }
 
 nsresult
 CallGetService(const char* aContractID, const nsIID& aIID, void** aResult)
 {
   nsComponentManagerImpl* compMgr = nsComponentManagerImpl::gComponentManager;
-  if (NS_WARN_IF(!compMgr)) {
+  if (!compMgr) {
     return NS_ERROR_NOT_INITIALIZED;
   }
 
   return compMgr->nsComponentManagerImpl::GetServiceByContractID(aContractID,
                                                                  aIID,
                                                                  aResult);
 }
 
diff --git a/xpcom/tests/gtest/TestDeadlockDetector.cpp b/xpcom/tests/gtest/TestDeadlockDetector.cpp
--- a/xpcom/tests/gtest/TestDeadlockDetector.cpp
+++ b/xpcom/tests/gtest/TestDeadlockDetector.cpp
@@ -7,16 +7,17 @@
 #include "mozilla/ArrayUtils.h"
 
 #include "prthread.h"
 
 #include "nsTArray.h"
 #include "nsMemory.h"
 
 #include "mozilla/CondVar.h"
+#include "mozilla/RecursiveMutex.h"
 #include "mozilla/ReentrantMonitor.h"
 #include "mozilla/Mutex.h"
 
 #ifdef MOZ_CRASHREPORTER
 #include "nsCOMPtr.h"
 #include "nsICrashReporter.h"
 #include "nsServiceManagerUtils.h"
 #endif
@@ -197,16 +198,41 @@ TEST_F(TESTNAME(DeadlockDetectorTest), T
         "###!!! ERROR: Potential deadlock detected.*"
         "=== Cyclical dependency starts at.*--- ReentrantMonitor : dd.sanity4.m1.*"
         "--- Next dependency:.*--- Mutex : dd.sanity4.m2.*"
         "=== Cycle completed at.*--- ReentrantMonitor : dd.sanity4.m1.*"
         "###!!! ASSERTION: Potential deadlock detected.*";
     ASSERT_DEATH_IF_SUPPORTED(Sanity4_Child(), regex);
 }
 
+int
+Sanity5_Child()
+{
+    DisableCrashReporter();
+
+    mozilla::RecursiveMutex m1("dd.sanity4.m1");
+    MUTEX m2("dd.sanity4.m2");
+    m1.Lock();
+    m2.Lock();
+    m1.Lock();
+    return 0;
+}
+
+TEST_F(TESTNAME(DeadlockDetectorTest), TESTNAME(Sanity5DeathTest))
+{
+    const char* const regex =
+        "Re-entering RecursiveMutex after acquiring other resources.*"
+        "###!!! ERROR: Potential deadlock detected.*"
+        "=== Cyclical dependency starts at.*--- RecursiveMutex : dd.sanity4.m1.*"
+        "--- Next dependency:.*--- Mutex : dd.sanity4.m2.*"
+        "=== Cycle completed at.*--- RecursiveMutex : dd.sanity4.m1.*"
+        "###!!! ASSERTION: Potential deadlock detected.*";
+    ASSERT_DEATH_IF_SUPPORTED(Sanity5_Child(), regex);
+}
+
 //-----------------------------------------------------------------------------
 // Multithreaded tests
 
 /**
  * Helper for passing state to threads in the multithread tests.
  */
 struct ThreadState
 {
diff --git a/xpcom/tests/gtest/TestRecursiveMutex.cpp b/xpcom/tests/gtest/TestRecursiveMutex.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/gtest/TestRecursiveMutex.cpp
@@ -0,0 +1,25 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsThreadUtils.h"
+#include "mozilla/RecursiveMutex.h"
+#include "gtest/gtest.h"
+
+using mozilla::RecursiveMutex;
+using mozilla::RecursiveMutexAutoLock;
+
+// Basic test to make sure the underlying implementation of RecursiveMutex is,
+// well, actually recursively acquirable.
+
+TEST(RecursiveMutex, SmokeTest)
+{
+  RecursiveMutex mutex("testing mutex");
+
+  RecursiveMutexAutoLock lock1(mutex);
+  RecursiveMutexAutoLock lock2(mutex);
+
+  //...and done.
+}
diff --git a/xpcom/tests/gtest/TestSlicedInputStream.cpp b/xpcom/tests/gtest/TestSlicedInputStream.cpp
--- a/xpcom/tests/gtest/TestSlicedInputStream.cpp
+++ b/xpcom/tests/gtest/TestSlicedInputStream.cpp
@@ -1,12 +1,13 @@
 #include "gtest/gtest.h"
 
 #include "nsCOMPtr.h"
 #include "nsIInputStream.h"
+#include "nsIPipe.h"
 #include "nsStreamUtils.h"
 #include "nsString.h"
 #include "nsStringStream.h"
 #include "SlicedInputStream.h"
 #include "Helpers.h"
 
 // This helper class is used to call OnInputStreamReady with the right stream
 // as argument.
diff --git a/xpcom/tests/gtest/moz.build b/xpcom/tests/gtest/moz.build
--- a/xpcom/tests/gtest/moz.build
+++ b/xpcom/tests/gtest/moz.build
@@ -27,16 +27,17 @@ UNIFIED_SOURCES += [
     'TestNsDeque.cpp',
     'TestNSPRLogModulesParser.cpp',
     'TestObserverArray.cpp',
     'TestObserverService.cpp',
     'TestPipes.cpp',
     'TestPLDHash.cpp',
     'TestPriorityQueue.cpp',
     'TestRacingServiceManager.cpp',
+    'TestRecursiveMutex.cpp',
     'TestRWLock.cpp',
     'TestSlicedInputStream.cpp',
     'TestSnappyStreams.cpp',
     'TestStateWatching.cpp',
     'TestStorageStream.cpp',
     'TestStrings.cpp',
     'TestStringStream.cpp',
     'TestSynchronization.cpp',
diff --git a/xpcom/threads/BackgroundHangMonitor.cpp b/xpcom/threads/BackgroundHangMonitor.cpp
--- a/xpcom/threads/BackgroundHangMonitor.cpp
+++ b/xpcom/threads/BackgroundHangMonitor.cpp
@@ -629,18 +629,17 @@ BackgroundHangThread::ReportHang(PRInter
     // runnable in case the dispatch fails. If it fails, the already_AddRefed
     // runnable which we passed in has been leaked, and we need to free it
     // ourselves. The only time when this should fail is if we're shutting down.
     //
     // Most components just avoid dispatching runnables during shutdown, but BHR
     // is not shut down until way too late, so we cannot do that. Instead, we
     // just detect that the dispatch failed and manually unleak the leaked
     // nsIRunnable in that situation.
-    nsresult rv = SystemGroup::Dispatch("NotifyBHRHangObservers",
-                                        TaskCategory::Other,
+    nsresult rv = SystemGroup::Dispatch(TaskCategory::Other,
                                         do_AddRef(runnable.get()));
     if (NS_FAILED(rv)) {
       // NOTE: We go through `get()` here in order to avoid the
       // MOZ_NO_ADDREF_RELEASE_ON_RETURN static analysis.
       nsrefcnt refcnt = runnable.get()->Release();
       MOZ_RELEASE_ASSERT(refcnt == 1, "runnable should have had 1 reference leaked");
     }
   }
diff --git a/xpcom/threads/BlockingResourceBase.cpp b/xpcom/threads/BlockingResourceBase.cpp
--- a/xpcom/threads/BlockingResourceBase.cpp
+++ b/xpcom/threads/BlockingResourceBase.cpp
@@ -15,16 +15,17 @@
 #include "CodeAddressService.h"
 #include "nsHashKeys.h"
 #include "mozilla/StackWalk.h"
 #include "nsTHashtable.h"
 #endif
 
 #include "mozilla/CondVar.h"
 #include "mozilla/DeadlockDetector.h"
+#include "mozilla/RecursiveMutex.h"
 #include "mozilla/ReentrantMonitor.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/RWLock.h"
 
 #if defined(MOZILLA_INTERNAL_API)
 #include "GeckoProfiler.h"
 #endif //MOZILLA_INTERNAL_API
 
@@ -33,17 +34,17 @@
 namespace mozilla {
 //
 // BlockingResourceBase implementation
 //
 
 // static members
 const char* const BlockingResourceBase::kResourceTypeName[] = {
   // needs to be kept in sync with BlockingResourceType
-  "Mutex", "ReentrantMonitor", "CondVar"
+  "Mutex", "ReentrantMonitor", "CondVar", "RecursiveMutex"
 };
 
 #ifdef DEBUG
 
 PRCallOnceType BlockingResourceBase::sCallOnce;
 unsigned BlockingResourceBase::sResourceAcqnChainFrontTPI = (unsigned)-1;
 BlockingResourceBase::DDT* BlockingResourceBase::sDeadlockDetector;
 
@@ -523,16 +524,76 @@ ReentrantMonitor::Wait(PRIntervalTime aI
   SetAcquisitionState(savedAcquisitionState);
   mChainPrev = savedChainPrev;
 
   return rv;
 }
 
 
 //
+// Debug implementation of RecursiveMutex
+void
+RecursiveMutex::Lock()
+{
+  BlockingResourceBase* chainFront = ResourceChainFront();
+
+  // the code below implements mutex reentrancy semantics
+
+  if (this == chainFront) {
+    // immediately re-entered the mutex: acceptable
+    LockInternal();
+    ++mEntryCount;
+    return;
+  }
+
+  // this is sort of a hack around not recording the thread that
+  // owns this monitor
+  if (chainFront) {
+    for (BlockingResourceBase* br = ResourceChainPrev(chainFront);
+         br;
+         br = ResourceChainPrev(br)) {
+      if (br == this) {
+        NS_WARNING(
+          "Re-entering RecursiveMutex after acquiring other resources.");
+
+        // show the caller why this is potentially bad
+        CheckAcquire();
+
+        LockInternal();
+        ++mEntryCount;
+        return;
+      }
+    }
+  }
+
+  CheckAcquire();
+  LockInternal();
+  NS_ASSERTION(mEntryCount == 0, "RecursiveMutex isn't free!");
+  Acquire();       // protected by us
+  mOwningThread = PR_GetCurrentThread();
+  mEntryCount = 1;
+}
+
+void
+RecursiveMutex::Unlock()
+{
+  if (--mEntryCount == 0) {
+    Release();              // protected by us
+    mOwningThread = nullptr;
+  }
+  UnlockInternal();
+}
+
+void
+RecursiveMutex::AssertCurrentThreadIn()
+{
+  MOZ_ASSERT(IsAcquired() && mOwningThread == PR_GetCurrentThread());
+}
+
+//
 // Debug implementation of CondVar
 nsresult
 CondVar::Wait(PRIntervalTime aInterval)
 {
   AssertCurrentThreadOwnsMutex();
 
   // save mutex state and reset to empty
   AcquisitionState savedAcquisitionState = mLock->GetAcquisitionState();
diff --git a/xpcom/threads/BlockingResourceBase.h b/xpcom/threads/BlockingResourceBase.h
--- a/xpcom/threads/BlockingResourceBase.h
+++ b/xpcom/threads/BlockingResourceBase.h
@@ -45,17 +45,17 @@ template <class T> class DeadlockDetecto
  * BlockingResourceBase
  * Base class of resources that might block clients trying to acquire them.
  * Does debugging and deadlock detection in DEBUG builds.
  **/
 class BlockingResourceBase
 {
 public:
   // Needs to be kept in sync with kResourceTypeNames.
-  enum BlockingResourceType { eMutex, eReentrantMonitor, eCondVar };
+  enum BlockingResourceType { eMutex, eReentrantMonitor, eCondVar, eRecursiveMutex };
 
   /**
    * kResourceTypeName
    * Human-readable version of BlockingResourceType enum.
    */
   static const char* const kResourceTypeName[];
 
 
diff --git a/xpcom/threads/LazyIdleThread.cpp b/xpcom/threads/LazyIdleThread.cpp
--- a/xpcom/threads/LazyIdleThread.cpp
+++ b/xpcom/threads/LazyIdleThread.cpp
@@ -373,17 +373,18 @@ LazyIdleThread::Release()
   return count;
 }
 
 NS_IMPL_QUERY_INTERFACE(LazyIdleThread, nsIThread,
                         nsIEventTarget,
                         nsISerialEventTarget,
                         nsITimerCallback,
                         nsIThreadObserver,
-                        nsIObserver)
+                        nsIObserver,
+                        nsINamed)
 
 NS_IMETHODIMP
 LazyIdleThread::DispatchFromScript(nsIRunnable* aEvent, uint32_t aFlags)
 {
   nsCOMPtr<nsIRunnable> event(aEvent);
   return Dispatch(event.forget(), aFlags);
 }
 
@@ -559,16 +560,23 @@ LazyIdleThread::Notify(nsITimer* aTimer)
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
+LazyIdleThread::GetName(nsACString& aName)
+{
+  aName.AssignLiteral("LazyIdleThread");
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 LazyIdleThread::OnDispatchedEvent(nsIThreadInternal* /*aThread */)
 {
   MOZ_ASSERT(mOwningEventTarget->IsOnCurrentThread());
   return NS_OK;
 }
 
 NS_IMETHODIMP
 LazyIdleThread::OnProcessNextEvent(nsIThreadInternal* /* aThread */,
diff --git a/xpcom/threads/LazyIdleThread.h b/xpcom/threads/LazyIdleThread.h
--- a/xpcom/threads/LazyIdleThread.h
+++ b/xpcom/threads/LazyIdleThread.h
@@ -6,16 +6,17 @@
 
 #ifndef mozilla_lazyidlethread_h__
 #define mozilla_lazyidlethread_h__
 
 #ifndef MOZILLA_INTERNAL_API
 #error "This header is only usable from within libxul (MOZILLA_INTERNAL_API)."
 #endif
 
+#include "nsINamed.h"
 #include "nsIObserver.h"
 #include "nsIThreadInternal.h"
 #include "nsITimer.h"
 
 #include "mozilla/Mutex.h"
 #include "nsCOMPtr.h"
 #include "nsTArray.h"
 #include "nsString.h"
@@ -32,24 +33,26 @@ namespace mozilla {
  * is created on the main thread then it will automatically join its thread on
  * XPCOM shutdown using the Observer Service.
  */
 class LazyIdleThread final
   : public nsIThread
   , public nsITimerCallback
   , public nsIThreadObserver
   , public nsIObserver
+  , public nsINamed
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIEVENTTARGET_FULL
   NS_DECL_NSITHREAD
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSITHREADOBSERVER
   NS_DECL_NSIOBSERVER
+  NS_DECL_NSINAMED
 
   enum ShutdownMethod
   {
     AutomaticShutdown = 0,
     ManualShutdown
   };
 
   /**
diff --git a/xpcom/threads/RecursiveMutex.cpp b/xpcom/threads/RecursiveMutex.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/threads/RecursiveMutex.cpp
@@ -0,0 +1,89 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/RecursiveMutex.h"
+
+#ifdef XP_WIN
+#include <windows.h>
+
+#define NativeHandle(m) (reinterpret_cast<CRITICAL_SECTION*>(&m))
+#endif
+
+namespace mozilla {
+
+RecursiveMutex::RecursiveMutex(const char* aName MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL)
+  : BlockingResourceBase(aName, eRecursiveMutex)
+#ifdef DEBUG
+  , mOwningThread(nullptr)
+  , mEntryCount(0)
+#endif
+{
+  MOZ_GUARD_OBJECT_NOTIFIER_INIT;
+#ifdef XP_WIN
+  // This number was adapted from NSPR.
+  static const DWORD sLockSpinCount = 100;
+
+#if defined(RELEASE_OR_BETA)
+  // Vista and later automatically allocate and subsequently leak a debug info
+  // object for each critical section that we allocate unless we tell the
+  // system not to do that.
+  DWORD flags = CRITICAL_SECTION_NO_DEBUG_INFO;
+#else
+  DWORD flags = 0;
+#endif
+  BOOL r = InitializeCriticalSectionEx(NativeHandle(mMutex),
+                                       sLockSpinCount, flags);
+  MOZ_RELEASE_ASSERT(r);
+#else
+  pthread_mutexattr_t attr;
+
+  MOZ_RELEASE_ASSERT(pthread_mutexattr_init(&attr) == 0,
+                     "pthread_mutexattr_init failed");
+
+  MOZ_RELEASE_ASSERT(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE) == 0,
+                     "pthread_mutexattr_settype failed");
+
+  MOZ_RELEASE_ASSERT(pthread_mutex_init(&mMutex, &attr) == 0,
+                     "pthread_mutex_init failed");
+
+  MOZ_RELEASE_ASSERT(pthread_mutexattr_destroy(&attr) == 0,
+                     "pthread_mutexattr_destroy failed");
+#endif
+}
+
+RecursiveMutex::~RecursiveMutex()
+{
+#ifdef XP_WIN
+  DeleteCriticalSection(NativeHandle(mMutex));
+#else
+  MOZ_RELEASE_ASSERT(pthread_mutex_destroy(&mMutex) == 0,
+                     "pthread_mutex_destroy failed");
+#endif
+}
+
+void
+RecursiveMutex::LockInternal()
+{
+#ifdef XP_WIN
+  EnterCriticalSection(NativeHandle(mMutex));
+#else
+  MOZ_RELEASE_ASSERT(pthread_mutex_lock(&mMutex) == 0,
+                     "pthread_mutex_lock failed");
+#endif
+}
+
+void
+RecursiveMutex::UnlockInternal()
+{
+#ifdef XP_WIN
+  LeaveCriticalSection(NativeHandle(mMutex));
+#else
+  MOZ_RELEASE_ASSERT(pthread_mutex_unlock(&mMutex) == 0,
+                     "pthread_mutex_unlock failed");
+#endif
+}
+
+} // namespace mozilla
diff --git a/xpcom/threads/RecursiveMutex.h b/xpcom/threads/RecursiveMutex.h
new file mode 100644
--- /dev/null
+++ b/xpcom/threads/RecursiveMutex.h
@@ -0,0 +1,124 @@
+
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// A lock that can be acquired multiple times on the same thread.
+
+#ifndef mozilla_RecursiveMutex_h
+#define mozilla_RecursiveMutex_h
+
+#include "mozilla/BlockingResourceBase.h"
+#include "mozilla/GuardObjects.h"
+
+#ifndef XP_WIN
+#include <pthread.h>
+#endif
+
+namespace mozilla {
+
+class RecursiveMutex : public BlockingResourceBase
+{
+public:
+  explicit RecursiveMutex(const char* aName MOZ_GUARD_OBJECT_NOTIFIER_PARAM);
+  ~RecursiveMutex();
+
+#ifdef DEBUG
+  void Lock();
+  void Unlock();
+#else
+  void Lock() { LockInternal(); }
+  void Unlock() { UnlockInternal(); }
+#endif
+
+  void AssertCurrentThreadIn()
+#ifdef DEBUG
+    ;
+#else
+  {
+  }
+#endif
+
+private:
+  RecursiveMutex() = delete;
+  RecursiveMutex(const RecursiveMutex&) = delete;
+  RecursiveMutex& operator=(const RecursiveMutex&) = delete;
+
+  void LockInternal();
+  void UnlockInternal();
+
+#ifdef DEBUG
+  PRThread* mOwningThread;
+  size_t mEntryCount;
+#endif
+
+#if !defined(XP_WIN)
+  pthread_mutex_t mMutex;
+#else
+  // We eschew including windows.h and using CRITICAL_SECTION here so that files
+  // including us don't also pull in windows.h.  Just use a type that's big
+  // enough for CRITICAL_SECTION, and we'll fix it up later.
+  void* mMutex[6];
+#endif
+  MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
+};
+
+class MOZ_RAII RecursiveMutexAutoLock
+{
+public:
+  explicit RecursiveMutexAutoLock(RecursiveMutex& aRecursiveMutex
+                                  MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
+    : mRecursiveMutex(&aRecursiveMutex)
+  {
+    MOZ_GUARD_OBJECT_NOTIFIER_INIT;
+    NS_ASSERTION(mRecursiveMutex, "null mutex");
+    mRecursiveMutex->Lock();
+  }
+
+  ~RecursiveMutexAutoLock(void)
+  {
+    mRecursiveMutex->Unlock();
+  }
+
+private:
+  RecursiveMutexAutoLock() = delete;
+  RecursiveMutexAutoLock(const RecursiveMutexAutoLock&) = delete;
+  RecursiveMutexAutoLock& operator=(const RecursiveMutexAutoLock&) = delete;
+  static void* operator new(size_t) CPP_THROW_NEW;
+
+  mozilla::RecursiveMutex* mRecursiveMutex;
+  MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
+};
+
+class MOZ_RAII RecursiveMutexAutoUnlock
+{
+public:
+  explicit RecursiveMutexAutoUnlock(RecursiveMutex& aRecursiveMutex
+                                    MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
+    : mRecursiveMutex(&aRecursiveMutex)
+  {
+    MOZ_GUARD_OBJECT_NOTIFIER_INIT;
+    NS_ASSERTION(mRecursiveMutex, "null mutex");
+    mRecursiveMutex->Unlock();
+  }
+
+  ~RecursiveMutexAutoUnlock(void)
+  {
+    mRecursiveMutex->Lock();
+  }
+
+private:
+  RecursiveMutexAutoUnlock() = delete;
+  RecursiveMutexAutoUnlock(const RecursiveMutexAutoUnlock&) = delete;
+  RecursiveMutexAutoUnlock& operator=(const RecursiveMutexAutoUnlock&) = delete;
+  static void* operator new(size_t) CPP_THROW_NEW;
+
+  mozilla::RecursiveMutex* mRecursiveMutex;
+  MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
+};
+
+} // namespace mozilla
+
+#endif // mozilla_RecursiveMutex_h
diff --git a/xpcom/threads/ReentrantMonitor.h b/xpcom/threads/ReentrantMonitor.h
--- a/xpcom/threads/ReentrantMonitor.h
+++ b/xpcom/threads/ReentrantMonitor.h
@@ -251,10 +251,9 @@ private:
   ReentrantMonitorAutoExit& operator=(const ReentrantMonitorAutoExit&);
   static void* operator new(size_t) CPP_THROW_NEW;
 
   ReentrantMonitor* mReentrantMonitor;
 };
 
 } // namespace mozilla
 
-
 #endif // ifndef mozilla_ReentrantMonitor_h
diff --git a/xpcom/threads/SchedulerGroup.cpp b/xpcom/threads/SchedulerGroup.cpp
--- a/xpcom/threads/SchedulerGroup.cpp
+++ b/xpcom/threads/SchedulerGroup.cpp
@@ -141,17 +141,17 @@ SchedulerEventTarget::DispatchFromScript
 }
 
 NS_IMETHODIMP
 SchedulerEventTarget::Dispatch(already_AddRefed<nsIRunnable> aRunnable, uint32_t aFlags)
 {
   if (NS_WARN_IF(aFlags != NS_DISPATCH_NORMAL)) {
     return NS_ERROR_UNEXPECTED;
   }
-  return mDispatcher->Dispatch(nullptr, mCategory, Move(aRunnable));
+  return mDispatcher->Dispatch(mCategory, Move(aRunnable));
 }
 
 NS_IMETHODIMP
 SchedulerEventTarget::DelayedDispatch(already_AddRefed<nsIRunnable>, uint32_t)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
@@ -164,30 +164,23 @@ SchedulerEventTarget::IsOnCurrentThread(
 
 NS_IMETHODIMP_(bool)
 SchedulerEventTarget::IsOnCurrentThreadInfallible()
 {
   return NS_IsMainThread();
 }
 
 /* static */ nsresult
-SchedulerGroup::UnlabeledDispatch(const char* aName,
-                                  TaskCategory aCategory,
+SchedulerGroup::UnlabeledDispatch(TaskCategory aCategory,
                                   already_AddRefed<nsIRunnable>&& aRunnable)
 {
-  nsCOMPtr<nsIRunnable> runnable(aRunnable);
-  if (aName) {
-    if (nsCOMPtr<nsINamed> named = do_QueryInterface(runnable)) {
-      named->SetName(aName);
-    }
-  }
   if (NS_IsMainThread()) {
-    return NS_DispatchToCurrentThread(runnable.forget());
+    return NS_DispatchToCurrentThread(Move(aRunnable));
   } else {
-    return NS_DispatchToMainThread(runnable.forget());
+    return NS_DispatchToMainThread(Move(aRunnable));
   }
 }
 
 /* static */ void
 SchedulerGroup::MarkVsyncReceived()
 {
   if (gEarliestUnprocessedVsync) {
     // If we've seen a vsync already, but haven't handled it, keep the
@@ -214,21 +207,20 @@ SchedulerGroup::MarkVsyncRan()
 SchedulerGroup* SchedulerGroup::sRunningDispatcher;
 
 SchedulerGroup::SchedulerGroup()
  : mAccessValid(false)
 {
 }
 
 nsresult
-SchedulerGroup::Dispatch(const char* aName,
-                         TaskCategory aCategory,
+SchedulerGroup::Dispatch(TaskCategory aCategory,
                          already_AddRefed<nsIRunnable>&& aRunnable)
 {
-  return LabeledDispatch(aName, aCategory, Move(aRunnable));
+  return LabeledDispatch(aCategory, Move(aRunnable));
 }
 
 nsISerialEventTarget*
 SchedulerGroup::EventTargetFor(TaskCategory aCategory) const
 {
   MOZ_ASSERT(aCategory != TaskCategory::Count);
   MOZ_ASSERT(mEventTargets[size_t(aCategory)]);
   return mEventTargets[size_t(aCategory)];
@@ -300,25 +292,24 @@ SchedulerGroup::FromEventTarget(nsIEvent
   RefPtr<SchedulerEventTarget> target = do_QueryObject(aEventTarget);
   if (!target) {
     return nullptr;
   }
   return target->Dispatcher();
 }
 
 nsresult
-SchedulerGroup::LabeledDispatch(const char* aName,
-                                TaskCategory aCategory,
+SchedulerGroup::LabeledDispatch(TaskCategory aCategory,
                                 already_AddRefed<nsIRunnable>&& aRunnable)
 {
   nsCOMPtr<nsIRunnable> runnable(aRunnable);
   if (XRE_IsContentProcess()) {
     runnable = new Runnable(runnable.forget(), this);
   }
-  return UnlabeledDispatch(aName, aCategory, runnable.forget());
+  return UnlabeledDispatch(aCategory, runnable.forget());
 }
 
 void
 SchedulerGroup::SetValidatingAccess(ValidationType aType)
 {
   sRunningDispatcher = aType == StartValidation ? this : nullptr;
   mAccessValid = aType == StartValidation;
 
diff --git a/xpcom/threads/SchedulerGroup.h b/xpcom/threads/SchedulerGroup.h
--- a/xpcom/threads/SchedulerGroup.h
+++ b/xpcom/threads/SchedulerGroup.h
@@ -104,32 +104,30 @@ public:
 
     nsCOMPtr<nsIRunnable> mRunnable;
     RefPtr<SchedulerGroup> mGroup;
   };
   friend class Runnable;
 
   bool* GetValidAccessPtr() { return &mAccessValid; }
 
-  virtual nsresult Dispatch(const char* aName,
-                            TaskCategory aCategory,
+  virtual nsresult Dispatch(TaskCategory aCategory,
                             already_AddRefed<nsIRunnable>&& aRunnable);
 
   virtual nsISerialEventTarget* EventTargetFor(TaskCategory aCategory) const;
 
   // Must always be called on the main thread. The returned AbstractThread can
   // always be used off the main thread.
   AbstractThread* AbstractMainThreadFor(TaskCategory aCategory);
 
   // This method performs a safe cast. It returns null if |this| is not of the
   // requested type.
   virtual dom::TabGroup* AsTabGroup() { return nullptr; }
 
-  static nsresult UnlabeledDispatch(const char* aName,
-                                    TaskCategory aCategory,
+  static nsresult UnlabeledDispatch(TaskCategory aCategory,
                                     already_AddRefed<nsIRunnable>&& aRunnable);
 
   static void MarkVsyncReceived();
 
   static void MarkVsyncRan();
 
 protected:
   // Implementations are guaranteed that this method is called on the main
@@ -139,18 +137,17 @@ protected:
   // Helper method to create an event target specific to a particular TaskCategory.
   virtual already_AddRefed<nsISerialEventTarget>
   CreateEventTargetFor(TaskCategory aCategory);
 
   // Given an event target returned by |dispatcher->CreateEventTargetFor|, this
   // function returns |dispatcher|.
   static SchedulerGroup* FromEventTarget(nsIEventTarget* aEventTarget);
 
-  nsresult LabeledDispatch(const char* aName,
-                           TaskCategory aCategory,
+  nsresult LabeledDispatch(TaskCategory aCategory,
                            already_AddRefed<nsIRunnable>&& aRunnable);
 
   void CreateEventTargets(bool aNeedValidation);
 
   // Shuts down this dispatcher. If aXPCOMShutdown is true, invalidates this
   // dispatcher.
   void Shutdown(bool aXPCOMShutdown);
 
diff --git a/xpcom/threads/SystemGroup.cpp b/xpcom/threads/SystemGroup.cpp
--- a/xpcom/threads/SystemGroup.cpp
+++ b/xpcom/threads/SystemGroup.cpp
@@ -80,21 +80,20 @@ SystemGroup::Shutdown()
 
 bool
 SystemGroup::Initialized()
 {
   return SystemGroupImpl::Initialized();
 }
 
 /* static */ nsresult
-SystemGroup::Dispatch(const char* aName,
-                      TaskCategory aCategory,
+SystemGroup::Dispatch(TaskCategory aCategory,
                       already_AddRefed<nsIRunnable>&& aRunnable)
 {
-  return SystemGroupImpl::Get()->Dispatch(aName, aCategory, Move(aRunnable));
+  return SystemGroupImpl::Get()->Dispatch(aCategory, Move(aRunnable));
 }
 
 /* static */ nsISerialEventTarget*
 SystemGroup::EventTargetFor(TaskCategory aCategory)
 {
   return SystemGroupImpl::Get()->EventTargetFor(aCategory);
 }
 
diff --git a/xpcom/threads/SystemGroup.h b/xpcom/threads/SystemGroup.h
--- a/xpcom/threads/SystemGroup.h
+++ b/xpcom/threads/SystemGroup.h
@@ -16,18 +16,17 @@
 // undefined.
 
 namespace mozilla {
 
 class SystemGroup
 {
  public:
   // This method is safe to use from any thread.
-  static nsresult Dispatch(const char* aName,
-                           TaskCategory aCategory,
+  static nsresult Dispatch(TaskCategory aCategory,
                            already_AddRefed<nsIRunnable>&& aRunnable);
 
   // This method is safe to use from any thread.
   static nsISerialEventTarget* EventTargetFor(TaskCategory aCategory);
 
   // Must be called on the main thread. The AbstractThread can always be used
   // off the main thread.
   static AbstractThread* AbstractMainThreadFor(TaskCategory aCategory);
diff --git a/xpcom/threads/moz.build b/xpcom/threads/moz.build
--- a/xpcom/threads/moz.build
+++ b/xpcom/threads/moz.build
@@ -44,16 +44,17 @@ EXPORTS.mozilla += [
     'HangAnnotations.h',
     'HangMonitor.h',
     'InputEventStatistics.h',
     'LazyIdleThread.h',
     'MainThreadIdlePeriod.h',
     'Monitor.h',
     'MozPromise.h',
     'Mutex.h',
+    'RecursiveMutex.h',
     'ReentrantMonitor.h',
     'RWLock.h',
     'SchedulerGroup.h',
     'SharedThreadPool.h',
     'StateMirroring.h',
     'StateWatching.h',
     'SyncRunnable.h',
     'SystemGroup.h',
@@ -77,16 +78,17 @@ UNIFIED_SOURCES += [
     'nsMemoryPressure.cpp',
     'nsProcessCommon.cpp',
     'nsProxyRelease.cpp',
     'nsThread.cpp',
     'nsThreadManager.cpp',
     'nsThreadPool.cpp',
     'nsThreadUtils.cpp',
     'nsTimerImpl.cpp',
+    'RecursiveMutex.cpp',
     'RWLock.cpp',
     'SchedulerGroup.cpp',
     'SharedThreadPool.cpp',
     'SystemGroup.cpp',
     'TaskQueue.cpp',
     'ThreadStackHelper.cpp',
     'ThrottledEventQueue.cpp',
     'TimerThread.cpp',
diff --git a/xpcom/threads/nsINamed.idl b/xpcom/threads/nsINamed.idl
--- a/xpcom/threads/nsINamed.idl
+++ b/xpcom/threads/nsINamed.idl
@@ -16,17 +16,9 @@ interface nsINamed : nsISupports
      * A string describing the purpose of the runnable/timer/whatever. Useful
      * for debugging. This attribute is read-only, but you can change it to a
      * compile-time string literal with setName.
      *
      * WARNING: This attribute will be included in telemetry, so it should
      * never contain privacy sensitive information.
      */
     readonly attribute ACString name;
-
-    /*
-     * Note: The string you pass in should be a compile-time literal.
-     *
-     * WARNING: This value will be included in telemetry, so it should
-     * never contain privacy sensitive information.
-     */
-    [noscript] void setName(in string aName);
 };
diff --git a/xpcom/threads/nsThreadManager.cpp b/xpcom/threads/nsThreadManager.cpp
--- a/xpcom/threads/nsThreadManager.cpp
+++ b/xpcom/threads/nsThreadManager.cpp
@@ -325,17 +325,17 @@ nsThreadManager::GetMainThread(nsIThread
   NS_ADDREF(*aResult = mMainThread);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsThreadManager::GetCurrentThread(nsIThread** aResult)
 {
   // Keep this functioning during Shutdown
-  if (NS_WARN_IF(!mMainThread)) {
+  if (!mMainThread) {
     return NS_ERROR_NOT_INITIALIZED;
   }
   *aResult = GetCurrentThread();
   if (!*aResult) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
   NS_ADDREF(*aResult);
   return NS_OK;
diff --git a/xpcom/threads/nsThreadUtils.cpp b/xpcom/threads/nsThreadUtils.cpp
--- a/xpcom/threads/nsThreadUtils.cpp
+++ b/xpcom/threads/nsThreadUtils.cpp
@@ -60,25 +60,16 @@ Runnable::GetName(nsACString& aName)
     aName.AssignASCII(mName);
   } else {
     aName.Truncate();
   }
 #endif
   return NS_OK;
 }
 
-nsresult
-Runnable::SetName(const char* aName)
-{
-#ifndef RELEASE_OR_BETA
-  mName = aName;
-#endif
-  return NS_OK;
-}
-
 NS_IMPL_ISUPPORTS_INHERITED(CancelableRunnable, Runnable,
                             nsICancelableRunnable)
 
 nsresult
 CancelableRunnable::Cancel()
 {
   // Do nothing
   return NS_OK;
diff --git a/xpcom/threads/nsThreadUtils.h b/xpcom/threads/nsThreadUtils.h
--- a/xpcom/threads/nsThreadUtils.h
+++ b/xpcom/threads/nsThreadUtils.h
@@ -511,18 +511,18 @@ namespace detail {
 // An event that can be used to call a C++11 functions or function objects,
 // including lambdas. The function must have no required arguments, and must
 // return void.
 template<typename StoredFunction>
 class RunnableFunction : public Runnable
 {
 public:
   template <typename F>
-  explicit RunnableFunction(F&& aFunction)
-    : Runnable("RunnableFunction")
+  explicit RunnableFunction(const char* aName, F&& aFunction)
+    : Runnable(aName)
     , mFunction(Forward<F>(aFunction))
   { }
 
   NS_IMETHOD Run() override {
     static_assert(IsVoid<decltype(mFunction())>::value,
                   "The lambda must return void!");
     mFunction();
     return NS_OK;
@@ -531,31 +531,16 @@ private:
   StoredFunction mFunction;
 };
 
 // Type alias for NS_NewRunnableFunction
 template<typename Function>
 using RunnableFunctionImpl =
   // Make sure we store a non-reference in nsRunnableFunction.
   typename detail::RunnableFunction<typename RemoveReference<Function>::Type>;
-
-template <typename T>
-inline already_AddRefed<T>
-SetRunnableName(const char* aName, T* aObj)
-{
-#ifdef RELEASE_OR_BETA
-  return do_AddRef(aObj);
-#else
-  MOZ_RELEASE_ASSERT(aName);
-  RefPtr<T> ref(aObj);
-  ref->SetName(aName);
-  return ref.forget();
-#endif
-}
-
 } // namespace detail
 
 namespace detail {
 
 template<typename CVRemoved>
 struct IsRefcountedSmartPointerHelper : FalseType {};
 
 template<typename Pointee>
@@ -640,20 +625,19 @@ ToSupports(mozilla::Runnable *p)
 }
 
 template<typename Function>
 already_AddRefed<mozilla::Runnable>
 NS_NewRunnableFunction(const char* aName, Function&& aFunction)
 {
   // We store a non-reference in RunnableFunction, but still forward aFunction
   // to move if possible.
-  return mozilla::detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new mozilla::detail::RunnableFunctionImpl<Function>(
-      mozilla::Forward<Function>(aFunction)));
+      aName, mozilla::Forward<Function>(aFunction)));
 }
 
 namespace mozilla {
 namespace detail {
 
 already_AddRefed<nsITimer> CreateTimer();
 
 template <RunnableKind Kind>
@@ -717,17 +701,17 @@ class nsRunnableMethod
 {
   using BaseType = typename mozilla::Conditional<Kind == mozilla::Standard,
                                                  mozilla::Runnable,
                                                  typename mozilla::Conditional<
                                                    Kind == mozilla::Cancelable,
                                                    mozilla::CancelableRunnable,
                                                    mozilla::IdleRunnable>::Type>::Type;
 public:
-  nsRunnableMethod() : BaseType("nsRunnableMethod") {}
+  nsRunnableMethod(const char* aName) : BaseType(aName) {}
 
   virtual void Revoke() = 0;
 
   // These ReturnTypeEnforcer classes set up a blacklist for return types that
   // we know are not safe. The default ReturnTypeEnforcer compiles just fine but
   // already_AddRefed will not.
   template<typename OtherReturnType>
   class ReturnTypeEnforcer
@@ -1186,19 +1170,20 @@ private:
     static_assert(IsIdle(Kind), "Don't use me!");
     RefPtr<IdleRunnable> r = static_cast<IdleRunnable*>(aClosure);
     r->SetDeadline(TimeStamp());
     r->Run();
     r->Cancel();
   }
 public:
   template<typename ForwardedPtrType, typename... Args>
-  explicit RunnableMethodImpl(ForwardedPtrType&& aObj, Method aMethod,
-                              Args&&... aArgs)
-    : mReceiver(Forward<ForwardedPtrType>(aObj))
+  explicit RunnableMethodImpl(const char* aName, ForwardedPtrType&& aObj,
+                              Method aMethod, Args&&... aArgs)
+    : BaseType(aName)
+    , mReceiver(Forward<ForwardedPtrType>(aObj))
     , mMethod(aMethod)
     , mArgs(Forward<Args>(aArgs)...)
   {
     static_assert(sizeof...(Storages) == sizeof...(Args), "Storages and Args should have equal sizes");
   }
   NS_IMETHOD Run()
   {
     CancelTimer();
@@ -1397,188 +1382,174 @@ using NonOwningIdleRunnableMethodWithTim
 // that do not take a `const char*` as their first parameter; you may see
 // these in older code.  The `const char*` overload is preferred and
 // should be used in new code exclusively.
 
 template<typename PtrType, typename Method>
 already_AddRefed<detail::OwningRunnableMethod<PtrType, Method>>
 NewRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod)
 {
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::OwningRunnableMethodImpl<PtrType, Method>(
-      Forward<PtrType>(aPtr), aMethod));
+      aName, Forward<PtrType>(aPtr), aMethod));
 }
 
 template<typename PtrType, typename Method>
 already_AddRefed<detail::CancelableRunnableMethod<PtrType, Method>>
 NewCancelableRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod)
 {
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::CancelableRunnableMethodImpl<PtrType, Method>(
-      Forward<PtrType>(aPtr), aMethod));
+      aName, Forward<PtrType>(aPtr), aMethod));
 }
 
 template<typename PtrType, typename Method>
 already_AddRefed<detail::IdleRunnableMethod<PtrType, Method>>
 NewIdleRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod)
 {
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::IdleRunnableMethodImpl<PtrType, Method>(
-      Forward<PtrType>(aPtr), aMethod));
+      aName, Forward<PtrType>(aPtr), aMethod));
 }
 
 template<typename PtrType, typename Method>
 already_AddRefed<detail::IdleRunnableMethodWithTimer<PtrType, Method>>
 NewIdleRunnableMethodWithTimer(const char* aName,
                                PtrType&& aPtr,
                                Method aMethod)
 {
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::IdleRunnableMethodWithTimerImpl<PtrType, Method>(
-      Forward<PtrType>(aPtr), aMethod));
+      aName, Forward<PtrType>(aPtr), aMethod));
 }
 
 template<typename PtrType, typename Method>
 already_AddRefed<detail::NonOwningRunnableMethod<PtrType, Method>>
 NewNonOwningRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod)
 {
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::NonOwningRunnableMethodImpl<PtrType, Method>(
-      Forward<PtrType>(aPtr), aMethod));
+      aName, Forward<PtrType>(aPtr), aMethod));
 }
 
 template<typename PtrType, typename Method>
 already_AddRefed<detail::NonOwningCancelableRunnableMethod<PtrType, Method>>
 NewNonOwningCancelableRunnableMethod(const char* aName, PtrType&& aPtr,
                                      Method aMethod)
 {
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::NonOwningCancelableRunnableMethodImpl<PtrType, Method>(
-      Forward<PtrType>(aPtr), aMethod));
+      aName, Forward<PtrType>(aPtr), aMethod));
 }
 
 template<typename PtrType, typename Method>
 already_AddRefed<detail::NonOwningIdleRunnableMethod<PtrType, Method>>
 NewNonOwningIdleRunnableMethod(const char* aName,
                                PtrType&& aPtr,
                                Method aMethod)
 {
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::NonOwningIdleRunnableMethodImpl<PtrType, Method>(
-      Forward<PtrType>(aPtr), aMethod));
+      aName, Forward<PtrType>(aPtr), aMethod));
 }
 
 template<typename PtrType, typename Method>
 already_AddRefed<detail::NonOwningIdleRunnableMethodWithTimer<PtrType, Method>>
 NewNonOwningIdleRunnableMethodWithTimer(const char* aName,
                                         PtrType&& aPtr,
                                         Method aMethod)
 {
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::NonOwningIdleRunnableMethodWithTimerImpl<PtrType, Method>(
-      Forward<PtrType>(aPtr), aMethod));
+      aName, Forward<PtrType>(aPtr), aMethod));
 }
 
 // Similar to NewRunnableMethod. Call like so:
 // nsCOMPtr<nsIRunnable> event =
 //   NewRunnableMethod<Types,...>(myObject, &MyClass::HandleEvent, myArg1,...);
 // 'Types' are the stored type for each argument, see ParameterStorage for details.
 template<typename... Storages, typename PtrType, typename Method, typename... Args>
 already_AddRefed<detail::OwningRunnableMethod<PtrType, Method>>
 NewRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod, Args&&... aArgs)
 {
   static_assert(sizeof...(Storages) == sizeof...(Args),
                 "<Storages...> size should be equal to number of arguments");
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::OwningRunnableMethodImpl<PtrType, Method, Storages...>(
-      Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
+      aName, Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
 }
 
 template<typename... Storages, typename PtrType, typename Method, typename... Args>
 already_AddRefed<detail::NonOwningRunnableMethod<PtrType, Method>>
 NewNonOwningRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod,
                            Args&&... aArgs)
 {
   static_assert(sizeof...(Storages) == sizeof...(Args),
                 "<Storages...> size should be equal to number of arguments");
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::NonOwningRunnableMethodImpl<PtrType, Method, Storages...>(
-      Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
+      aName, Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
 }
 
 template<typename... Storages, typename PtrType, typename Method, typename... Args>
 already_AddRefed<detail::CancelableRunnableMethod<PtrType, Method>>
 NewCancelableRunnableMethod(const char* aName, PtrType&& aPtr, Method aMethod,
                             Args&&... aArgs)
 {
   static_assert(sizeof...(Storages) == sizeof...(Args),
                 "<Storages...> size should be equal to number of arguments");
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::CancelableRunnableMethodImpl<PtrType, Method, Storages...>(
-      Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
+      aName, Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
 }
 
 template<typename... Storages, typename PtrType, typename Method, typename... Args>
 already_AddRefed<detail::NonOwningCancelableRunnableMethod<PtrType, Method>>
 NewNonOwningCancelableRunnableMethod(const char* aName, PtrType&& aPtr,
                                      Method aMethod, Args&&... aArgs)
 {
   static_assert(sizeof...(Storages) == sizeof...(Args),
                 "<Storages...> size should be equal to number of arguments");
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::NonOwningCancelableRunnableMethodImpl<PtrType, Method, Storages...>(
-      Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
+      aName, Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
 }
 
 template<typename... Storages,
          typename PtrType,
          typename Method,
          typename... Args>
 already_AddRefed<detail::IdleRunnableMethod<PtrType, Method>>
 NewIdleRunnableMethod(const char* aName,
                       PtrType&& aPtr,
                       Method aMethod,
                       Args&&... aArgs)
 {
   static_assert(sizeof...(Storages) == sizeof...(Args),
                 "<Storages...> size should be equal to number of arguments");
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::IdleRunnableMethodImpl<PtrType, Method, Storages...>(
-      Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
+      aName, Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
 }
 
 template<typename... Storages,
          typename PtrType,
          typename Method,
          typename... Args>
 already_AddRefed<detail::NonOwningIdleRunnableMethod<PtrType, Method>>
 NewNonOwningIdleRunnableMethod(const char* aName,
                                PtrType&& aPtr,
                                Method aMethod,
                                Args&&... aArgs)
 {
   static_assert(sizeof...(Storages) == sizeof...(Args),
                 "<Storages...> size should be equal to number of arguments");
-  return detail::SetRunnableName(
-    aName,
+  return do_AddRef(
     new detail::NonOwningIdleRunnableMethodImpl<PtrType, Method, Storages...>(
-      Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
+      aName, Forward<PtrType>(aPtr), aMethod, mozilla::Forward<Args>(aArgs)...));
 }
 
 } // namespace mozilla
 
 #endif  // XPCOM_GLUE_AVOID_NSPR
 
 // This class is designed to be used when you have an event class E that has a
 // pointer back to resource class R.  If R goes away while E is still pending,
diff --git a/xpfe/appshell/nsWebShellWindow.cpp b/xpfe/appshell/nsWebShellWindow.cpp
--- a/xpfe/appshell/nsWebShellWindow.cpp
+++ b/xpfe/appshell/nsWebShellWindow.cpp
@@ -524,16 +524,17 @@ static void LoadNativeMenus(nsIDOMDocume
     nms->CreateNativeMenuBar(aParentWindow, nullptr);
   }
 }
 #endif
 
 namespace mozilla {
 
 class WebShellWindowTimerCallback final : public nsITimerCallback
+                                        , public nsINamed
 {
 public:
   explicit WebShellWindowTimerCallback(nsWebShellWindow* aWindow)
     : mWindow(aWindow)
   {}
 
   NS_DECL_THREADSAFE_ISUPPORTS
 
@@ -542,23 +543,29 @@ public:
     // Although this object participates in a refcount cycle (this -> mWindow
     // -> mSPTimer -> this), mSPTimer is a one-shot timer and releases this
     // after it fires.  So we don't need to release mWindow here.
 
     mWindow->FirePersistenceTimer();
     return NS_OK;
   }
 
+  NS_IMETHOD GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("WebShellWindowTimerCallback");
+    return NS_OK;
+  }
+
 private:
   ~WebShellWindowTimerCallback() {}
 
   RefPtr<nsWebShellWindow> mWindow;
 };
 
-NS_IMPL_ISUPPORTS(WebShellWindowTimerCallback, nsITimerCallback)
+NS_IMPL_ISUPPORTS(WebShellWindowTimerCallback, nsITimerCallback, nsINamed)
 
 } // namespace mozilla
 
 void
 nsWebShellWindow::SetPersistenceTimer(uint32_t aDirtyFlags)
 {
   MutexAutoLock lock(mSPTimerLock);
   if (!mSPTimer) {

